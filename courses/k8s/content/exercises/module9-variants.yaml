conceptLinks:
  ConfigMap Creation: "#lesson-configmaps"
  Using ConfigMaps: "#lesson-using-configmaps"
  Secret Creation: "#lesson-secrets"
  Using Secrets: "#lesson-using-secrets"
  Config Update Propagation: "#lesson-volume-mount-updates-the-propagation-rule"
  Immutable Configs: "#lesson-immutable-configmaps-and-secrets"
  Secret Security: "#lesson-secrets-are-not-encrypted"
  imagePullSecrets: "#lesson-imagepullsecrets-for-private-registries"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: ConfigMap Creation
      variants:
        - id: v1
          title: Basic ConfigMap YAML
          description: >-
            Write a <code>ConfigMap</code> named <code>app-config</code> in the <code>default</code> namespace with
            three key-value pairs: <code>DB_HOST: postgres</code>, <code>DB_PORT: "5432"</code>, and
            <code>LOG_LEVEL: info</code>.
          hints:
            - "Use <code>apiVersion: v1</code> and <code>kind: ConfigMap</code>."
            - "Put all key-value pairs under the <code>data</code> field."
            - "Numeric values like port numbers must be quoted as strings in ConfigMap data."
          solution: |-
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: app-config
              namespace: default
            data:
              DB_HOST: postgres
              DB_PORT: "5432"
              LOG_LEVEL: info
        - id: v2
          title: ConfigMap with Multi-line Value
          description: >-
            Write a <code>ConfigMap</code> named <code>nginx-conf</code> that contains a key
            <code>nginx.conf</code> with a multi-line nginx configuration as its value. Include
            <code>worker_processes auto;</code> and an <code>http</code> block with a server listening on port 80.
          hints:
            - "Use the YAML pipe (<code>|</code>) for multi-line values."
            - "The key name can contain dots, e.g. <code>nginx.conf</code>."
            - "Multi-line config files are stored as a single value under one key."
          solution: |-
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: nginx-conf
            data:
              nginx.conf: |
                worker_processes auto;
                events {
                    worker_connections 1024;
                }
                http {
                    server {
                        listen 80;
                        location / {
                            proxy_pass http://localhost:8080;
                        }
                    }
                }
        - id: v3
          title: kubectl create configmap from-literal
          description: >-
            Write the <code>kubectl</code> command to create a ConfigMap named <code>feature-flags</code> with
            two key-value pairs: <code>DARK_MODE=true</code> and <code>BETA_API=false</code>.
          hints:
            - "Use <code>kubectl create configmap</code> with <code>--from-literal</code> flags."
            - "Each key-value pair needs its own <code>--from-literal</code> flag."
            - "The format is <code>--from-literal=KEY=VALUE</code>."
          solution: |-
            kubectl create configmap feature-flags \
              --from-literal=DARK_MODE=true \
              --from-literal=BETA_API=false
        - id: v4
          title: kubectl create configmap from-file
          description: >-
            Write the <code>kubectl</code> command to create a ConfigMap named <code>app-settings</code>
            from a file called <code>settings.properties</code>. The filename should become the key.
          hints:
            - "Use <code>kubectl create configmap</code> with <code>--from-file</code>."
            - "When using <code>--from-file=filename</code>, the filename becomes the key automatically."
            - "The file contents become the value."
          solution: |-
            kubectl create configmap app-settings \
              --from-file=settings.properties
        - id: v5
          title: kubectl create configmap from-file with Custom Key
          description: >-
            Write the <code>kubectl</code> command to create a ConfigMap named <code>app-settings</code>
            from a file called <code>settings.properties</code>, but use <code>app.conf</code> as the key
            instead of the filename.
          hints:
            - "Use the <code>--from-file=KEY=FILEPATH</code> syntax to set a custom key."
            - "The format is <code>--from-file=custom-key=actual-file</code>."
            - "This is useful when you need the key to differ from the filename on disk."
          solution: |-
            kubectl create configmap app-settings \
              --from-file=app.conf=settings.properties
        - id: v6
          title: ConfigMap from a Directory
          description: >-
            Write the <code>kubectl</code> command to create a ConfigMap named <code>all-configs</code>
            from a directory called <code>config-dir/</code>. Every file in the directory should become a
            key in the ConfigMap.
          hints:
            - "Use <code>--from-file=directory/</code> to load all files."
            - "Each file in the directory becomes a separate key."
            - "The trailing slash is optional but conventional."
          solution: |-
            kubectl create configmap all-configs \
              --from-file=config-dir/
        - id: v7
          title: ConfigMap with JSON Config File
          description: >-
            Write a <code>ConfigMap</code> named <code>webapp-config</code> with a key <code>config.json</code>
            containing a JSON object with <code>"features"</code> (an object with <code>"dark_mode": true</code>)
            and <code>"cache_ttl": 300</code>.
          hints:
            - "Use the YAML pipe (<code>|</code>) to embed the JSON as a multi-line string."
            - "The entire JSON document is a single value under the <code>config.json</code> key."
            - "Indentation inside the pipe block is preserved as-is."
          solution: |-
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: webapp-config
            data:
              config.json: |
                {
                  "features": {
                    "dark_mode": true
                  },
                  "cache_ttl": 300
                }
        - id: v8
          title: ConfigMap with Mixed Keys
          description: >-
            Write a <code>ConfigMap</code> named <code>mixed-config</code> with simple key-value pairs
            (<code>APP_ENV: production</code>, <code>APP_PORT: "8080"</code>) and a multi-line
            <code>app.properties</code> file containing <code>server.port=8080</code> and
            <code>server.context-path=/api</code>.
          hints:
            - "Simple key-value pairs and multi-line values can coexist under <code>data</code>."
            - "Use the pipe (<code>|</code>) only for the multi-line value."
            - "Quote numeric values like <code>\"8080\"</code> so they are treated as strings."
          solution: |-
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: mixed-config
            data:
              APP_ENV: production
              APP_PORT: "8080"
              app.properties: |
                server.port=8080
                server.context-path=/api
        - id: v9
          title: Immutable ConfigMap
          description: >-
            Write an immutable <code>ConfigMap</code> named <code>app-config-v3</code> with
            <code>DB_HOST: prod-postgres.internal</code> and <code>LOG_LEVEL: warn</code>.
            Once created, this ConfigMap cannot be modified.
          hints:
            - "Add <code>immutable: true</code> at the top level of the ConfigMap spec."
            - "Immutable ConfigMaps must be deleted and recreated to change their data."
            - "The <code>immutable</code> field is a boolean at the same level as <code>data</code>."
          solution: |-
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: app-config-v3
            data:
              DB_HOST: prod-postgres.internal
              LOG_LEVEL: warn
            immutable: true
        - id: v10
          title: ConfigMap with binaryData Reference
          description: >-
            Write a <code>ConfigMap</code> named <code>tls-config</code> that has a regular data key
            <code>TLS_ENABLED: "true"</code> and a <code>binaryData</code> key <code>keystore.jks</code>
            with base64-encoded content <code>SGVsbG8gV29ybGQ=</code>.
          hints:
            - "Use the <code>data</code> field for plain text and <code>binaryData</code> for binary content."
            - "The <code>binaryData</code> field is a sibling of <code>data</code>, not nested inside it."
            - "Values in <code>binaryData</code> must be base64-encoded."
          solution: |-
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: tls-config
            data:
              TLS_ENABLED: "true"
            binaryData:
              keystore.jks: SGVsbG8gV29ybGQ=
        - id: v11
          title: ConfigMap in a Specific Namespace
          description: >-
            Write a <code>ConfigMap</code> named <code>cache-config</code> in the <code>staging</code> namespace
            with keys <code>REDIS_HOST: redis.staging.svc</code>, <code>REDIS_PORT: "6379"</code>, and
            <code>CACHE_TTL: "600"</code>.
          hints:
            - "Set the namespace in <code>metadata.namespace</code>."
            - "ConfigMaps are namespaced resources -- they exist within a single namespace."
            - "Pods can only reference ConfigMaps in the same namespace."
          solution: |-
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: cache-config
              namespace: staging
            data:
              REDIS_HOST: redis.staging.svc
              REDIS_PORT: "6379"
              CACHE_TTL: "600"
    - id: warmup_2
      concept: Using ConfigMaps
      variants:
        - id: v1
          title: Single Key as Env Var (valueFrom)
          description: >-
            Write a Pod spec snippet that injects the key <code>DB_HOST</code> from a ConfigMap named
            <code>app-config</code> into an environment variable called <code>DATABASE_HOST</code>.
            Use <code>valueFrom.configMapKeyRef</code>.
          hints:
            - "Use <code>env</code> with <code>valueFrom.configMapKeyRef</code> on the container."
            - "The <code>name</code> field references the ConfigMap, <code>key</code> references the specific key."
            - "The env var name (<code>DATABASE_HOST</code>) can differ from the ConfigMap key (<code>DB_HOST</code>)."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                env:
                - name: DATABASE_HOST
                  valueFrom:
                    configMapKeyRef:
                      name: app-config
                      key: DB_HOST
        - id: v2
          title: Multiple Keys as Env Vars
          description: >-
            Write a Pod spec that injects <code>DB_HOST</code>, <code>DB_PORT</code>, and <code>LOG_LEVEL</code>
            from ConfigMap <code>app-config</code> as environment variables with the same names.
          hints:
            - "Each key needs its own <code>env</code> entry with <code>valueFrom.configMapKeyRef</code>."
            - "When you want the env var name to match the ConfigMap key, use the same string for both."
            - "List all three entries under the container's <code>env</code> array."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                env:
                - name: DB_HOST
                  valueFrom:
                    configMapKeyRef:
                      name: app-config
                      key: DB_HOST
                - name: DB_PORT
                  valueFrom:
                    configMapKeyRef:
                      name: app-config
                      key: DB_PORT
                - name: LOG_LEVEL
                  valueFrom:
                    configMapKeyRef:
                      name: app-config
                      key: LOG_LEVEL
        - id: v3
          title: All Keys as Env Vars (envFrom)
          description: >-
            Write a Pod spec that injects all keys from ConfigMap <code>app-config</code> as environment
            variables using <code>envFrom</code>.
          hints:
            - "Use <code>envFrom</code> with <code>configMapRef</code> instead of individual <code>env</code> entries."
            - "<code>envFrom</code> is a list at the container level, not nested under <code>env</code>."
            - "Every key in the ConfigMap becomes an env var with the same name."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                envFrom:
                - configMapRef:
                    name: app-config
        - id: v4
          title: envFrom with Prefix
          description: >-
            Write a Pod spec that injects all keys from ConfigMap <code>app-config</code> as environment
            variables, but with the prefix <code>CFG_</code> added to every key name.
          hints:
            - "Add <code>prefix: CFG_</code> alongside <code>configMapRef</code> in the <code>envFrom</code> entry."
            - "With prefix, a key <code>DB_HOST</code> becomes env var <code>CFG_DB_HOST</code>."
            - "The prefix is optional and useful to avoid naming collisions."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                envFrom:
                - configMapRef:
                    name: app-config
                  prefix: CFG_
        - id: v5
          title: Mount ConfigMap as Volume
          description: >-
            Write a Pod spec that mounts ConfigMap <code>nginx-conf</code> as a volume at
            <code>/etc/nginx/conf.d</code> (read-only). Each key in the ConfigMap becomes a file.
          hints:
            - "Define a volume with <code>configMap.name</code> under <code>spec.volumes</code>."
            - "Reference that volume in the container's <code>volumeMounts</code> with a <code>mountPath</code>."
            - "Set <code>readOnly: true</code> on the volumeMount for safety."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: nginx
            spec:
              containers:
              - name: nginx
                image: nginx:1.25
                volumeMounts:
                - name: config-volume
                  mountPath: /etc/nginx/conf.d
                  readOnly: true
              volumes:
              - name: config-volume
                configMap:
                  name: nginx-conf
        - id: v6
          title: Mount Specific Key to Specific Path
          description: >-
            Write a Pod spec that mounts only the <code>nginx.conf</code> key from ConfigMap
            <code>app-config</code> as a file at <code>/etc/nginx/conf.d/default.conf</code>.
          hints:
            - "Use <code>items</code> in the volume definition to select specific keys."
            - "Each item maps a <code>key</code> to a <code>path</code> (filename)."
            - "The <code>mountPath</code> is the directory; the <code>path</code> in items is the filename within it."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: nginx
            spec:
              containers:
              - name: nginx
                image: nginx:1.25
                volumeMounts:
                - name: config-volume
                  mountPath: /etc/nginx/conf.d
                  readOnly: true
              volumes:
              - name: config-volume
                configMap:
                  name: app-config
                  items:
                  - key: nginx.conf
                    path: default.conf
        - id: v7
          title: Optional ConfigMap Key Reference
          description: >-
            Write a Pod spec that injects the key <code>LOG_LEVEL</code> from ConfigMap
            <code>app-config</code> as an env var, but marks it as <code>optional</code> so the Pod
            starts even if the key is missing.
          hints:
            - "Add <code>optional: true</code> to the <code>configMapKeyRef</code>."
            - "Without <code>optional: true</code>, the Pod will fail to start if the key or ConfigMap is missing."
            - "This is useful for optional configuration with sensible defaults in your app."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                env:
                - name: LOG_LEVEL
                  valueFrom:
                    configMapKeyRef:
                      name: app-config
                      key: LOG_LEVEL
                      optional: true
        - id: v8
          title: ConfigMap Volume with subPath
          description: >-
            Write a Pod spec that mounts only the <code>default.conf</code> key from ConfigMap
            <code>nginx-conf</code> directly to the path <code>/etc/nginx/conf.d/default.conf</code>
            using <code>subPath</code>. Note that subPath mounts do not auto-update.
          hints:
            - "Set <code>mountPath</code> to the full file path, not just the directory."
            - "Set <code>subPath</code> to the key name in the ConfigMap."
            - "subPath creates a direct bind mount, bypassing the symlink-based auto-update mechanism."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: nginx
            spec:
              containers:
              - name: nginx
                image: nginx:1.25
                volumeMounts:
                - name: config-volume
                  mountPath: /etc/nginx/conf.d/default.conf
                  subPath: default.conf
              volumes:
              - name: config-volume
                configMap:
                  name: nginx-conf
        - id: v9
          title: Deployment with ConfigMap envFrom
          description: >-
            Write a Deployment named <code>web</code> with 2 replicas that injects all keys from ConfigMap
            <code>web-config</code> as env vars using <code>envFrom</code>. Use image <code>nginx:1.25</code>.
          hints:
            - "The <code>envFrom</code> goes inside the container spec within the Pod template."
            - "A Deployment wraps the Pod spec in <code>spec.template.spec</code>."
            - "Don't forget <code>selector.matchLabels</code> matching the template labels."
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: web
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: web
              template:
                metadata:
                  labels:
                    app: web
                spec:
                  containers:
                  - name: web
                    image: nginx:1.25
                    envFrom:
                    - configMapRef:
                        name: web-config
        - id: v10
          title: Deployment with ConfigMap Volume Mount
          description: >-
            Write a Deployment named <code>api-server</code> with 3 replicas and image <code>myapi:v2</code>.
            Mount ConfigMap <code>api-config</code> as a read-only volume at <code>/app/config</code>.
          hints:
            - "Define the volume under <code>spec.template.spec.volumes</code>."
            - "Reference the volume in <code>spec.template.spec.containers[].volumeMounts</code>."
            - "The volume name must match between <code>volumes</code> and <code>volumeMounts</code>."
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: api-server
            spec:
              replicas: 3
              selector:
                matchLabels:
                  app: api-server
              template:
                metadata:
                  labels:
                    app: api-server
                spec:
                  containers:
                  - name: api-server
                    image: myapi:v2
                    volumeMounts:
                    - name: config-volume
                      mountPath: /app/config
                      readOnly: true
                  volumes:
                  - name: config-volume
                    configMap:
                      name: api-config
    - id: warmup_3
      concept: Secret Creation
      variants:
        - id: v1
          title: Opaque Secret with data (base64)
          description: >-
            Write an <code>Opaque</code> Secret named <code>db-creds</code> using the <code>data</code> field
            with base64-encoded values. The username is <code>admin</code> (base64: <code>YWRtaW4=</code>) and
            the password is <code>s3cret</code> (base64: <code>czNjcmV0</code>).
          hints:
            - "Use <code>type: Opaque</code> for generic secrets."
            - "Values under <code>data</code> must be base64-encoded."
            - "You can encode with <code>echo -n \"admin\" | base64</code>."
          solution: |-
            apiVersion: v1
            kind: Secret
            metadata:
              name: db-creds
            type: Opaque
            data:
              username: YWRtaW4=
              password: czNjcmV0
        - id: v2
          title: Opaque Secret with stringData
          description: >-
            Write an <code>Opaque</code> Secret named <code>db-creds</code> using the <code>stringData</code>
            field with plain text values: username <code>admin</code> and password <code>s3cret!P@ss</code>.
          hints:
            - "<code>stringData</code> accepts plain text -- Kubernetes base64-encodes it on apply."
            - "<code>stringData</code> is write-only: <code>kubectl get secret -o yaml</code> always shows <code>data</code>."
            - "Quote passwords with special characters to avoid YAML parsing issues."
          solution: |-
            apiVersion: v1
            kind: Secret
            metadata:
              name: db-creds
            type: Opaque
            stringData:
              username: admin
              password: "s3cret!P@ss"
        - id: v3
          title: kubectl create secret generic
          description: >-
            Write the <code>kubectl</code> command to create a generic Secret named <code>api-creds</code>
            with <code>API_KEY=sk-abc123</code> and <code>API_SECRET=supersecret</code>.
          hints:
            - "Use <code>kubectl create secret generic</code> with <code>--from-literal</code> flags."
            - "The syntax is the same as ConfigMap creation, just <code>secret generic</code> instead of <code>configmap</code>."
            - "Kubernetes automatically base64-encodes the values."
          solution: |-
            kubectl create secret generic api-creds \
              --from-literal=API_KEY=sk-abc123 \
              --from-literal=API_SECRET=supersecret
        - id: v4
          title: kubectl create secret from File
          description: >-
            Write the <code>kubectl</code> command to create a generic Secret named <code>ssh-key</code>
            from a file called <code>id_rsa</code>.
          hints:
            - "Use <code>kubectl create secret generic</code> with <code>--from-file</code>."
            - "The filename becomes the key in the Secret."
            - "File contents are automatically base64-encoded."
          solution: |-
            kubectl create secret generic ssh-key \
              --from-file=id_rsa
        - id: v5
          title: TLS Secret
          description: >-
            Write the <code>kubectl</code> command to create a TLS Secret named <code>my-tls-cert</code>
            from certificate file <code>tls.crt</code> and key file <code>tls.key</code>.
          hints:
            - "Use <code>kubectl create secret tls</code> (not <code>generic</code>)."
            - "Use <code>--cert</code> and <code>--key</code> flags for the certificate and private key."
            - "The Secret type will be <code>kubernetes.io/tls</code> with keys <code>tls.crt</code> and <code>tls.key</code>."
          solution: |-
            kubectl create secret tls my-tls-cert \
              --cert=tls.crt \
              --key=tls.key
        - id: v6
          title: Docker Registry Secret
          description: >-
            Write the <code>kubectl</code> command to create a Docker registry Secret named
            <code>regcred</code> for <code>ghcr.io</code> with username <code>myuser</code>,
            password <code>ghp_token123</code>, and email <code>me@example.com</code>.
          hints:
            - "Use <code>kubectl create secret docker-registry</code>."
            - "Required flags: <code>--docker-server</code>, <code>--docker-username</code>, <code>--docker-password</code>."
            - "The Secret type will be <code>kubernetes.io/dockerconfigjson</code>."
          solution: |-
            kubectl create secret docker-registry regcred \
              --docker-server=ghcr.io \
              --docker-username=myuser \
              --docker-password=ghp_token123 \
              --docker-email=me@example.com
        - id: v7
          title: Secret with Mixed data and stringData
          description: >-
            Write a Secret named <code>mixed-creds</code> that uses <code>data</code> for a base64-encoded
            username <code>YWRtaW4=</code> and <code>stringData</code> for a plain-text password
            <code>newpassword</code>. Both fields can coexist in the same Secret.
          hints:
            - "You can mix <code>data</code> and <code>stringData</code> in the same Secret."
            - "<code>stringData</code> values override <code>data</code> values for the same key."
            - "This is useful when some values are already base64-encoded and others are not."
          solution: |-
            apiVersion: v1
            kind: Secret
            metadata:
              name: mixed-creds
            type: Opaque
            data:
              username: YWRtaW4=
            stringData:
              password: newpassword
        - id: v8
          title: Immutable Secret
          description: >-
            Write an immutable Secret named <code>db-creds-v2</code> using <code>stringData</code> with
            username <code>admin</code> and password <code>n3w-s3cret</code>. Once created, this Secret
            cannot be modified.
          hints:
            - "Add <code>immutable: true</code> at the top level, same as with ConfigMaps."
            - "Immutable Secrets reduce kubelet watch overhead at scale."
            - "You must delete and recreate the Secret to change its data."
          solution: |-
            apiVersion: v1
            kind: Secret
            metadata:
              name: db-creds-v2
            type: Opaque
            stringData:
              username: admin
              password: "n3w-s3cret"
            immutable: true
        - id: v9
          title: Secret with Multi-line Value
          description: >-
            Write a Secret named <code>app-cert</code> using <code>stringData</code> that contains a key
            <code>ca.crt</code> with a multi-line PEM-formatted certificate placeholder
            (<code>-----BEGIN CERTIFICATE-----</code> ... <code>-----END CERTIFICATE-----</code>).
          hints:
            - "Use <code>stringData</code> with a YAML pipe (<code>|</code>) for multi-line values."
            - "The entire certificate is stored as a single value under one key."
            - "In production, you would paste the actual PEM content here."
          solution: |-
            apiVersion: v1
            kind: Secret
            metadata:
              name: app-cert
            type: Opaque
            stringData:
              ca.crt: |
                -----BEGIN CERTIFICATE-----
                MIICpDCCAYwCCQDU+pQ4pHgSpDANBgkqhkiG9w0BAQsFADAU
                MRIwEAYDVQQDDAlsb2NhbGhvc3QwHhcNMjQwMTAxMDAwMMDFk
                -----END CERTIFICATE-----
        - id: v10
          title: Secret in a Specific Namespace
          description: >-
            Write an Opaque Secret named <code>payment-keys</code> in the <code>production</code> namespace
            with <code>stringData</code> keys <code>STRIPE_KEY: sk_live_abc123</code> and
            <code>STRIPE_SECRET: whsec_xyz789</code>.
          hints:
            - "Set the namespace in <code>metadata.namespace</code>."
            - "Secrets are namespaced -- Pods can only reference Secrets in the same namespace."
            - "Use <code>stringData</code> so you don't have to manually base64-encode."
          solution: |-
            apiVersion: v1
            kind: Secret
            metadata:
              name: payment-keys
              namespace: production
            type: Opaque
            stringData:
              STRIPE_KEY: sk_live_abc123
              STRIPE_SECRET: whsec_xyz789
        - id: v11
          title: Decode a base64 Secret Value
          description: >-
            Given the base64-encoded Secret value <code>czNjcmV0IVBAc3M=</code>, write the <code>bash</code>
            command to decode it and show the plain text. Also write the command to encode the string
            <code>mypassword</code> to base64.
          hints:
            - "Use <code>echo \"...\" | base64 -d</code> to decode (the <code>-d</code> flag means decode)."
            - "Use <code>echo -n \"mypassword\" | base64</code> to encode (the <code>-n</code> flag avoids a trailing newline)."
            - "The <code>-n</code> flag on echo is critical -- without it, the newline character gets encoded too."
          solution: |-
            # Decode
            echo "czNjcmV0IVBAc3M=" | base64 -d
            # Output: s3cret!P@ss

            # Encode
            echo -n "mypassword" | base64
            # Output: bXlwYXNzd29yZA==
    - id: warmup_4
      concept: Using Secrets
      variants:
        - id: v1
          title: Secret as Env Var (secretKeyRef)
          description: >-
            Write a Pod spec that injects <code>username</code> and <code>password</code> from Secret
            <code>db-creds</code> as environment variables <code>DB_USERNAME</code> and
            <code>DB_PASSWORD</code>.
          hints:
            - "Use <code>valueFrom.secretKeyRef</code> instead of <code>configMapKeyRef</code>."
            - "The structure is identical to ConfigMap env vars, just with <code>secretKeyRef</code>."
            - "The <code>name</code> references the Secret, <code>key</code> references the key within it."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                env:
                - name: DB_USERNAME
                  valueFrom:
                    secretKeyRef:
                      name: db-creds
                      key: username
                - name: DB_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: db-creds
                      key: password
        - id: v2
          title: Secret as envFrom
          description: >-
            Write a Pod spec that injects all keys from Secret <code>app-secrets</code> as environment
            variables using <code>envFrom</code>.
          hints:
            - "Use <code>envFrom</code> with <code>secretRef</code> instead of <code>configMapRef</code>."
            - "Every key in the Secret becomes an env var."
            - "Values are automatically base64-decoded when injected as env vars."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                envFrom:
                - secretRef:
                    name: app-secrets
        - id: v3
          title: Mount Secret as Volume
          description: >-
            Write a Pod spec that mounts Secret <code>db-creds</code> as a read-only volume at
            <code>/etc/secrets</code> with file permissions <code>0400</code>.
          hints:
            - "Use a <code>secret</code> volume type with <code>secretName</code> (not <code>name</code>)."
            - "Set <code>defaultMode: 0400</code> for read-only owner permissions (security best practice)."
            - "Each key in the Secret becomes a file at the mount path."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                volumeMounts:
                - name: secret-volume
                  mountPath: /etc/secrets
                  readOnly: true
              volumes:
              - name: secret-volume
                secret:
                  secretName: db-creds
                  defaultMode: 0400
        - id: v4
          title: Mount Specific Secret Key
          description: >-
            Write a Pod spec that mounts only the <code>password</code> key from Secret
            <code>db-creds</code> as a file at <code>/etc/secrets/db-password</code>.
          hints:
            - "Use <code>items</code> in the secret volume to select specific keys."
            - "Map <code>key: password</code> to <code>path: db-password</code>."
            - "The <code>mountPath</code> is the directory; the <code>path</code> in items is the filename."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                volumeMounts:
                - name: secret-volume
                  mountPath: /etc/secrets
                  readOnly: true
              volumes:
              - name: secret-volume
                secret:
                  secretName: db-creds
                  items:
                  - key: password
                    path: db-password
        - id: v5
          title: imagePullSecrets
          description: >-
            Write a Pod spec for image <code>ghcr.io/myorg/myapp:v1</code> that uses Secret
            <code>regcred</code> as an <code>imagePullSecrets</code> entry to authenticate with the
            private registry.
          hints:
            - "<code>imagePullSecrets</code> is a list at <code>spec</code> level, not inside a container."
            - "Each entry is an object with a <code>name</code> field referencing a docker-registry Secret."
            - "The Secret type must be <code>kubernetes.io/dockerconfigjson</code>."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              imagePullSecrets:
              - name: regcred
              containers:
              - name: myapp
                image: ghcr.io/myorg/myapp:v1
        - id: v6
          title: Deployment with imagePullSecrets
          description: >-
            Write a Deployment named <code>private-app</code> with 2 replicas using image
            <code>registry.example.com/app:v3</code> and <code>imagePullSecrets</code> referencing
            Secret <code>registry-auth</code>.
          hints:
            - "<code>imagePullSecrets</code> goes in the Pod template spec, not the Deployment spec."
            - "Place it at <code>spec.template.spec.imagePullSecrets</code>."
            - "The Secret must exist in the same namespace as the Deployment."
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: private-app
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: private-app
              template:
                metadata:
                  labels:
                    app: private-app
                spec:
                  imagePullSecrets:
                  - name: registry-auth
                  containers:
                  - name: app
                    image: registry.example.com/app:v3
        - id: v7
          title: Secret Volume with defaultMode
          description: >-
            Write a Pod spec that mounts Secret <code>tls-certs</code> at <code>/etc/tls</code> with
            file permissions <code>0444</code> (readable by all) instead of the default. Explain when
            you might use different permission modes.
          hints:
            - "Set <code>defaultMode</code> on the secret volume definition."
            - "The value is an octal number: <code>0400</code> = owner read, <code>0444</code> = all read."
            - "Use restrictive modes (<code>0400</code>) for private keys, and more permissive for public certs."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                volumeMounts:
                - name: tls-volume
                  mountPath: /etc/tls
                  readOnly: true
              volumes:
              - name: tls-volume
                secret:
                  secretName: tls-certs
                  defaultMode: 0444
        - id: v8
          title: Combine ConfigMap and Secret Env Vars
          description: >-
            Write a Pod spec that gets <code>APP_ENV</code> from ConfigMap <code>app-config</code>
            (using <code>envFrom</code>) and <code>DB_PASSWORD</code> from Secret <code>db-creds</code>
            (using <code>valueFrom.secretKeyRef</code>).
          hints:
            - "You can use both <code>envFrom</code> and <code>env</code> on the same container."
            - "Specific <code>env</code> entries override values from <code>envFrom</code> for the same key."
            - "This pattern is common: non-sensitive config via envFrom, secrets via individual env entries."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                envFrom:
                - configMapRef:
                    name: app-config
                env:
                - name: DB_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: db-creds
                      key: password
        - id: v9
          title: Patch ServiceAccount with imagePullSecrets
          description: >-
            Write the <code>kubectl</code> command to patch the <code>default</code> ServiceAccount so that
            all Pods using it automatically get <code>imagePullSecrets</code> referencing Secret <code>regcred</code>.
          hints:
            - "Use <code>kubectl patch serviceaccount</code> with <code>-p</code> for a JSON patch."
            - "The patch sets the <code>imagePullSecrets</code> field on the ServiceAccount."
            - "This applies namespace-wide to all Pods using the <code>default</code> ServiceAccount."
          solution: |-
            kubectl patch serviceaccount default \
              -p '{"imagePullSecrets": [{"name": "regcred"}]}'
        - id: v10
          title: Secret with Projected Volume
          description: >-
            Write a Pod spec that mounts both ConfigMap <code>app-config</code> and Secret
            <code>app-secrets</code> into the same directory <code>/etc/app</code> using a
            <code>projected</code> volume.
          hints:
            - "A <code>projected</code> volume lets you combine multiple sources into one mount path."
            - "List <code>configMap</code> and <code>secret</code> as <code>sources</code> inside the projected volume."
            - "Keys from all sources appear as files in the same directory."
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                volumeMounts:
                - name: app-volume
                  mountPath: /etc/app
                  readOnly: true
              volumes:
              - name: app-volume
                projected:
                  sources:
                  - configMap:
                      name: app-config
                  - secret:
                      name: app-secrets
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 3
      concept: Config Injection Patterns
      variants:
        - id: v1
          title: Full-Stack Config Injection
          description: >-
            Write a complete Deployment named <code>webapp</code> (2 replicas, image <code>myapp:v2</code>) that:
            <br>1. Injects all keys from ConfigMap <code>webapp-config</code> as env vars using <code>envFrom</code>
            <br>2. Injects <code>DB_PASSWORD</code> from Secret <code>db-creds</code> (key: <code>password</code>) as an env var
            <br>3. Mounts ConfigMap <code>webapp-config</code> key <code>config.json</code> as a file at <code>/etc/config/config.json</code>
            <br>4. Mounts Secret <code>db-creds</code> at <code>/etc/secrets</code> with mode <code>0400</code>
          functionSignature: "Deployment"
          testCases:
            - input: "ConfigMap webapp-config has APP_ENV=production, LOG_LEVEL=info, config.json={...}"
              output: "Pod gets env vars APP_ENV, LOG_LEVEL, DB_PASSWORD; files at /etc/config/config.json and /etc/secrets/"
            - input: "ConfigMap config.json updated"
              output: "Volume mount at /etc/config/config.json updates within ~60-90s; env vars do NOT update"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need four things on one container: envFrom (ConfigMap), env (Secret), and two volumeMounts
                (one for ConfigMap, one for Secret). Each volume needs a matching entry in spec.volumes.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>envFrom</code> with <code>configMapRef</code> for the ConfigMap env vars. Use a separate
                <code>env</code> entry with <code>secretKeyRef</code> for the password. Define two volumes: one
                <code>configMap</code> with <code>items</code> (to select just config.json) and one <code>secret</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Deployment metadata + spec + selector
                2. Pod template with containers:
                   - envFrom: configMapRef for all config keys
                   - env: secretKeyRef for DB_PASSWORD
                   - volumeMounts: two entries (config + secrets)
                3. volumes: configMap with items + secret with defaultMode</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: webapp
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: webapp
              template:
                metadata:
                  labels:
                    app: webapp
                spec:
                  containers:
                  - name: webapp
                    image: myapp:v2
                    envFrom:
                    - configMapRef:
                        name: webapp-config
                    env:
                    - name: DB_PASSWORD
                      valueFrom:
                        secretKeyRef:
                          name: db-creds
                          key: password
                    volumeMounts:
                    - name: config-files
                      mountPath: /etc/config
                      readOnly: true
                    - name: secret-files
                      mountPath: /etc/secrets
                      readOnly: true
                  volumes:
                  - name: config-files
                    configMap:
                      name: webapp-config
                      items:
                      - key: config.json
                        path: config.json
                  - name: secret-files
                    secret:
                      secretName: db-creds
                      defaultMode: 0400
          difficulty: 3
        - id: v2
          title: Multi-Container Config Sharing
          description: >-
            Write a Pod named <code>app-with-sidecar</code> with two containers:
            <br>1. <code>app</code> (image <code>myapp:v1</code>): gets <code>DB_HOST</code> from ConfigMap <code>app-config</code> as env var, mounts Secret <code>db-creds</code> at <code>/etc/secrets</code>
            <br>2. <code>log-shipper</code> (image <code>fluentd:v1</code>): mounts ConfigMap <code>fluentd-config</code> at <code>/etc/fluentd</code>
            <br>Both containers share a volume at <code>/var/log/app</code>.
          functionSignature: "Pod"
          testCases:
            - input: "Pod with two containers, each with different config sources"
              output: "app container has DB_HOST env var and Secret volume; log-shipper has ConfigMap volume; both share /var/log/app"
            - input: "Sidecar reads logs written by main container"
              output: "emptyDir volume at /var/log/app is shared between both containers"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each container can have its own volumeMounts and env vars, but volumes are defined at the Pod level.
                You need three volumes: a Secret, a ConfigMap, and an emptyDir for sharing logs.
            - title: "\U0001F4A1 Hint"
              content: >-
                Define three volumes at the Pod level: <code>db-creds</code> (secret), <code>fluentd-config</code>
                (configMap), and <code>shared-logs</code> (emptyDir). Each container mounts only the volumes it needs,
                plus the shared emptyDir.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Pod with two containers
                2. app container: env (configMapKeyRef) + 2 volumeMounts
                3. log-shipper container: 2 volumeMounts
                4. volumes: secret + configMap + emptyDir</pre>
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: app-with-sidecar
            spec:
              containers:
              - name: app
                image: myapp:v1
                env:
                - name: DB_HOST
                  valueFrom:
                    configMapKeyRef:
                      name: app-config
                      key: DB_HOST
                volumeMounts:
                - name: db-creds
                  mountPath: /etc/secrets
                  readOnly: true
                - name: shared-logs
                  mountPath: /var/log/app
              - name: log-shipper
                image: fluentd:v1
                volumeMounts:
                - name: fluentd-config
                  mountPath: /etc/fluentd
                  readOnly: true
                - name: shared-logs
                  mountPath: /var/log/app
              volumes:
              - name: db-creds
                secret:
                  secretName: db-creds
                  defaultMode: 0400
              - name: fluentd-config
                configMap:
                  name: fluentd-config
              - name: shared-logs
                emptyDir: {}
          difficulty: 3
        - id: v3
          title: Init Container Config Loading
          description: >-
            Write a Pod named <code>webapp</code> with an init container (<code>config-loader</code>, image
            <code>busybox:1.36</code>) that reads ConfigMap <code>app-template</code> from
            <code>/etc/template/app.conf</code> and writes a processed version to <code>/app/config/app.conf</code>.
            The main container (<code>webapp</code>, image <code>myapp:v1</code>) reads from <code>/app/config</code>.
            Use an emptyDir to share data between init and main containers.
          functionSignature: "Pod"
          testCases:
            - input: "Init container processes config template, main container reads result"
              output: "Init runs first, writes to shared emptyDir; main container starts with processed config"
            - input: "ConfigMap app-template contains app.conf key"
              output: "Init reads from /etc/template/app.conf (ConfigMap volume), writes to /app/config/app.conf (emptyDir)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Init containers run before the main container. You need a ConfigMap volume for the template and
                an emptyDir for the processed output. Both init and main containers mount the emptyDir.
            - title: "\U0001F4A1 Hint"
              content: >-
                The init container needs two volumeMounts: the ConfigMap at <code>/etc/template</code> (read) and
                the emptyDir at <code>/app/config</code> (write). The main container only needs the emptyDir mount.
                Use a simple <code>cp</code> or <code>sed</code> command in the init container.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. initContainers with config-loader:
                   - mounts: ConfigMap + emptyDir
                   - command: process template, write output
                2. containers with webapp:
                   - mounts: emptyDir only
                3. volumes: configMap + emptyDir</pre>
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: webapp
            spec:
              initContainers:
              - name: config-loader
                image: busybox:1.36
                command: ["/bin/sh", "-c"]
                args:
                - cp /etc/template/app.conf /app/config/app.conf
                volumeMounts:
                - name: config-template
                  mountPath: /etc/template
                  readOnly: true
                - name: processed-config
                  mountPath: /app/config
              containers:
              - name: webapp
                image: myapp:v1
                volumeMounts:
                - name: processed-config
                  mountPath: /app/config
                  readOnly: true
              volumes:
              - name: config-template
                configMap:
                  name: app-template
              - name: processed-config
                emptyDir: {}
          difficulty: 2
        - id: v4
          title: Environment-Specific Deployment
          description: >-
            Write a Deployment named <code>api</code> (3 replicas, image <code>api:v3</code>) that combines
            config from multiple sources:
            <br>1. <code>envFrom</code> from ConfigMap <code>shared-config</code> (common settings)
            <br>2. <code>envFrom</code> from ConfigMap <code>env-config</code> with prefix <code>ENV_</code> (environment-specific)
            <br>3. Individual Secret env vars for <code>DB_PASSWORD</code> and <code>API_KEY</code> from Secret <code>api-secrets</code>
            <br>4. A ConfigMap volume mount at <code>/etc/app</code> for config files
          functionSignature: "Deployment"
          testCases:
            - input: "shared-config: APP_NAME=myapi; env-config: DB_HOST=prod-db"
              output: "Container gets APP_NAME=myapi, ENV_DB_HOST=prod-db, DB_PASSWORD=***, API_KEY=***"
            - input: "Two envFrom sources with different prefixes"
              output: "shared-config keys are unprefixed; env-config keys get ENV_ prefix"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You can have multiple <code>envFrom</code> entries, each from a different ConfigMap or Secret.
                Individual <code>env</code> entries take precedence over <code>envFrom</code> for the same key.
            - title: "\U0001F4A1 Hint"
              content: >-
                List two entries in <code>envFrom</code>: one <code>configMapRef</code> without prefix, one with
                <code>prefix: ENV_</code>. Then add two <code>env</code> entries with <code>secretKeyRef</code>.
                Finally, add a volume and volumeMount for the config files.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. envFrom: [shared-config (no prefix), env-config (prefix ENV_)]
                2. env: [DB_PASSWORD from secret, API_KEY from secret]
                3. volumeMounts: config-files at /etc/app
                4. volumes: configMap shared-config</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: api
            spec:
              replicas: 3
              selector:
                matchLabels:
                  app: api
              template:
                metadata:
                  labels:
                    app: api
                spec:
                  containers:
                  - name: api
                    image: api:v3
                    envFrom:
                    - configMapRef:
                        name: shared-config
                    - configMapRef:
                        name: env-config
                      prefix: ENV_
                    env:
                    - name: DB_PASSWORD
                      valueFrom:
                        secretKeyRef:
                          name: api-secrets
                          key: DB_PASSWORD
                    - name: API_KEY
                      valueFrom:
                        secretKeyRef:
                          name: api-secrets
                          key: API_KEY
                    volumeMounts:
                    - name: config-files
                      mountPath: /etc/app
                      readOnly: true
                  volumes:
                  - name: config-files
                    configMap:
                      name: shared-config
          difficulty: 3
        - id: v5
          title: Complete App Stack with ConfigMap, Secret, and TLS
          description: >-
            Write a Deployment named <code>secure-app</code> (2 replicas, image <code>myapp:v2</code>) that:
            <br>1. Gets <code>APP_ENV</code> and <code>LOG_LEVEL</code> from ConfigMap <code>app-config</code> as env vars
            <br>2. Gets <code>DB_PASSWORD</code> from Secret <code>db-creds</code> as env var
            <br>3. Mounts TLS Secret <code>tls-cert</code> at <code>/etc/tls</code> with mode <code>0400</code>
            <br>4. Mounts ConfigMap <code>nginx-conf</code> at <code>/etc/nginx/conf.d</code>
            <br>5. Uses <code>imagePullSecrets</code> referencing <code>regcred</code>
          functionSignature: "Deployment"
          testCases:
            - input: "Deployment consuming ConfigMap env vars, Secret env var, TLS volume, ConfigMap volume, imagePullSecrets"
              output: "All five config sources properly injected into the Pod"
            - input: "Private registry image with TLS termination and database credentials"
              output: "Pod pulls from private registry, serves HTTPS with mounted TLS cert, connects to DB with Secret password"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This combines five different config injection patterns in one Deployment. Think about what goes
                where: env (for individual keys), volumeMounts (for files), volumes (at Pod level), and
                imagePullSecrets (also at Pod level).
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>env</code> with <code>configMapKeyRef</code> for the two ConfigMap keys and
                <code>secretKeyRef</code> for the password. Define two volumes (one secret, one configMap).
                Place <code>imagePullSecrets</code> at the same level as <code>containers</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. imagePullSecrets at spec.template.spec level
                2. containers[0]:
                   - env: APP_ENV (configMapKeyRef), LOG_LEVEL (configMapKeyRef),
                          DB_PASSWORD (secretKeyRef)
                   - volumeMounts: tls at /etc/tls, nginx at /etc/nginx/conf.d
                3. volumes: tls-cert (secret), nginx-conf (configMap)</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: secure-app
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: secure-app
              template:
                metadata:
                  labels:
                    app: secure-app
                spec:
                  imagePullSecrets:
                  - name: regcred
                  containers:
                  - name: secure-app
                    image: myapp:v2
                    env:
                    - name: APP_ENV
                      valueFrom:
                        configMapKeyRef:
                          name: app-config
                          key: APP_ENV
                    - name: LOG_LEVEL
                      valueFrom:
                        configMapKeyRef:
                          name: app-config
                          key: LOG_LEVEL
                    - name: DB_PASSWORD
                      valueFrom:
                        secretKeyRef:
                          name: db-creds
                          key: password
                    volumeMounts:
                    - name: tls-volume
                      mountPath: /etc/tls
                      readOnly: true
                    - name: nginx-config
                      mountPath: /etc/nginx/conf.d
                      readOnly: true
                  volumes:
                  - name: tls-volume
                    secret:
                      secretName: tls-cert
                      defaultMode: 0400
                  - name: nginx-config
                    configMap:
                      name: nginx-conf
          difficulty: 4
        - id: v6
          title: ConfigMap + Secret with Projected Volume
          description: >-
            Write a Pod named <code>combined-app</code> that uses a <code>projected</code> volume to mount
            both ConfigMap <code>app-config</code> and Secret <code>app-secrets</code> into a single
            directory <code>/etc/app</code>. Also inject <code>APP_ENV</code> from the ConfigMap as an env var.
          functionSignature: "Pod"
          testCases:
            - input: "ConfigMap has APP_ENV=prod, app.conf=...; Secret has db_password=..."
              output: "All keys from both sources appear as files in /etc/app; APP_ENV env var is set"
            - input: "Need ConfigMap and Secret files in the same directory"
              output: "Projected volume combines both into one mount point"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Normally you can't mount two volumes to the same path. A projected volume solves this by
                combining multiple sources (configMap, secret, serviceAccountToken, downwardAPI) into one volume.
            - title: "\U0001F4A1 Hint"
              content: >-
                Define a <code>projected</code> volume with two <code>sources</code>: one <code>configMap</code>
                and one <code>secret</code>. Mount it at <code>/etc/app</code>. Separately use <code>env</code>
                with <code>configMapKeyRef</code> for the environment variable.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. env: APP_ENV from configMapKeyRef
                2. volumeMounts: projected volume at /etc/app
                3. volumes: projected with sources:
                   - configMap: app-config
                   - secret: app-secrets</pre>
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: combined-app
            spec:
              containers:
              - name: app
                image: myapp:v1
                env:
                - name: APP_ENV
                  valueFrom:
                    configMapKeyRef:
                      name: app-config
                      key: APP_ENV
                volumeMounts:
                - name: app-volume
                  mountPath: /etc/app
                  readOnly: true
              volumes:
              - name: app-volume
                projected:
                  sources:
                  - configMap:
                      name: app-config
                  - secret:
                      name: app-secrets
          difficulty: 2
    - id: challenge_2
      block: 1
      difficulty: 2
      concept: Secret Security
      variants:
        - id: v1
          title: Identify the Security Issues
          description: >-
            This Secret YAML is checked into a git repository. Identify all the security issues:
            <br><pre>apiVersion: v1
            kind: Secret
            metadata:
              name: prod-db-creds
            type: Opaque
            data:
              username: YWRtaW4=
              password: cDRzc3cwcmQ=</pre>
            <br>List the issues and explain why base64 is not encryption. Then write the RBAC Role that would
            restrict read access to only this specific Secret in the <code>production</code> namespace.
          functionSignature: "Role"
          testCases:
            - input: "Secret YAML committed to git with base64-encoded values"
              output: "Issues: 1) Committed to git, 2) base64 is encoding not encryption, 3) no RBAC restriction, 4) no etcd encryption"
            - input: "Need RBAC Role for production namespace"
              output: "Role with get verb on secrets resource, limited to prod-db-creds by resourceNames"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                base64 is a reversible encoding, not encryption. Anyone can run <code>echo "cDRzc3cwcmQ=" | base64 -d</code>
                to get the password. What are the layers of Secret security in Kubernetes?
            - title: "\U0001F4A1 Hint"
              content: >-
                The issues are: (1) Secrets should never be committed to git, (2) base64 is not encryption,
                (3) etcd stores Secrets in plain text by default, (4) no RBAC to restrict access.
                For the Role, use <code>resourceNames</code> to limit access to a specific Secret.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>Issues:
                1. Secret committed to git (visible in history forever)
                2. base64 encoding is trivially reversible
                3. No etcd encryption at rest mentioned
                4. No RBAC restriction on who can read this Secret

                RBAC Role pattern:
                - apiGroups: [""]
                  resources: ["secrets"]
                  verbs: ["get"]
                  resourceNames: ["specific-secret-name"]</pre>
          solution: |-
            # Issues:
            # 1. Secret YAML committed to git -- password is visible in git history forever
            # 2. base64 is ENCODING, not ENCRYPTION -- anyone can decode:
            #    echo "cDRzc3cwcmQ=" | base64 -d   p4ssw0rd
            # 3. etcd may not have encryption at rest enabled
            # 4. No RBAC restricting who can read this Secret

            # RBAC Role to restrict access:
            apiVersion: rbac.authorization.k8s.io/v1
            kind: Role
            metadata:
              name: prod-db-secret-reader
              namespace: production
            rules:
            - apiGroups: [""]
              resources: ["secrets"]
              verbs: ["get"]
              resourceNames: ["prod-db-creds"]
          difficulty: 1
        - id: v2
          title: Fix Overly Permissive RBAC
          description: >-
            This Role grants full access to all Secrets in the namespace. Fix it so that it only allows
            reading (<code>get</code>) the Secrets named <code>app-config-secret</code> and <code>tls-cert</code>:
            <br><pre>apiVersion: rbac.authorization.k8s.io/v1
            kind: Role
            metadata:
              name: app-secret-access
              namespace: production
            rules:
            - apiGroups: [""]
              resources: ["secrets"]
              verbs: ["get", "list", "watch", "create", "update", "delete"]</pre>
          functionSignature: "Role"
          testCases:
            - input: "Role with full CRUD on all Secrets"
              output: "Role with only get verb, limited to two specific Secrets by resourceNames"
            - input: "list and watch verbs on secrets"
              output: "Removed -- list exposes all Secret names, watch streams changes"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The principle of least privilege says grant only the minimum access needed.
                <code>list</code> exposes all Secret names, <code>watch</code> streams changes,
                and <code>delete</code> could cause outages. What verbs are actually needed?
            - title: "\U0001F4A1 Hint"
              content: >-
                Remove <code>list</code>, <code>watch</code>, <code>create</code>, <code>update</code>,
                <code>delete</code>. Keep only <code>get</code>. Add <code>resourceNames</code> to
                limit access to the two specific Secrets.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Reduce verbs to ["get"] only
                2. Add resourceNames to restrict to specific Secrets
                3. Keep namespace: production</pre>
          solution: |-
            apiVersion: rbac.authorization.k8s.io/v1
            kind: Role
            metadata:
              name: app-secret-access
              namespace: production
            rules:
            - apiGroups: [""]
              resources: ["secrets"]
              verbs: ["get"]
              resourceNames: ["app-config-secret", "tls-cert"]
          difficulty: 2
        - id: v3
          title: Secret Exposed in Pod Command
          description: >-
            This Pod prints its Secret value in the container command. Identify the security issue and
            rewrite the Pod spec to mount the Secret as a file instead:
            <br><pre>apiVersion: v1
            kind: Pod
            metadata:
              name: app
            spec:
              containers:
              - name: app
                image: myapp:v1
                command: ["/bin/sh", "-c"]
                args: ["echo Password is $DB_PASS && ./start.sh"]
                env:
                - name: DB_PASS
                  valueFrom:
                    secretKeyRef:
                      name: db-creds
                      key: password</pre>
          functionSignature: "Pod"
          testCases:
            - input: "Pod echoes secret value in command args"
              output: "Secret visible in kubectl logs, process list, and container inspect"
            - input: "Rewrite to use volume mount instead"
              output: "Secret mounted as file at /etc/secrets/password with mode 0400, read by app at startup"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>echo Password is $DB_PASS</code> prints the Secret to stdout, which means it appears
                in <code>kubectl logs</code>. Container commands are also visible via the API. Where else
                might this Secret leak?
            - title: "\U0001F4A1 Hint"
              content: >-
                Remove the echo command that prints the password. Mount the Secret as a file at
                <code>/etc/secrets</code> and have the app read from the file instead. Set
                <code>defaultMode: 0400</code> for restrictive permissions.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>Issues:
                1. echo prints Secret to stdout (visible in kubectl logs)
                2. Env vars visible in /proc/PID/environ
                3. Container spec visible via Kubernetes API

                Fix: Mount Secret as volume file instead:
                1. Remove echo from command
                2. Add volumeMount at /etc/secrets
                3. Add secret volume with defaultMode 0400
                4. App reads password from /etc/secrets/password</pre>
          solution: |-
            # Issue: echo prints the secret to stdout (visible in kubectl logs)
            # Also: env vars can be seen via /proc/PID/environ
            # Fix: mount as file instead

            apiVersion: v1
            kind: Pod
            metadata:
              name: app
            spec:
              containers:
              - name: app
                image: myapp:v1
                command: ["/bin/sh", "-c"]
                args: ["./start.sh --password-file /etc/secrets/password"]
                volumeMounts:
                - name: db-creds
                  mountPath: /etc/secrets
                  readOnly: true
              volumes:
              - name: db-creds
                secret:
                  secretName: db-creds
                  defaultMode: 0400
          difficulty: 2
        - id: v4
          title: RoleBinding for Secret Access
          description: >-
            Write a Role and RoleBinding that grants ServiceAccount <code>app-sa</code> in namespace
            <code>production</code> read-only access to Secret <code>db-creds</code>. The ServiceAccount
            should be able to <code>get</code> only that specific Secret, nothing else.
          functionSignature: "Role + RoleBinding"
          testCases:
            - input: "ServiceAccount app-sa needs to read Secret db-creds"
              output: "Role with get on secrets/db-creds + RoleBinding binding app-sa to the Role"
            - input: "app-sa tries to list all secrets"
              output: "Denied -- Role only allows get on the specific Secret"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A Role defines the permissions, a RoleBinding assigns those permissions to a subject
                (user, group, or ServiceAccount). What fields connect the RoleBinding to both the
                Role and the ServiceAccount?
            - title: "\U0001F4A1 Hint"
              content: >-
                The Role uses <code>resourceNames</code> to limit to <code>db-creds</code>.
                The RoleBinding uses <code>roleRef</code> to reference the Role and <code>subjects</code>
                to reference the ServiceAccount.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>Role:
                - resources: ["secrets"], verbs: ["get"]
                - resourceNames: ["db-creds"]

                RoleBinding:
                - roleRef: references the Role
                - subjects: [{kind: ServiceAccount, name: app-sa}]</pre>
          solution: |-
            apiVersion: rbac.authorization.k8s.io/v1
            kind: Role
            metadata:
              name: db-creds-reader
              namespace: production
            rules:
            - apiGroups: [""]
              resources: ["secrets"]
              verbs: ["get"]
              resourceNames: ["db-creds"]
            ---
            apiVersion: rbac.authorization.k8s.io/v1
            kind: RoleBinding
            metadata:
              name: app-sa-db-creds
              namespace: production
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: Role
              name: db-creds-reader
            subjects:
            - kind: ServiceAccount
              name: app-sa
              namespace: production
          difficulty: 2
        - id: v5
          title: Separate ConfigMap and Secret RBAC
          description: >-
            Write two Roles in the <code>staging</code> namespace:
            <br>1. <code>config-reader</code>: allows <code>get</code>, <code>list</code>, <code>watch</code> on ConfigMaps (developers need this)
            <br>2. <code>secret-reader</code>: allows only <code>get</code> on Secrets, restricted to <code>app-secret</code> (only the app ServiceAccount needs this)
            <br>Explain why you would give different access levels for ConfigMaps vs Secrets.
          functionSignature: "Role"
          testCases:
            - input: "ConfigMap access: developers need list/watch for debugging"
              output: "config-reader Role with get, list, watch on configmaps"
            - input: "Secret access: only app needs specific secrets"
              output: "secret-reader Role with only get on secrets, limited by resourceNames"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                ConfigMaps hold non-sensitive data, so broader access is acceptable. Secrets hold
                sensitive data, so access should be minimal. Why would you avoid giving <code>list</code>
                permission on Secrets?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>list</code> on Secrets exposes all Secret names in the namespace, and the response
                includes the data. <code>watch</code> streams Secret changes in real time. Both are
                unnecessary and dangerous for Secrets.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>config-reader:
                - resources: ["configmaps"]
                - verbs: ["get", "list", "watch"]

                secret-reader:
                - resources: ["secrets"]
                - verbs: ["get"]
                - resourceNames: ["app-secret"]</pre>
          solution: |-
            # ConfigMaps: broader access is fine (non-sensitive data)
            apiVersion: rbac.authorization.k8s.io/v1
            kind: Role
            metadata:
              name: config-reader
              namespace: staging
            rules:
            - apiGroups: [""]
              resources: ["configmaps"]
              verbs: ["get", "list", "watch"]
            ---
            # Secrets: minimal access (sensitive data)
            # list on secrets exposes all secret data in the response
            # watch streams secret changes in real time
            apiVersion: rbac.authorization.k8s.io/v1
            kind: Role
            metadata:
              name: secret-reader
              namespace: staging
            rules:
            - apiGroups: [""]
              resources: ["secrets"]
              verbs: ["get"]
              resourceNames: ["app-secret"]
          difficulty: 3
        - id: v6
          title: Detect Secret in Environment Variable Leak
          description: >-
            A developer reports that a Secret value appears in application logs. The Pod spec includes:
            <br><pre>env:
            - name: DB_CONNECTION_STRING
              value: "postgres://admin:p4ssw0rd@db:5432/mydb"</pre>
            <br>Identify the issues and rewrite using a ConfigMap for the host/port/database and
            a Secret for the credentials. Construct the connection string inside the container using
            the separate env vars.
          functionSignature: "ConfigMap + Secret + Pod"
          testCases:
            - input: "Connection string with embedded password in plain env var"
              output: "Separate ConfigMap (host, port, db) and Secret (username, password); app constructs connection string"
            - input: "Password visible in kubectl describe pod"
              output: "After fix: only Secret reference shown, not the actual value"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The password is hardcoded in the env var <code>value</code> field, not pulled from a Secret.
                This means it is visible in the Pod spec via <code>kubectl get pod -o yaml</code> and in
                any YAML files committed to git. How do you split it up?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a ConfigMap with <code>DB_HOST</code>, <code>DB_PORT</code>, <code>DB_NAME</code>.
                Create a Secret with <code>DB_USER</code>, <code>DB_PASS</code>. Inject all five as
                separate env vars. The application constructs the connection string from the parts.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>ConfigMap: DB_HOST=db, DB_PORT=5432, DB_NAME=mydb
                Secret: DB_USER=admin, DB_PASS=p4ssw0rd
                Pod env: configMapKeyRef for host/port/db,
                         secretKeyRef for user/pass</pre>
          solution: |-
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: db-config
            data:
              DB_HOST: db
              DB_PORT: "5432"
              DB_NAME: mydb
            ---
            apiVersion: v1
            kind: Secret
            metadata:
              name: db-creds
            type: Opaque
            stringData:
              DB_USER: admin
              DB_PASS: p4ssw0rd
            ---
            apiVersion: v1
            kind: Pod
            metadata:
              name: myapp
            spec:
              containers:
              - name: myapp
                image: myapp:v1
                env:
                - name: DB_HOST
                  valueFrom:
                    configMapKeyRef:
                      name: db-config
                      key: DB_HOST
                - name: DB_PORT
                  valueFrom:
                    configMapKeyRef:
                      name: db-config
                      key: DB_PORT
                - name: DB_NAME
                  valueFrom:
                    configMapKeyRef:
                      name: db-config
                      key: DB_NAME
                - name: DB_USER
                  valueFrom:
                    secretKeyRef:
                      name: db-creds
                      key: DB_USER
                - name: DB_PASS
                  valueFrom:
                    secretKeyRef:
                      name: db-creds
                      key: DB_PASS
          difficulty: 2
    - id: challenge_3
      block: 2
      difficulty: 2
      concept: Config Update Propagation
      variants:
        - id: v1
          title: Predict Update Behavior - Volume Mount
          description: >-
            A Deployment mounts ConfigMap <code>app-config</code> as a volume at <code>/etc/config</code>
            (standard mount, no subPath). You update the ConfigMap with <code>kubectl edit</code>.
            <br><br>Questions:
            <br>1. Will the mounted file at <code>/etc/config/LOG_LEVEL</code> update automatically?
            <br>2. How long will it take?
            <br>3. Do you need to restart the Pods?
          functionSignature: "Analysis"
          testCases:
            - input: "ConfigMap updated, Pod has standard volume mount"
              output: "File updates automatically within ~60-90 seconds, no Pod restart needed"
            - input: "kubelet sync period for ConfigMap volumes"
              output: "kubelet periodically syncs mounted ConfigMaps; default is configurable but typically ~60s"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Volume-mounted ConfigMaps use a symlink mechanism. The kubelet periodically checks for
                ConfigMap changes and updates the symlink target. What does this mean for your application?
            - title: "\U0001F4A1 Hint"
              content: >-
                Standard volume mounts (no subPath) auto-update within ~60-90 seconds. The kubelet uses
                symlinks: it writes a new directory, then atomically swaps the symlink. Your application
                needs to re-read the file to pick up changes.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>Standard volume mount update behavior:
                1. ConfigMap updated via kubectl edit/apply
                2. kubelet detects change within sync period (~60-90s)
                3. kubelet writes new data to a timestamped directory
                4. kubelet atomically updates symlink to new directory
                5. File at mount path now has new content
                6. Application must re-read the file to see changes</pre>
          solution: |-
            # Answers:
            # 1. YES -- the mounted file updates automatically
            # 2. Within approximately 60-90 seconds (kubelet sync period)
            # 3. NO -- Pod restart is NOT required for volume mounts
            #
            # How it works:
            # - kubelet uses symlinks for ConfigMap volumes
            # - When ConfigMap changes, kubelet writes new data to a new directory
            # - Then atomically swaps the symlink to point to the new directory
            # - The file at the mount path now contains the updated content
            #
            # Important: your application must re-read the file to see changes.
            # If the app reads config only at startup, you still need a restart
            # or a file-watch mechanism (e.g., inotify).
            #
            # Example of what happens on the filesystem:
            # /etc/config/
            #   ..data -> ..2024_01_15_10_30_00.123456789   (symlink)
            #   ..2024_01_15_10_30_00.123456789/            (actual data dir)
            #     LOG_LEVEL
            #   LOG_LEVEL -> ..data/LOG_LEVEL               (symlink)
          difficulty: 2
        - id: v2
          title: Predict Update Behavior - Env Var
          description: >-
            A Deployment injects <code>LOG_LEVEL</code> from ConfigMap <code>app-config</code> as an
            environment variable using <code>configMapKeyRef</code>. You update the ConfigMap to change
            <code>LOG_LEVEL</code> from <code>info</code> to <code>debug</code>.
            <br><br>Questions:
            <br>1. Will the env var inside the running container update?
            <br>2. What must you do to pick up the change?
            <br>3. Write the <code>kubectl</code> command to make the Pods pick up the new env var.
          functionSignature: "Analysis"
          testCases:
            - input: "ConfigMap updated, Pod uses env var from configMapKeyRef"
              output: "Env var does NOT update; must restart Pods with kubectl rollout restart"
            - input: "kubectl exec pod -- printenv LOG_LEVEL after ConfigMap update"
              output: "Still shows 'info' (old value) until Pod is restarted"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Environment variables are set when the container process starts. They live in the
                process's memory. Does anything update a running process's environment after it starts?
            - title: "\U0001F4A1 Hint"
              content: >-
                Environment variables are injected at Pod creation time and never updated.
                Use <code>kubectl rollout restart deployment/NAME</code> to trigger new Pods
                that will pick up the new ConfigMap values.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>Env var update behavior:
                1. Env vars are set at container start time
                2. They become part of the process environment
                3. ConfigMap changes do NOT propagate to env vars
                4. Must restart Pods to pick up new values
                5. kubectl rollout restart deployment/NAME</pre>
          solution: |-
            # Answers:
            # 1. NO -- env vars do NOT update automatically
            # 2. You must restart the Pods (rolling restart)
            # 3. Command:

            kubectl rollout restart deployment/myapp

            # Explanation:
            # Environment variables are set when the container starts.
            # They are part of the process environment in memory.
            # Kubernetes does not update env vars on a running container.
            #
            # rollout restart creates new Pods one by one (rolling update),
            # and each new Pod reads the current ConfigMap values at start time.
          difficulty: 2
        - id: v3
          title: Predict Update Behavior - subPath Mount
          description: >-
            A Pod mounts a single file from ConfigMap <code>nginx-conf</code> using <code>subPath</code>:
            <br><pre>volumeMounts:
            - name: config
              mountPath: /etc/nginx/conf.d/default.conf
              subPath: default.conf</pre>
            <br>You update the ConfigMap. Will the file at <code>/etc/nginx/conf.d/default.conf</code>
            update automatically? Explain why or why not.
          functionSignature: "Analysis"
          testCases:
            - input: "ConfigMap updated, Pod uses subPath volume mount"
              output: "File does NOT update -- subPath uses a bind mount, not a symlink"
            - input: "Need to update the config file"
              output: "Must restart the Pod; or switch to a regular mount (without subPath) for auto-updates"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                subPath creates a direct bind mount from the volume to the specific file path.
                The kubelet's auto-update mechanism works by swapping symlinks. What happens
                when there is no symlink to swap?
            - title: "\U0001F4A1 Hint"
              content: >-
                subPath mounts bypass the symlink mechanism that enables auto-updates.
                The file is directly bind-mounted, so the kubelet cannot atomically swap it.
                This is a common gotcha that catches people by surprise.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>subPath mount behavior:
                1. subPath creates a direct bind mount (no symlink)
                2. kubelet cannot swap the file atomically
                3. ConfigMap changes do NOT propagate
                4. Must restart the Pod to pick up changes
                5. Alternative: use regular mount (no subPath) for auto-updates</pre>
          solution: |-
            # Answer: NO -- subPath mounts do NOT auto-update.
            #
            # Why:
            # - Standard volume mounts use a symlink-based mechanism:
            #   kubelet writes new data, then atomically swaps the symlink.
            # - subPath creates a direct bind mount instead of a symlink.
            #   The kubelet's update mechanism is completely bypassed.
            #
            # To pick up changes, you must restart the Pod:
            kubectl rollout restart deployment/nginx
            #
            # Alternative: remove subPath and use a regular mount.
            # Regular mount (auto-updates):
            #   volumeMounts:
            #   - name: config
            #     mountPath: /etc/nginx/conf.d
            #   volumes:
            #   - name: config
            #     configMap:
            #       name: nginx-conf
            #       items:
            #       - key: default.conf
            #         path: default.conf
            #
            # The trade-off: regular mount replaces the entire directory,
            # while subPath mounts a single file without affecting other files.
          difficulty: 2
        - id: v4
          title: Design for Live Config Reload
          description: >-
            You need a Deployment where the application picks up ConfigMap changes within 2 minutes without
            any Pod restarts. The ConfigMap has keys <code>LOG_LEVEL</code> and <code>config.yaml</code>.
            <br><br>Write the Deployment YAML that enables this. Explain which consumption method supports
            auto-update and which does not.
          functionSignature: "Deployment"
          testCases:
            - input: "Need live config reload without Pod restart"
              output: "Use volume mount (not env vars, not subPath) for automatic updates"
            - input: "ConfigMap has both simple keys and a config file"
              output: "Mount entire ConfigMap as volume; app reads files, not env vars"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Only one consumption method supports automatic updates. Which one is it?
                And within that method, is there a variant that does NOT support auto-updates?
            - title: "\U0001F4A1 Hint"
              content: >-
                Volume mounts (without subPath) auto-update. Mount the ConfigMap at a directory
                and have your application read from files instead of env vars. The app needs a
                file-watching mechanism or periodic re-reads.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>For live config reload:
                1. Mount ConfigMap as volume (NO subPath)
                2. App reads config from mounted files
                3. App implements file-watch (inotify) or periodic re-read
                4. kubelet syncs changes within ~60-90 seconds

                Methods that do NOT auto-update:
                - Environment variables (set at Pod start only)
                - subPath mounts (direct bind mount, no symlink)</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: live-reload-app
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: live-reload-app
              template:
                metadata:
                  labels:
                    app: live-reload-app
                spec:
                  containers:
                  - name: app
                    image: myapp:v2
                    # NO env vars for config that needs live updates
                    # NO subPath mounts
                    # Use standard volume mount for auto-updates
                    volumeMounts:
                    - name: config
                      mountPath: /etc/config
                      readOnly: true
                  volumes:
                  - name: config
                    configMap:
                      name: app-config
            # Auto-update summary:
            # - Volume mount (standard): YES, updates in ~60-90 seconds
            # - Volume mount (subPath): NO, requires Pod restart
            # - Environment variable: NO, requires Pod restart
            #
            # The app reads /etc/config/LOG_LEVEL and /etc/config/config.yaml
            # as files. It should implement inotify or periodic re-read to
            # detect changes.
          difficulty: 2
        - id: v5
          title: Mixed Propagation Scenario
          description: >-
            A Deployment consumes ConfigMap <code>app-config</code> in three ways:
            <br>1. <code>LOG_LEVEL</code> as an env var via <code>configMapKeyRef</code>
            <br>2. <code>config.yaml</code> as a volume mount at <code>/etc/config/config.yaml</code> (standard mount, no subPath)
            <br>3. <code>nginx.conf</code> as a volume mount at <code>/etc/nginx/nginx.conf</code> using <code>subPath</code>
            <br><br>You update the ConfigMap. For each of the three consumption methods, predict whether
            the Pod sees the new value and explain why.
          functionSignature: "Analysis"
          testCases:
            - input: "ConfigMap updated, three different consumption methods"
              output: "Env var: NO, standard volume: YES (~60-90s), subPath volume: NO"
            - input: "Which requires Pod restart?"
              output: "Env var and subPath mount both require restart; standard volume mount does not"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each consumption method has different update behavior. There are exactly three cases
                to consider, and they all behave differently.
            - title: "\U0001F4A1 Hint"
              content: >-
                Env vars: set at start, never updated. Standard volume mount: auto-updates via
                symlink swap. subPath mount: direct bind mount, never updated. Two out of three
                require a Pod restart.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>Update propagation rules:
                1. env var (configMapKeyRef)  NO auto-update
                2. volume mount (standard)  YES, ~60-90 seconds
                3. volume mount (subPath)  NO auto-update

                Only standard volume mounts auto-update.
                Everything else requires Pod restart.</pre>
          solution: |-
            # Propagation analysis:
            #
            # 1. LOG_LEVEL (env var via configMapKeyRef):
            #     Does NOT update automatically.
            #     Env vars are set at container start and live in process memory.
            #     Requires Pod restart: kubectl rollout restart deployment/NAME
            #
            # 2. config.yaml (standard volume mount, no subPath):
            #     DOES update automatically within ~60-90 seconds.
            #     kubelet detects the ConfigMap change and swaps the symlink.
            #     App must re-read the file to see the new content.
            #
            # 3. nginx.conf (subPath volume mount):
            #     Does NOT update automatically.
            #     subPath creates a direct bind mount, bypassing the symlink mechanism.
            #     Requires Pod restart: kubectl rollout restart deployment/NAME
            #
            # Summary:
            # 
            #  Method                 Auto-update  Restart needed  
            # 
            #  Env var                NO           YES             
            #  Volume mount           YES (~60s)   NO              
            #  subPath volume mount   NO           YES             
            # 
          difficulty: 3
        - id: v6
          title: Immutable ConfigMap Update Strategy
          description: >-
            You have an immutable ConfigMap <code>app-config-v1</code> and need to update the configuration.
            <br><br>Questions:
            <br>1. Can you edit an immutable ConfigMap?
            <br>2. What is the recommended update strategy?
            <br>3. Write the commands and YAML to deploy an updated config using versioned ConfigMap names.
          functionSignature: "ConfigMap + kubectl"
          testCases:
            - input: "Need to update immutable ConfigMap app-config-v1"
              output: "Cannot edit; create new app-config-v2, update Deployment to reference v2"
            - input: "Rollback scenario"
              output: "Update Deployment back to app-config-v1 to rollback; old ConfigMap still exists"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Immutable means you cannot change it. So how do you deploy new config? Think about
                how versioned names enable clean rollbacks.
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a new ConfigMap with a version suffix (e.g., <code>app-config-v2</code>).
                Update the Deployment to reference the new name. This triggers a rolling update.
                To rollback, point the Deployment back to <code>app-config-v1</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Cannot edit immutable ConfigMap
                2. Create new ConfigMap with incremented version
                3. Update Deployment to reference new ConfigMap name
                4. Rolling update deploys new Pods with new config
                5. Rollback: update Deployment to reference old ConfigMap name</pre>
          solution: |-
            # 1. NO -- immutable ConfigMaps cannot be edited:
            # kubectl edit configmap app-config-v1
            #  error: configmaps "app-config-v1" is immutable

            # 2. Create a new versioned ConfigMap:
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: app-config-v2
            data:
              DB_HOST: new-postgres.internal
              LOG_LEVEL: debug
            immutable: true

            # 3. Apply the new ConfigMap:
            # kubectl apply -f app-config-v2.yaml

            # 4. Update the Deployment to reference the new ConfigMap:
            # kubectl set env deployment/myapp --from=configmap/app-config-v2
            # OR edit the Deployment YAML to reference app-config-v2

            # 5. Rollback if needed:
            # kubectl set env deployment/myapp --from=configmap/app-config-v1
            # The old immutable ConfigMap still exists, so rollback is clean

            # Benefits of versioned immutable ConfigMaps:
            # - No accidental edits
            # - Clean rollback (old versions preserved)
            # - Reduced kubelet load (no watch needed)
            # - Clear audit trail of config changes
          difficulty: 3
