conceptLinks:
  kubectl get: "#lesson-get-list-and-filter"
  Output Formats: "#lesson-output-formats"
  kubectl explain: "#lesson-explain-built-in-documentation"
  Dry Run & Generate: "#lesson-client-side-dry-run"
  jsonpath: "#lesson-output-formats"
  API Groups: "#lesson-api-groups-and-versions"
  Imperative vs Declarative: "#lesson-imperative-vs-declarative"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: kubectl get
      variants:
        - id: v1
          title: List All Pods
          description: >-
            Write a kubectl command to list all Pods in the <code>default</code> namespace.
          hints:
            - The basic verb for listing resources is <code>get</code>
            - "Default namespace is used when you don't specify <code>-n</code>"
          solution: |-
            kubectl get pods
        - id: v2
          title: List Pods in a Specific Namespace
          description: >-
            List all Pods in the <code>kube-system</code> namespace.
          hints:
            - "Use the <code>-n</code> flag to specify a namespace"
          solution: |-
            kubectl get pods -n kube-system
        - id: v3
          title: List Pods Across All Namespaces
          description: >-
            List all Pods across every namespace in the cluster.
          hints:
            - "There's a short flag <code>-A</code> that means all namespaces"
            - "The long form is <code>--all-namespaces</code>"
          solution: |-
            kubectl get pods -A
        - id: v4
          title: List Pods by Label
          description: >-
            List all Pods that have the label <code>app=web</code>.
          hints:
            - "Use <code>-l</code> to filter by label selector"
          solution: |-
            kubectl get pods -l app=web
        - id: v5
          title: List Multiple Resource Types
          description: >-
            List all Pods, Services, and Deployments in the current namespace with a single command.
          hints:
            - You can specify multiple resource types separated by commas
          solution: |-
            kubectl get pods,svc,deploy
        - id: v6
          title: List Services in a Namespace
          description: >-
            List all Services in the <code>production</code> namespace.
          hints:
            - "Services can be abbreviated as <code>svc</code>"
            - "Use <code>-n</code> for the namespace"
          solution: |-
            kubectl get svc -n production
        - id: v7
          title: List Deployments with Labels
          description: >-
            List all Deployments that have both labels <code>app=api</code> and <code>tier=backend</code>.
          hints:
            - Multiple label selectors are separated by commas (AND logic)
          solution: |-
            kubectl get deploy -l app=api,tier=backend
        - id: v8
          title: List Pods Using Set-Based Selector
          description: >-
            List all Pods where the label <code>env</code> is either <code>staging</code> or <code>production</code>.
          hints:
            - "Use the set-based selector syntax: <code>'key in (val1, val2)'</code>"
            - Wrap the selector in single quotes
          solution: |-
            kubectl get pods -l 'env in (staging, production)'
        - id: v9
          title: List Pods Without a Label
          description: >-
            List all Pods that do <strong>not</strong> have the <code>canary</code> label.
          hints:
            - "Use the negation selector <code>!label</code>"
            - Wrap in single quotes to avoid shell interpretation
          solution: |-
            kubectl get pods -l '!canary'
        - id: v10
          title: List Pods Sorted by Creation Time
          description: >-
            List all Pods sorted by their creation timestamp (newest last).
          hints:
            - "Use the <code>--sort-by</code> flag"
            - "The field path is <code>.metadata.creationTimestamp</code>"
          solution: |-
            kubectl get pods --sort-by=.metadata.creationTimestamp
        - id: v11
          title: List Pods on a Specific Node
          description: >-
            List all Pods running on the node called <code>node-1</code> using a field selector.
          hints:
            - "Use <code>--field-selector</code> instead of <code>-l</code>"
            - "The field path is <code>spec.nodeName</code>"
          solution: |-
            kubectl get pods --field-selector spec.nodeName=node-1
        - id: v12
          title: List Non-Running Pods
          description: >-
            List all Pods that are <strong>not</strong> in the <code>Running</code> phase using a field selector.
          hints:
            - "Field selectors support <code>!=</code> for negation"
            - "The field path is <code>status.phase</code>"
          solution: |-
            kubectl get pods --field-selector status.phase!=Running
        - id: v13
          title: Describe a Pod
          description: >-
            Get the detailed human-readable information for a Pod called <code>web-abc12</code>, including its events.
          hints:
            - "Use <code>describe</code> instead of <code>get</code>"
            - Events are shown at the bottom of describe output
          solution: |-
            kubectl describe pod web-abc12

    - id: warmup_2
      concept: Output Formats
      variants:
        - id: v1
          title: Wide Output
          description: >-
            List all Pods with extra columns like Node name and Pod IP.
          hints:
            - "Use <code>-o wide</code> to show additional columns"
          solution: |-
            kubectl get pods -o wide
        - id: v2
          title: Full YAML Output
          description: >-
            Get the complete YAML representation of a Pod named <code>nginx</code>.
          hints:
            - "Use <code>-o yaml</code> to output the full object as YAML"
          solution: |-
            kubectl get pod nginx -o yaml
        - id: v3
          title: Full JSON Output
          description: >-
            Get the complete JSON representation of a Deployment named <code>web</code>.
          hints:
            - "Use <code>-o json</code> to output the full object as JSON"
          solution: |-
            kubectl get deployment web -o json
        - id: v4
          title: Extract Pod IP with jsonpath
          description: >-
            Extract only the Pod IP address of a Pod named <code>nginx</code> using jsonpath output.
          hints:
            - "Use <code>-o jsonpath='{...}'</code>"
            - "The field path is <code>.status.podIP</code>"
          solution: |-
            kubectl get pod nginx -o jsonpath='{.status.podIP}'
        - id: v5
          title: Extract All Pod Names with jsonpath
          description: >-
            Extract just the names of all Pods in the current namespace using jsonpath.
          hints:
            - "When listing resources, results are in <code>.items[*]</code>"
            - "The name field is <code>.metadata.name</code>"
          solution: |-
            kubectl get pods -o jsonpath='{.items[*].metadata.name}'
        - id: v6
          title: Extract Container Image
          description: >-
            Extract the container image of a Pod named <code>web</code> using jsonpath.
          hints:
            - "Containers are at <code>.spec.containers[0].image</code>"
          solution: |-
            kubectl get pod web -o jsonpath='{.spec.containers[0].image}'
        - id: v7
          title: Custom Columns for Pods
          description: >-
            List all Pods showing only NAME, STATUS, and IP as custom columns.
          hints:
            - "Use <code>-o custom-columns=HEADER:.path,...</code>"
            - "STATUS is at <code>.status.phase</code>, IP is at <code>.status.podIP</code>"
          solution: |-
            kubectl get pods -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,IP:.status.podIP
        - id: v8
          title: Custom Columns with Node
          description: >-
            List all Pods with custom columns showing NAME, NODE, and the container IMAGE.
          hints:
            - "Node is at <code>.spec.nodeName</code>"
            - "Image is at <code>.spec.containers[0].image</code>"
          solution: |-
            kubectl get pods -o custom-columns=NAME:.metadata.name,NODE:.spec.nodeName,IMAGE:.spec.containers[0].image
        - id: v9
          title: jsonpath Range Expression
          description: >-
            Use a jsonpath <code>range</code> expression to print each Pod's name and IP on separate lines (tab-separated).
          hints:
            - "Use <code>{range .items[*]}</code> to iterate"
            - "Use <code>{\"\\t\"}</code> for tab and <code>{\"\\n\"}</code> for newline"
            - "Close with <code>{end}</code>"
          solution: |-
            kubectl get pods -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.podIP}{"\n"}{end}'
        - id: v10
          title: Extract Service ClusterIP
          description: >-
            Extract the <code>clusterIP</code> of a Service named <code>my-service</code> using jsonpath.
          hints:
            - "The field is at <code>.spec.clusterIP</code>"
          solution: |-
            kubectl get svc my-service -o jsonpath='{.spec.clusterIP}'
        - id: v11
          title: YAML Output for a Service
          description: >-
            Get the full YAML of a Service named <code>frontend</code> in the <code>production</code> namespace.
          hints:
            - "Combine <code>-n</code> and <code>-o yaml</code>"
          solution: |-
            kubectl get svc frontend -n production -o yaml
        - id: v12
          title: Extract Deployment Replicas
          description: >-
            Extract the number of desired replicas from a Deployment named <code>api</code> using jsonpath.
          hints:
            - "The field path is <code>.spec.replicas</code>"
          solution: |-
            kubectl get deployment api -o jsonpath='{.spec.replicas}'

    - id: warmup_3
      concept: kubectl explain
      variants:
        - id: v1
          title: Explain a Pod
          description: >-
            Use <code>kubectl explain</code> to see the top-level fields of a Pod resource.
          hints:
            - "Just pass the resource type to <code>explain</code>"
          solution: |-
            kubectl explain pod
        - id: v2
          title: Explain Pod Containers
          description: >-
            Use <code>kubectl explain</code> to see the fields available for a Pod's containers.
          hints:
            - "Drill into nested fields with dot notation: <code>resource.field.subfield</code>"
          solution: |-
            kubectl explain pod.spec.containers
        - id: v3
          title: Explain Deployment Strategy
          description: >-
            Look up the fields available for a Deployment's update strategy.
          hints:
            - "The path is <code>deployment.spec.strategy</code>"
          solution: |-
            kubectl explain deployment.spec.strategy
        - id: v4
          title: Explain Resource Requests
          description: >-
            Look up the documentation for container resource requests (CPU/memory).
          hints:
            - "The path drills through containers to resources to requests"
          solution: |-
            kubectl explain pod.spec.containers.resources.requests
        - id: v5
          title: Recursive Explain
          description: >-
            Show the full recursive field tree for a Pod spec (all nested fields at once).
          hints:
            - "Add the <code>--recursive</code> flag"
          solution: |-
            kubectl explain pod.spec --recursive
        - id: v6
          title: Explain Service Spec
          description: >-
            Look up the fields available in a Service's spec to understand what options exist.
          hints:
            - "The resource path is <code>service.spec</code>"
          solution: |-
            kubectl explain service.spec
        - id: v7
          title: Explain Container Ports
          description: >-
            Look up the fields available for defining ports on a container.
          hints:
            - "Drill into <code>pod.spec.containers.ports</code>"
          solution: |-
            kubectl explain pod.spec.containers.ports
        - id: v8
          title: Explain Volume Mounts
          description: >-
            Look up the fields available for container volume mounts.
          hints:
            - "The field path is <code>pod.spec.containers.volumeMounts</code>"
          solution: |-
            kubectl explain pod.spec.containers.volumeMounts
        - id: v9
          title: Explain CronJob Schedule
          description: >-
            Look up the documentation for a CronJob's spec to find the schedule field.
          hints:
            - "The resource path is <code>cronjob.spec</code>"
          solution: |-
            kubectl explain cronjob.spec
        - id: v10
          title: Explain Liveness Probe
          description: >-
            Look up the fields available for configuring a container's liveness probe.
          hints:
            - "The path is <code>pod.spec.containers.livenessProbe</code>"
          solution: |-
            kubectl explain pod.spec.containers.livenessProbe
        - id: v11
          title: Explain StatefulSet Spec
          description: >-
            Look up the fields available in a StatefulSet's spec.
          hints:
            - "Use <code>statefulset.spec</code> as the resource path"
          solution: |-
            kubectl explain statefulset.spec
        - id: v12
          title: Explain Pod Security Context
          description: >-
            Look up the fields for a Pod-level security context.
          hints:
            - "The path is <code>pod.spec.securityContext</code>"
          solution: |-
            kubectl explain pod.spec.securityContext

    - id: warmup_4
      concept: Dry Run & Generate
      variants:
        - id: v1
          title: Generate Deployment YAML
          description: >-
            Generate the YAML for a Deployment named <code>web</code> using the <code>nginx</code> image with 3 replicas,
            without actually creating it.
          hints:
            - "Use <code>kubectl create deployment</code> with <code>--dry-run=client -o yaml</code>"
            - "Use <code>--replicas=3</code> to set the replica count"
          solution: |-
            kubectl create deployment web --image=nginx --replicas=3 --dry-run=client -o yaml
        - id: v2
          title: Generate Pod YAML
          description: >-
            Generate the YAML for a Pod named <code>busybox</code> using the <code>busybox</code> image that runs
            <code>sleep 3600</code>, without creating it.
          hints:
            - "Use <code>kubectl run</code> for creating Pod YAML"
            - "Add <code>--dry-run=client -o yaml</code>"
            - "Use <code>--command -- sleep 3600</code> for the command"
          solution: |-
            kubectl run busybox --image=busybox --dry-run=client -o yaml --command -- sleep 3600
        - id: v3
          title: Generate Service YAML
          description: >-
            Generate the YAML for a ClusterIP Service named <code>web-svc</code> that exposes port 80 targeting port 8080,
            without creating it.
          hints:
            - "Use <code>kubectl create service clusterip</code>"
            - "Use <code>--tcp=80:8080</code> for the port mapping"
          solution: |-
            kubectl create service clusterip web-svc --tcp=80:8080 --dry-run=client -o yaml
        - id: v4
          title: Generate Job YAML
          description: >-
            Generate the YAML for a Job named <code>backup</code> using the <code>alpine</code> image that runs
            <code>tar czf /backup/data.tar.gz /data</code>, without creating it.
          hints:
            - "Use <code>kubectl create job</code>"
            - "The image and command go after <code>--image</code> and <code>--</code>"
          solution: |-
            kubectl create job backup --image=alpine --dry-run=client -o yaml -- tar czf /backup/data.tar.gz /data
        - id: v5
          title: Generate Namespace YAML
          description: >-
            Generate the YAML for a Namespace named <code>staging</code> without creating it.
          hints:
            - "Use <code>kubectl create namespace</code>"
            - "Add <code>--dry-run=client -o yaml</code>"
          solution: |-
            kubectl create namespace staging --dry-run=client -o yaml
        - id: v6
          title: Generate ConfigMap YAML
          description: >-
            Generate the YAML for a ConfigMap named <code>app-config</code> with the key-value pairs
            <code>DB_HOST=postgres</code> and <code>DB_PORT=5432</code>, without creating it.
          hints:
            - "Use <code>kubectl create configmap</code>"
            - "Use <code>--from-literal</code> for each key-value pair"
          solution: |-
            kubectl create configmap app-config --from-literal=DB_HOST=postgres --from-literal=DB_PORT=5432 --dry-run=client -o yaml
        - id: v7
          title: Generate Secret YAML
          description: >-
            Generate the YAML for a generic Secret named <code>db-creds</code> with <code>username=admin</code> and
            <code>password=s3cret</code>, without creating it.
          hints:
            - "Use <code>kubectl create secret generic</code>"
            - "Use <code>--from-literal</code> for each key-value pair"
          solution: |-
            kubectl create secret generic db-creds --from-literal=username=admin --from-literal=password=s3cret --dry-run=client -o yaml
        - id: v8
          title: Generate ServiceAccount YAML
          description: >-
            Generate the YAML for a ServiceAccount named <code>app-sa</code> in the <code>production</code> namespace,
            without creating it.
          hints:
            - "Use <code>kubectl create serviceaccount</code>"
            - "Use <code>-n</code> for the namespace"
          solution: |-
            kubectl create serviceaccount app-sa -n production --dry-run=client -o yaml
        - id: v9
          title: Generate NodePort Service YAML
          description: >-
            Generate the YAML for a NodePort Service named <code>web-nodeport</code> that exposes port 80,
            without creating it.
          hints:
            - "Use <code>kubectl create service nodeport</code>"
            - "Use <code>--tcp=80:80</code> for the port mapping"
          solution: |-
            kubectl create service nodeport web-nodeport --tcp=80:80 --dry-run=client -o yaml
        - id: v10
          title: Generate and Save to File
          description: >-
            Generate a Deployment YAML for <code>api</code> using <code>node:18-alpine</code> with 2 replicas and save it
            to a file called <code>api-deploy.yaml</code>.
          hints:
            - "Use <code>--dry-run=client -o yaml</code> and redirect with <code>></code>"
          solution: |-
            kubectl create deployment api --image=node:18-alpine --replicas=2 --dry-run=client -o yaml > api-deploy.yaml
        - id: v11
          title: Server-Side Dry Run
          description: >-
            Validate a manifest file called <code>deployment.yaml</code> against the live API Server without actually
            creating the resource.
          hints:
            - "Use <code>--dry-run=server</code> instead of <code>--dry-run=client</code>"
            - "This sends the request to the API Server for full validation"
          solution: |-
            kubectl apply -f deployment.yaml --dry-run=server
        - id: v12
          title: Diff Before Applying
          description: >-
            Preview what would change if you applied <code>deployment.yaml</code> to the cluster, without actually
            applying it.
          hints:
            - "Use <code>kubectl diff</code> instead of <code>kubectl apply</code>"
          solution: |-
            kubectl diff -f deployment.yaml

  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: jsonpath
      variants:
        - id: v1
          title: Extract Pod IPs as a List
          description: >-
            Extract the IP addresses of all Pods in the <code>default</code> namespace, each on a separate line. Use
            jsonpath to iterate through the list.
          functionSignature: "kubectl get pods -o jsonpath='{range ...}{...}{end}'"
          testCases:
            - input: "3 running Pods with IPs 10.1.0.15, 10.1.0.16, 10.1.0.17"
              output: "10.1.0.15\\n10.1.0.16\\n10.1.0.17"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you <code>get pods</code>, the result is a List with an <code>.items</code> array. You need to
                iterate over that array and extract a specific field from each item.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>{range .items[*]}</code> to iterate. The IP field is at <code>.status.podIP</code>. Use
                <code>{\"\\n\"}</code> for newlines.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl get pods -o jsonpath='{range .items[*]}{.status.podIP}{"\n"}{end}'</pre>
          solution: |-
            kubectl get pods -o jsonpath='{range .items[*]}{.status.podIP}{"\n"}{end}'
          difficulty: 1
        - id: v2
          title: Extract Pod Names and Statuses
          description: >-
            For all Pods in the current namespace, extract the name and phase (status) in a tab-separated format, one Pod
            per line. Use jsonpath.
          functionSignature: "kubectl get pods -o jsonpath='{range ...}...{end}'"
          testCases:
            - input: "2 Pods: web-abc (Running), db-xyz (Pending)"
              output: "web-abc\\tRunning\\ndb-xyz\\tPending"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to iterate and pull two fields from each item. Use tab (<code>{\"\\t\"}</code>) between fields
                and newline (<code>{\"\\n\"}</code>) between rows.
            - title: "\U0001F4A1 Hint"
              content: >-
                Inside the range, access <code>.metadata.name</code> and <code>.status.phase</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl get pods -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.phase}{"\n"}{end}'</pre>
          solution: |-
            kubectl get pods -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.phase}{"\n"}{end}'
          difficulty: 1
        - id: v3
          title: Extract Container Images from a Deployment
          description: >-
            Extract the container image(s) used by a Deployment named <code>web</code>. The Deployment may have multiple
            containers in its Pod template.
          functionSignature: "kubectl get deployment web -o jsonpath='{...}'"
          testCases:
            - input: "Deployment 'web' with containers: nginx:1.25, fluentd:latest"
              output: "nginx:1.25 fluentd:latest"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A Deployment's container images are nested inside the Pod template spec. When querying a single resource
                (not a list), there is no <code>.items</code> array.
            - title: "\U0001F4A1 Hint"
              content: >-
                The path is <code>.spec.template.spec.containers[*].image</code>. The <code>[*]</code> wildcard gets
                all containers.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl get deployment web -o jsonpath='{.spec.template.spec.containers[*].image}'</pre>
          solution: |-
            kubectl get deployment web -o jsonpath='{.spec.template.spec.containers[*].image}'
          difficulty: 2
        - id: v4
          title: Extract Node Names and Internal IPs
          description: >-
            Extract the name and InternalIP address of every node in the cluster using jsonpath. Each node's addresses are
            in <code>.status.addresses</code> (an array of objects with <code>type</code> and <code>address</code>
            fields). Use a jsonpath filter to select only the <code>InternalIP</code> type.
          functionSignature: "kubectl get nodes -o jsonpath='{range ...}...{end}'"
          testCases:
            - input: "2 nodes: node-1 (192.168.1.10), node-2 (192.168.1.11)"
              output: "node-1\\t192.168.1.10\\nnode-2\\t192.168.1.11"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each node has a <code>.status.addresses</code> array with entries like
                <code>{type: InternalIP, address: 192.168.1.10}</code>. You need a jsonpath filter expression
                <code>[?(@.type==\"InternalIP\")]</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                Inside the range, use <code>.status.addresses[?(@.type==\"InternalIP\")].address</code> to extract
                only the InternalIP.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl get nodes -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.addresses[?(@.type=="InternalIP")].address}{"\n"}{end}'</pre>
          solution: |-
            kubectl get nodes -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.addresses[?(@.type=="InternalIP")].address}{"\n"}{end}'
          difficulty: 3
        - id: v5
          title: Extract Restart Counts
          description: >-
            List the name and total restart count of each Pod in the current namespace using jsonpath. The restart count
            for the first container is at <code>.status.containerStatuses[0].restartCount</code>.
          functionSignature: "kubectl get pods -o jsonpath='{range ...}...{end}'"
          testCases:
            - input: "2 Pods: web-abc (0 restarts), api-xyz (3 restarts)"
              output: "web-abc\\t0\\napi-xyz\\t3"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Restart counts are in the <code>status.containerStatuses</code> array. For a single-container Pod,
                index <code>[0]</code> gives you the first (and only) container.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>{.status.containerStatuses[0].restartCount}</code> inside a range over <code>.items[*]</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl get pods -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.containerStatuses[0].restartCount}{"\n"}{end}'</pre>
          solution: |-
            kubectl get pods -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.containerStatuses[0].restartCount}{"\n"}{end}'
          difficulty: 2
        - id: v6
          title: Custom Columns for Deployments
          description: >-
            List all Deployments showing NAME, READY replicas, and IMAGE using custom-columns output format.
          functionSignature: "kubectl get deploy -o custom-columns=..."
          testCases:
            - input: "Deployment 'web' with 3/3 ready, image nginx:1.25"
              output: "NAME  READY  IMAGE\\nweb   3      nginx:1.25"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Custom columns let you define a table with your own headers and field paths. Ready replicas are at
                <code>.status.readyReplicas</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>-o custom-columns=NAME:.metadata.name,READY:.status.readyReplicas,IMAGE:...</code>. The
                container image is nested in the Pod template.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl get deploy -o custom-columns=NAME:.metadata.name,READY:.status.readyReplicas,IMAGE:.spec.template.spec.containers[0].image</pre>
          solution: |-
            kubectl get deploy -o custom-columns=NAME:.metadata.name,READY:.status.readyReplicas,IMAGE:.spec.template.spec.containers[0].image
          difficulty: 2
        - id: v7
          title: Extract Service Ports with jsonpath
          description: >-
            Extract the port and targetPort of all ports on a Service named <code>web-svc</code>. Output each as
            <code>port:targetPort</code> on a separate line.
          functionSignature: "kubectl get svc web-svc -o jsonpath='{range ...}...{end}'"
          testCases:
            - input: "Service with ports 80:8080 and 443:8443"
              output: "80:8080\\n443:8443"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A Service's ports are in <code>.spec.ports</code>, an array of objects with <code>port</code> and
                <code>targetPort</code> fields.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>{range .spec.ports[*]}</code> to iterate. Access <code>{.port}</code> and
                <code>{.targetPort}</code> inside the range.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl get svc web-svc -o jsonpath='{range .spec.ports[*]}{.port}:{.targetPort}{"\n"}{end}'</pre>
          solution: |-
            kubectl get svc web-svc -o jsonpath='{range .spec.ports[*]}{.port}:{.targetPort}{"\n"}{end}'
          difficulty: 2
        - id: v8
          title: Extract Sorted Pod Names by Restart Count
          description: >-
            List Pod names sorted by their first container's restart count (most restarts last) using <code>--sort-by</code>,
            and output only the names using jsonpath.
          functionSignature: "kubectl get pods --sort-by=... -o jsonpath='{...}'"
          testCases:
            - input: "3 Pods: api (5 restarts), web (0 restarts), db (2 restarts)"
              output: "web\\ndb\\napi"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You can combine <code>--sort-by</code> with <code>-o jsonpath</code>. The sort is applied first, then
                the jsonpath extracts from the sorted results.
            - title: "\U0001F4A1 Hint"
              content: >-
                Sort by <code>.status.containerStatuses[0].restartCount</code> and extract
                <code>.items[*].metadata.name</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl get pods --sort-by=.status.containerStatuses[0].restartCount -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}'</pre>
          solution: |-
            kubectl get pods --sort-by=.status.containerStatuses[0].restartCount -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}'
          difficulty: 3

    - id: challenge_2
      block: 1
      difficulty: 2
      concept: Dry Run & Generate
      variants:
        - id: v1
          title: Generate and Modify a Deployment
          description: >-
            Generate the YAML for a Deployment named <code>api</code> using image <code>node:18-alpine</code> with 2
            replicas, save it to <code>api.yaml</code>, then add resource requests (128Mi memory, 250m CPU) manually.
            Show the generate command.
          functionSignature: "kubectl create deployment ... --dry-run=client -o yaml > file.yaml"
          testCases:
            - input: "Generate Deployment YAML for 'api' with node:18-alpine, 2 replicas"
              output: "YAML file with kind: Deployment, image: node:18-alpine, replicas: 2"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The <code>--dry-run=client -o yaml</code> pattern generates valid YAML without creating the resource.
                You redirect it to a file, then edit the file to add fields that imperative commands don't support.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>kubectl create deployment api --image=node:18-alpine --replicas=2</code> with the dry-run
                flags. Resource requests must be added manually in the YAML under
                <code>spec.template.spec.containers[0].resources.requests</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl create deployment api --image=node:18-alpine --replicas=2 \
                  --dry-run=client -o yaml > api.yaml
                # Then edit api.yaml to add:
                #   resources:
                #     requests:
                #       memory: "128Mi"
                #       cpu: "250m"</pre>
          solution: |-
            kubectl create deployment api --image=node:18-alpine --replicas=2 --dry-run=client -o yaml > api.yaml
          difficulty: 2
        - id: v2
          title: Generate a CronJob YAML
          description: >-
            Generate the YAML for a CronJob named <code>cleanup</code> using the <code>alpine</code> image that runs
            <code>find /tmp -mtime +7 -delete</code> every day at midnight. Save to <code>cleanup.yaml</code>.
          functionSignature: "kubectl create cronjob ... --dry-run=client -o yaml > file.yaml"
          testCases:
            - input: "CronJob 'cleanup' with schedule '0 0 * * *' using alpine image"
              output: "YAML file with kind: CronJob, schedule: '0 0 * * *', image: alpine"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                CronJobs need a <code>--schedule</code> flag in cron format. The command goes after <code>--</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>kubectl create cronjob cleanup --image=alpine --schedule=\"0 0 * * *\"</code> with dry-run
                flags and the command after <code>--</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl create cronjob cleanup --image=alpine \
                  --schedule="0 0 * * *" \
                  --dry-run=client -o yaml -- find /tmp -mtime +7 -delete > cleanup.yaml</pre>
          solution: |-
            kubectl create cronjob cleanup --image=alpine --schedule="0 0 * * *" --dry-run=client -o yaml -- find /tmp -mtime +7 -delete > cleanup.yaml
          difficulty: 2
        - id: v3
          title: Generate a Pod with Environment Variables
          description: >-
            Generate YAML for a Pod named <code>db</code> using the <code>postgres:15</code> image with environment
            variable <code>POSTGRES_PASSWORD=mysecret</code>. Do not create it.
          functionSignature: "kubectl run ... --dry-run=client -o yaml"
          testCases:
            - input: "Pod 'db' with postgres:15 and POSTGRES_PASSWORD env var"
              output: "YAML with kind: Pod, image: postgres:15, env POSTGRES_PASSWORD"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>kubectl run</code> supports the <code>--env</code> flag for setting environment variables.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>kubectl run db --image=postgres:15 --env=POSTGRES_PASSWORD=mysecret</code> with dry-run flags.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl run db --image=postgres:15 \
                  --env=POSTGRES_PASSWORD=mysecret \
                  --dry-run=client -o yaml</pre>
          solution: |-
            kubectl run db --image=postgres:15 --env=POSTGRES_PASSWORD=mysecret --dry-run=client -o yaml
          difficulty: 2
        - id: v4
          title: Generate a Pod with Port Exposure
          description: >-
            Generate YAML for a Pod named <code>web</code> using <code>nginx:1.25</code> that exposes container port 80.
            Do not create it.
          functionSignature: "kubectl run ... --dry-run=client -o yaml"
          testCases:
            - input: "Pod 'web' with nginx:1.25 exposing port 80"
              output: "YAML with kind: Pod, image: nginx:1.25, containerPort: 80"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>kubectl run</code> supports the <code>--port</code> flag to set the container port.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>kubectl run web --image=nginx:1.25 --port=80</code> with dry-run flags.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl run web --image=nginx:1.25 --port=80 \
                  --dry-run=client -o yaml</pre>
          solution: |-
            kubectl run web --image=nginx:1.25 --port=80 --dry-run=client -o yaml
          difficulty: 2
        - id: v5
          title: Validate and Diff Workflow
          description: >-
            You have a modified manifest <code>deployment.yaml</code>. Show the two-step workflow to: (1) validate the
            manifest against the live API server without persisting, and (2) preview the diff of what would change.
          functionSignature: "kubectl apply --dry-run=server ... && kubectl diff ..."
          testCases:
            - input: "deployment.yaml with updated replica count"
              output: "Step 1: server dry run passes. Step 2: diff shows replica change."
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Server-side dry run validates against admission controllers and schema. <code>kubectl diff</code>
                shows exactly what would change.
            - title: "\U0001F4A1 Hint"
              content: >-
                Step 1 uses <code>--dry-run=server</code>. Step 2 uses <code>kubectl diff -f</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl apply -f deployment.yaml --dry-run=server
                kubectl diff -f deployment.yaml</pre>
          solution: |-
            kubectl apply -f deployment.yaml --dry-run=server
            kubectl diff -f deployment.yaml
          difficulty: 3
        - id: v6
          title: Generate a Role YAML
          description: >-
            Generate the YAML for a Role named <code>pod-reader</code> in the <code>default</code> namespace that allows
            <code>get</code>, <code>list</code>, and <code>watch</code> on <code>pods</code>. Do not create it.
          functionSignature: "kubectl create role ... --dry-run=client -o yaml"
          testCases:
            - input: "Role 'pod-reader' with get/list/watch on pods"
              output: "YAML with kind: Role, verbs: [get, list, watch], resources: [pods]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>kubectl create role</code> accepts <code>--verb</code> and <code>--resource</code> flags.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>kubectl create role pod-reader --verb=get,list,watch --resource=pods</code> with dry-run flags.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl create role pod-reader \
                  --verb=get,list,watch \
                  --resource=pods \
                  --dry-run=client -o yaml</pre>
          solution: |-
            kubectl create role pod-reader --verb=get,list,watch --resource=pods --dry-run=client -o yaml
          difficulty: 3
        - id: v7
          title: Generate an Ingress YAML
          description: >-
            Generate the YAML for an Ingress named <code>web-ingress</code> with rule
            <code>--rule=\"web.example.com/=web-svc:80\"</code>. Do not create it.
          functionSignature: "kubectl create ingress ... --dry-run=client -o yaml"
          testCases:
            - input: "Ingress 'web-ingress' with host web.example.com routing to web-svc:80"
              output: "YAML with kind: Ingress, host: web.example.com, service: web-svc, port: 80"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>kubectl create ingress</code> supports a <code>--rule</code> flag that takes the format
                <code>host/path=service:port</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>kubectl create ingress web-ingress --rule=\"web.example.com/=web-svc:80\"</code> with dry-run
                flags.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl create ingress web-ingress \
                  --rule="web.example.com/=web-svc:80" \
                  --dry-run=client -o yaml</pre>
          solution: |-
            kubectl create ingress web-ingress --rule="web.example.com/=web-svc:80" --dry-run=client -o yaml
          difficulty: 3

    - id: challenge_3
      block: 2
      difficulty: 1
      concept: API Groups
      variants:
        - id: v1
          title: Core API Group Resources
          description: >-
            A teammate wrote a manifest with <code>apiVersion: core/v1</code> for a Pod. The API server rejects it. What
            is the correct <code>apiVersion</code> for core resources like Pods, Services, ConfigMaps, and Secrets?
          functionSignature: "apiVersion: ?"
          testCases:
            - input: "Pod"
              output: "v1"
            - input: "Service"
              output: "v1"
            - input: "ConfigMap"
              output: "v1"
            - input: "Secret"
              output: "v1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The core API group is special — it predates the named group system. Its resources are served at
                <code>/api/v1</code>, not <code>/apis/core/v1</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                Core group resources just use <code>v1</code> as the apiVersion, with no group prefix.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>apiVersion: v1
                kind: Pod
                # NOT apiVersion: core/v1</pre>
          solution: |-
            v1
          difficulty: 1
        - id: v2
          title: apps API Group
          description: >-
            What is the correct <code>apiVersion</code> for a Deployment? What about ReplicaSet, StatefulSet, and
            DaemonSet?
          functionSignature: "apiVersion: ?"
          testCases:
            - input: "Deployment"
              output: "apps/v1"
            - input: "ReplicaSet"
              output: "apps/v1"
            - input: "StatefulSet"
              output: "apps/v1"
            - input: "DaemonSet"
              output: "apps/v1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Workload controllers like Deployments were originally in extensions but have moved to a named API group.
            - title: "\U0001F4A1 Hint"
              content: >-
                All workload controllers (Deployment, ReplicaSet, StatefulSet, DaemonSet) are in the <code>apps</code>
                group at version <code>v1</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>apiVersion: apps/v1
                kind: Deployment</pre>
          solution: |-
            apps/v1
          difficulty: 1
        - id: v3
          title: batch API Group
          description: >-
            What is the correct <code>apiVersion</code> for a Job? And for a CronJob?
          functionSignature: "apiVersion: ?"
          testCases:
            - input: "Job"
              output: "batch/v1"
            - input: "CronJob"
              output: "batch/v1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Jobs and CronJobs are batch workloads — they run to completion rather than running continuously.
            - title: "\U0001F4A1 Hint"
              content: >-
                Both are in the <code>batch</code> group at version <code>v1</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>apiVersion: batch/v1
                kind: Job</pre>
          solution: |-
            batch/v1
          difficulty: 1
        - id: v4
          title: networking.k8s.io API Group
          description: >-
            What is the correct <code>apiVersion</code> for an Ingress resource? An older tutorial uses
            <code>extensions/v1beta1</code> — is that still valid?
          functionSignature: "apiVersion: ?"
          testCases:
            - input: "Ingress"
              output: "networking.k8s.io/v1"
            - input: "NetworkPolicy"
              output: "networking.k8s.io/v1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Ingress was moved from <code>extensions/v1beta1</code> to its own networking group. The old version
                was removed in Kubernetes 1.22.
            - title: "\U0001F4A1 Hint"
              content: >-
                Ingress and NetworkPolicy are both in <code>networking.k8s.io/v1</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>apiVersion: networking.k8s.io/v1
                kind: Ingress
                # extensions/v1beta1 was removed in K8s 1.22</pre>
          solution: |-
            networking.k8s.io/v1
          difficulty: 1
        - id: v5
          title: RBAC API Group
          description: >-
            What is the correct <code>apiVersion</code> for a Role, ClusterRole, RoleBinding, and ClusterRoleBinding?
          functionSignature: "apiVersion: ?"
          testCases:
            - input: "Role"
              output: "rbac.authorization.k8s.io/v1"
            - input: "ClusterRole"
              output: "rbac.authorization.k8s.io/v1"
            - input: "RoleBinding"
              output: "rbac.authorization.k8s.io/v1"
            - input: "ClusterRoleBinding"
              output: "rbac.authorization.k8s.io/v1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                RBAC resources control who can do what in the cluster. They have their own dedicated API group.
            - title: "\U0001F4A1 Hint"
              content: >-
                All RBAC resources are in <code>rbac.authorization.k8s.io/v1</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>apiVersion: rbac.authorization.k8s.io/v1
                kind: Role</pre>
          solution: |-
            rbac.authorization.k8s.io/v1
          difficulty: 1
        - id: v6
          title: Find the apiVersion with kubectl
          description: >-
            You need to write a manifest for a resource but don't know its API group. What kubectl command shows you the
            correct <code>apiVersion</code> for any resource type?
          functionSignature: "kubectl explain <resource>"
          testCases:
            - input: "kubectl explain ingress | head"
              output: "GROUP: networking.k8s.io, VERSION: v1"
            - input: "kubectl explain deployment | head"
              output: "GROUP: apps, VERSION: v1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>kubectl explain</code> shows the GROUP and VERSION at the top of its output for any resource type.
            - title: "\U0001F4A1 Hint"
              content: >-
                Run <code>kubectl explain &lt;resource&gt;</code> and look at the VERSION line. You can also run
                <code>kubectl api-resources</code> to see all resources and their API groups.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl explain cronjob
                # KIND:     CronJob
                # VERSION:  batch/v1

                kubectl api-resources | grep -i cronjob
                # cronjobs   cj   batch/v1   true   CronJob</pre>
          solution: |-
            kubectl explain cronjob
          difficulty: 2
        - id: v7
          title: List All API Resources
          description: >-
            What kubectl command lists all available resource types in the cluster, showing their short names, API group,
            and whether they are namespaced?
          functionSignature: "kubectl api-resources"
          testCases:
            - input: "List all resource types"
              output: "Table with NAME, SHORTNAMES, APIVERSION, NAMESPACED, KIND"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                There's a dedicated kubectl command that lists every resource type the API server knows about.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>kubectl api-resources</code> shows all resource types. You can filter with <code>--namespaced=true</code>
                or grep for specific resources.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kubectl api-resources
                # NAME          SHORTNAMES   APIVERSION   NAMESPACED   KIND
                # pods          po           v1           true         Pod
                # services      svc          v1           true         Service
                # deployments   deploy       apps/v1      true         Deployment</pre>
          solution: |-
            kubectl api-resources
          difficulty: 2
        - id: v8
          title: Mixed apiVersion Quiz
          description: >-
            Given the following resource kinds, write the correct <code>apiVersion</code> for each: Pod, Deployment,
            CronJob, Ingress, Service, ClusterRole.
          functionSignature: "apiVersion for each resource kind"
          testCases:
            - input: "Pod"
              output: "v1"
            - input: "Deployment"
              output: "apps/v1"
            - input: "CronJob"
              output: "batch/v1"
            - input: "Ingress"
              output: "networking.k8s.io/v1"
            - input: "Service"
              output: "v1"
            - input: "ClusterRole"
              output: "rbac.authorization.k8s.io/v1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Group the resources by their API group: core (v1), apps, batch, networking.k8s.io, rbac.authorization.k8s.io.
            - title: "\U0001F4A1 Hint"
              content: >-
                Core resources (Pod, Service) use <code>v1</code>. Workload controllers use <code>apps/v1</code>. Batch
                resources use <code>batch/v1</code>. Networking uses <code>networking.k8s.io/v1</code>. RBAC uses
                <code>rbac.authorization.k8s.io/v1</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>Pod:         v1
                Service:     v1
                Deployment:  apps/v1
                CronJob:     batch/v1
                Ingress:     networking.k8s.io/v1
                ClusterRole: rbac.authorization.k8s.io/v1</pre>
          solution: |-
            Pod:         v1
            Service:     v1
            Deployment:  apps/v1
            CronJob:     batch/v1
            Ingress:     networking.k8s.io/v1
            ClusterRole: rbac.authorization.k8s.io/v1
          difficulty: 2
