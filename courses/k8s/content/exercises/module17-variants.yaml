conceptLinks:
  Sprig Functions: "#lesson-sprig"
  toYaml & nindent: "#lesson-toyaml"
  Chart Hooks: "#lesson-hooks"
  Subchart Values: "#lesson-subcharts"
  Advanced Template Logic: "#lesson-advanced-flow"
  Template Rendering: "#lesson-template-rendering"
  Library Charts: "#lesson-library-charts"
  .Files: "#lesson-files"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Sprig Functions
      variants:
        - id: v1
          title: Uppercase a Release Name
          description: >-
            Using the Sprig <code>upper</code> function, write a Helm template expression that converts
            <code>.Release.Name</code> to uppercase. For example, if the release name is <code>my-app</code>,
            the output should be <code>MY-APP</code>.
          hints:
            - "Sprig string functions are called with pipe syntax: <code>value | functionName</code>."
            - "The <code>upper</code> function converts an entire string to uppercase."
          solution: |-
            {{ .Release.Name | upper }}
        - id: v2
          title: Lowercase and Quote a Label
          description: >-
            Write a Helm template expression that takes <code>.Values.appName</code>, converts it to lowercase,
            and wraps it in double quotes using Sprig functions. If <code>appName</code> is <code>MyService</code>,
            the output should be <code>"myservice"</code>.
          hints:
            - "Chain functions with pipes: <code>value | func1 | func2</code>."
            - "<code>lower</code> converts to lowercase, <code>quote</code> wraps in double quotes."
          solution: |-
            {{ .Values.appName | lower | quote }}
        - id: v3
          title: Replace Characters in a String
          description: >-
            Write a Helm template expression that takes <code>.Values.hostname</code> and replaces all underscores
            with hyphens using the Sprig <code>replace</code> function. For example, <code>my_web_app</code>
            becomes <code>my-web-app</code>.
          hints:
            - "<code>replace</code> takes three arguments: old string, new string, and the source string."
            - "In pipe syntax: <code>source | replace \"old\" \"new\"</code>."
          solution: |-
            {{ .Values.hostname | replace "_" "-" }}
        - id: v4
          title: Get the First Element of a List
          description: >-
            Given <code>.Values.servers</code> is a list like <code>["alpha", "beta", "gamma"]</code>, write a
            template expression that outputs the first element using the Sprig <code>first</code> function.
          hints:
            - "The <code>first</code> function returns the first element of a list."
            - "Use pipe syntax: <code>.Values.servers | first</code>."
          solution: |-
            {{ .Values.servers | first }}
        - id: v5
          title: Get the Last Element of a List
          description: >-
            Given <code>.Values.tags</code> is a list like <code>["v1.0", "v1.1", "v2.0"]</code>, write a
            template expression that outputs the last element using the Sprig <code>last</code> function.
          hints:
            - "The <code>last</code> function returns the last element of a list."
            - "Use pipe syntax: <code>.Values.tags | last</code>."
          solution: |-
            {{ .Values.tags | last }}
        - id: v6
          title: Append to a List
          description: >-
            Given <code>.Values.fruits</code> is <code>["apple", "banana"]</code>, write a template expression
            using <code>append</code> that adds <code>"cherry"</code> to the list and then outputs it with
            <code>toJson</code>.
          hints:
            - "<code>append</code> adds an element to the end of a list and returns a new list."
            - "Syntax: <code>append list element</code> or <code>list | append element</code>."
          solution: |-
            {{ append .Values.fruits "cherry" | toJson }}
        - id: v7
          title: Create a Dict and Retrieve a Value
          description: >-
            Write a template expression that creates a dictionary with keys <code>name</code> and <code>port</code>
            set to <code>"nginx"</code> and <code>"80"</code> respectively using the Sprig <code>dict</code>
            function, then retrieves the <code>name</code> key using <code>get</code>.
          hints:
            - "<code>dict</code> creates a dictionary: <code>dict \"key1\" \"val1\" \"key2\" \"val2\"</code>."
            - "<code>get</code> retrieves a value: <code>get $myDict \"keyName\"</code>."
          solution: |-
            {{- $svc := dict "name" "nginx" "port" "80" -}}
            {{ get $svc "name" }}
        - id: v8
          title: Check if a Dict Has a Key
          description: >-
            Given <code>.Values.config</code> is a dict that may or may not contain a <code>debug</code> key,
            write a template expression using <code>hasKey</code> that outputs <code>true</code> or
            <code>false</code>.
          hints:
            - "<code>hasKey</code> returns a boolean: <code>hasKey dict \"keyName\"</code>."
            - "This is useful for conditionally including config sections."
          solution: |-
            {{ hasKey .Values.config "debug" }}
        - id: v9
          title: Base64 Encode a Secret
          description: >-
            Write a Helm template expression that takes <code>.Values.password</code> and base64-encodes it
            using the Sprig <code>b64enc</code> function. This is commonly used in Kubernetes Secret manifests.
          hints:
            - "<code>b64enc</code> base64-encodes a string."
            - "Kubernetes Secrets require base64-encoded data fields."
          solution: |-
            {{ .Values.password | b64enc }}
        - id: v10
          title: Convert a Value to JSON
          description: >-
            Given <code>.Values.metadata</code> is a dict like <code>{env: prod, team: platform}</code>, write
            a template expression that serializes it to a JSON string using <code>toJson</code>.
          hints:
            - "<code>toJson</code> serializes any value to a JSON string."
            - "This is useful for annotations that store structured data."
          solution: |-
            {{ .Values.metadata | toJson }}
        - id: v11
          title: Default Value Fallback
          description: >-
            Write a Helm template expression that outputs <code>.Values.replicas</code> if it is set, or
            defaults to <code>3</code> if it is not. Use the Sprig <code>default</code> function.
          hints:
            - "<code>default</code> returns the fallback value when the input is empty or nil."
            - "Syntax: <code>.Values.replicas | default 3</code>."
          solution: |-
            {{ .Values.replicas | default 3 }}
        - id: v12
          title: Truncate a Long String
          description: >-
            Write a template expression that truncates <code>.Release.Name</code> to 63 characters (the
            Kubernetes name length limit) and removes any trailing hyphens, using the Sprig <code>trunc</code>
            and <code>trimSuffix</code> functions.
          hints:
            - "<code>trunc 63</code> truncates to 63 characters."
            - "<code>trimSuffix \"-\"</code> removes a trailing hyphen."
          solution: |-
            {{ .Release.Name | trunc 63 | trimSuffix "-" }}
    - id: warmup_2
      concept: toYaml & nindent
      variants:
        - id: v1
          title: Embed Resource Limits
          description: >-
            Given <code>.Values.resources</code> contains <code>{limits: {cpu: "500m", memory: "128Mi"}}</code>,
            write a template snippet that renders it as proper YAML under a <code>resources:</code> key with
            correct 2-space indentation.
          hints:
            - "<code>toYaml</code> converts a value to a YAML string."
            - "<code>nindent N</code> adds a newline then indents each line by N spaces."
          solution: |-
            resources:
              {{- toYaml .Values.resources | nindent 2 }}
        - id: v2
          title: Embed Pod Annotations
          description: >-
            Given <code>.Values.podAnnotations</code> is a map like <code>{prometheus.io/scrape: "true",
            prometheus.io/port: "9090"}</code>, write a template snippet that renders these as annotations
            in a pod spec with 8-space indentation (typical for a Deployment pod template).
          hints:
            - "Annotations go under <code>metadata.annotations</code> in the pod template."
            - "Use <code>toYaml .Values.podAnnotations | nindent 8</code> for 8-space indent."
          solution: |-
            annotations:
              {{- toYaml .Values.podAnnotations | nindent 8 }}
        - id: v3
          title: Embed Node Selector
          description: >-
            Given <code>.Values.nodeSelector</code> is <code>{disktype: ssd, region: us-east-1}</code>,
            write a template snippet that conditionally renders a <code>nodeSelector:</code> block only
            if the value is non-empty. Use <code>toYaml</code> with <code>nindent 8</code>.
          hints:
            - "Use <code>{{- if .Values.nodeSelector }}</code> to conditionally render."
            - "The <code>-</code> in <code>{{-</code> trims whitespace before the tag."
          solution: |-
            {{- if .Values.nodeSelector }}
            nodeSelector:
              {{- toYaml .Values.nodeSelector | nindent 8 }}
            {{- end }}
        - id: v4
          title: Embed Tolerations List
          description: >-
            Given <code>.Values.tolerations</code> is a list of toleration objects, write a template snippet
            that renders a <code>tolerations:</code> block with correct 8-space indentation. The output should
            produce valid YAML list items.
          hints:
            - "Lists in YAML start with <code>-</code> for each item."
            - "<code>toYaml</code> handles lists properly, just set the right indent level."
          solution: |-
            {{- if .Values.tolerations }}
            tolerations:
              {{- toYaml .Values.tolerations | nindent 8 }}
            {{- end }}
        - id: v5
          title: Embed Environment Variables
          description: >-
            Given <code>.Values.env</code> is a list like <code>[{name: DB_HOST, value: "postgres"},
            {name: DB_PORT, value: "5432"}]</code>, write a template snippet that renders these as container
            environment variables with 12-space indentation (nested inside a container spec).
          hints:
            - "Container env vars are deeply nested in a Deployment spec."
            - "Use <code>nindent 12</code> for the container-level nesting."
          solution: |-
            env:
              {{- toYaml .Values.env | nindent 12 }}
        - id: v6
          title: Embed Labels with indent
          description: >-
            Write a template helper <code>mychart.labels</code> that returns common labels, and then include
            it in a metadata block using <code>nindent 4</code>. The labels should include
            <code>app.kubernetes.io/name</code> and <code>app.kubernetes.io/instance</code>.
          hints:
            - "Use <code>include</code> instead of <code>template</code> so you can pipe the result."
            - "<code>include \"mychart.labels\" . | nindent 4</code> includes and indents."
          solution: |-
            {{- define "mychart.labels" -}}
            app.kubernetes.io/name: {{ .Chart.Name }}
            app.kubernetes.io/instance: {{ .Release.Name }}
            {{- end -}}

            metadata:
              labels:
                {{- include "mychart.labels" . | nindent 4 }}
        - id: v7
          title: Embed Security Context
          description: >-
            Given <code>.Values.securityContext</code> is <code>{runAsNonRoot: true, runAsUser: 1000,
            fsGroup: 2000}</code>, write a template snippet that renders it under <code>securityContext:</code>
            with 8-space indentation and only if the value is non-empty.
          hints:
            - "Combine <code>if</code> with <code>toYaml | nindent</code> for conditional blocks."
            - "The security context sits at the pod spec level, hence 8-space indent."
          solution: |-
            {{- if .Values.securityContext }}
            securityContext:
              {{- toYaml .Values.securityContext | nindent 8 }}
            {{- end }}
        - id: v8
          title: nindent vs indent
          description: >-
            Explain the difference between <code>indent</code> and <code>nindent</code> in Helm, and write
            two equivalent template expressions: one using <code>indent</code> and one using <code>nindent</code>
            to embed <code>.Values.resources</code> at 6-space indentation.
          hints:
            - "<code>indent N</code> indents each line by N spaces but does NOT add a leading newline."
            - "<code>nindent N</code> adds a leading newline THEN indents each line by N spaces."
          solution: |-
            # Using nindent (more common, works with {{- trim):
            resources:
              {{- toYaml .Values.resources | nindent 6 }}

            # Using indent (requires manual newline placement):
            resources:
            {{ toYaml .Values.resources | indent 6 }}
        - id: v9
          title: Embed Volume Mounts
          description: >-
            Given <code>.Values.volumeMounts</code> is a list like
            <code>[{name: data, mountPath: /data}, {name: config, mountPath: /etc/config, readOnly: true}]</code>,
            write a template snippet that renders these as container volume mounts with proper indentation at
            10 spaces.
          hints:
            - "Volume mounts go inside a container spec, typically deeply nested."
            - "Use <code>toYaml .Values.volumeMounts | nindent 10</code>."
          solution: |-
            volumeMounts:
              {{- toYaml .Values.volumeMounts | nindent 10 }}
        - id: v10
          title: Embed Extra Pod Spec Fields
          description: >-
            Write a template pattern that allows users to inject arbitrary extra fields into a pod spec via
            <code>.Values.extraPodSpec</code>. If the user sets <code>extraPodSpec: {hostNetwork: true,
            dnsPolicy: ClusterFirstWithHostNet}</code>, those fields should be rendered at the pod spec
            level (6-space indent).
          hints:
            - "Use a conditional block to only render if <code>.Values.extraPodSpec</code> is set."
            - "<code>toYaml .Values.extraPodSpec | nindent 6</code> renders it at the right level."
          solution: |-
            {{- if .Values.extraPodSpec }}
              {{- toYaml .Values.extraPodSpec | nindent 6 }}
            {{- end }}
    - id: warmup_3
      concept: Chart Hooks
      variants:
        - id: v1
          title: Pre-install Hook Annotation
          description: >-
            Write the metadata annotations for a Kubernetes Job that should run as a Helm <code>pre-install</code>
            hook. Include the hook annotation and set the hook delete policy to
            <code>before-hook-creation</code>.
          hints:
            - "Hook annotations go under <code>metadata.annotations</code>."
            - "The annotation key is <code>helm.sh/hook</code>."
            - "Delete policy uses <code>helm.sh/hook-delete-policy</code>."
          solution: |-
            metadata:
              annotations:
                "helm.sh/hook": pre-install
                "helm.sh/hook-delete-policy": before-hook-creation
        - id: v2
          title: Post-upgrade Hook with Weight
          description: >-
            Write the annotations for a hook that runs after a Helm upgrade (<code>post-upgrade</code>), has a
            hook weight of <code>5</code>, and deletes on <code>hook-succeeded</code>.
          hints:
            - "<code>helm.sh/hook-weight</code> controls the order hooks execute (lower runs first)."
            - "Weight values are strings, even though they represent numbers."
          solution: |-
            metadata:
              annotations:
                "helm.sh/hook": post-upgrade
                "helm.sh/hook-weight": "5"
                "helm.sh/hook-delete-policy": hook-succeeded
        - id: v3
          title: Pre-delete Hook
          description: >-
            Write the annotations for a Job that should run before a Helm release is deleted
            (<code>pre-delete</code>). The hook should be deleted when the next hook creation occurs.
          hints:
            - "Pre-delete hooks run before <code>helm uninstall</code> removes resources."
            - "Use <code>before-hook-creation</code> to clean up old hook resources."
          solution: |-
            metadata:
              annotations:
                "helm.sh/hook": pre-delete
                "helm.sh/hook-delete-policy": before-hook-creation
        - id: v4
          title: Multiple Hook Events
          description: >-
            Write annotations for a hook that runs on both <code>pre-install</code> and
            <code>pre-upgrade</code> events. Set the delete policy to <code>before-hook-creation</code>
            and the weight to <code>-1</code>.
          hints:
            - "Multiple hook events are comma-separated in a single annotation value."
            - "Negative weights run before positive weights."
          solution: |-
            metadata:
              annotations:
                "helm.sh/hook": pre-install,pre-upgrade
                "helm.sh/hook-weight": "-1"
                "helm.sh/hook-delete-policy": before-hook-creation
        - id: v5
          title: Post-install Hook with Succeeded Delete
          description: >-
            Write annotations for a post-install hook that automatically cleans up after success. The Job
            should be deleted only if it succeeds.
          hints:
            - "<code>hook-succeeded</code> means the resource is deleted only after successful completion."
            - "If the hook fails, the resource remains for debugging."
          solution: |-
            metadata:
              annotations:
                "helm.sh/hook": post-install
                "helm.sh/hook-delete-policy": hook-succeeded
        - id: v6
          title: Hook with Failed Delete Policy
          description: >-
            Write annotations for a <code>pre-upgrade</code> hook that is deleted if it fails. This is useful
            for retry scenarios where you want a fresh start on each attempt.
          hints:
            - "<code>hook-failed</code> deletes the resource when the hook fails."
            - "This is less common than <code>hook-succeeded</code> or <code>before-hook-creation</code>."
          solution: |-
            metadata:
              annotations:
                "helm.sh/hook": pre-upgrade
                "helm.sh/hook-delete-policy": hook-failed
        - id: v7
          title: Test Hook
          description: >-
            Write annotations for a Helm test hook. Helm tests run with <code>helm test RELEASE</code> and
            are used to verify a release is working correctly. Set the delete policy to
            <code>before-hook-creation</code>.
          hints:
            - "The test hook type is simply <code>test</code> (previously <code>test-success</code>)."
            - "Helm tests are Pods or Jobs that validate the deployed release."
          solution: |-
            metadata:
              annotations:
                "helm.sh/hook": test
                "helm.sh/hook-delete-policy": before-hook-creation
        - id: v8
          title: Hook Ordering with Weights
          description: >-
            You have three pre-install hooks: a schema migration (should run first), a data seed (should run
            second), and a cache warm-up (should run third). Write the weight annotations for each.
          hints:
            - "Lower weight values execute first."
            - "Use weights like <code>0</code>, <code>1</code>, <code>2</code> or <code>-5</code>, <code>0</code>, <code>5</code>."
          solution: |-
            # Schema migration (runs first)
            metadata:
              annotations:
                "helm.sh/hook": pre-install
                "helm.sh/hook-weight": "0"

            # Data seed (runs second)
            metadata:
              annotations:
                "helm.sh/hook": pre-install
                "helm.sh/hook-weight": "1"

            # Cache warm-up (runs third)
            metadata:
              annotations:
                "helm.sh/hook": pre-install
                "helm.sh/hook-weight": "2"
        - id: v9
          title: Combined Delete Policies
          description: >-
            Write annotations for a <code>post-upgrade</code> hook that is deleted both when it succeeds
            AND before the next hook creation. Use multiple delete policies.
          hints:
            - "Multiple delete policies can be combined in a comma-separated list."
            - "This ensures cleanup in both normal and re-run scenarios."
          solution: |-
            metadata:
              annotations:
                "helm.sh/hook": post-upgrade
                "helm.sh/hook-delete-policy": hook-succeeded,before-hook-creation
        - id: v10
          title: Pre-rollback Hook
          description: >-
            Write annotations for a hook that runs before a Helm rollback (<code>pre-rollback</code>). Set
            the weight to <code>-5</code> so it runs before any other pre-rollback hooks. Delete the hook
            before the next hook creation.
          hints:
            - "Pre-rollback hooks run before <code>helm rollback</code> restores the previous release."
            - "Negative weights ensure this hook runs before hooks with weight 0 or higher."
          solution: |-
            metadata:
              annotations:
                "helm.sh/hook": pre-rollback
                "helm.sh/hook-weight": "-5"
                "helm.sh/hook-delete-policy": before-hook-creation
    - id: warmup_4
      concept: Subchart Values
      variants:
        - id: v1
          title: Override a Subchart Value
          description: >-
            Your chart depends on a <code>postgresql</code> subchart. Write the <code>values.yaml</code>
            entry that sets the PostgreSQL image tag to <code>15.3</code> and the database name to
            <code>myapp</code> in the subchart.
          hints:
            - "Subchart values are nested under the subchart's name in the parent values.yaml."
            - "The subchart name matches the dependency name in Chart.yaml."
          solution: |-
            postgresql:
              image:
                tag: "15.3"
              auth:
                database: myapp
        - id: v2
          title: Use Global Values
          description: >-
            Write a <code>values.yaml</code> snippet that sets a global value <code>global.storageClass</code>
            to <code>fast-ssd</code>. Then write the template expression that a subchart would use to
            access this global value.
          hints:
            - "Global values are accessible to all subcharts under <code>.Values.global</code>."
            - "Both parent and child charts access globals the same way."
          solution: |-
            # In parent values.yaml:
            global:
              storageClass: fast-ssd

            # In any chart template (parent or subchart):
            storageClass: {{ .Values.global.storageClass }}
        - id: v3
          title: Override Multiple Subchart Values
          description: >-
            Your chart has a <code>redis</code> subchart dependency. Write the <code>values.yaml</code>
            entries that set <code>architecture</code> to <code>standalone</code>,
            <code>auth.enabled</code> to <code>false</code>, and <code>master.persistence.size</code>
            to <code>1Gi</code>.
          hints:
            - "Nest the subchart configuration under the <code>redis:</code> key."
            - "Follow the subchart's own values.yaml structure for key names."
          solution: |-
            redis:
              architecture: standalone
              auth:
                enabled: false
              master:
                persistence:
                  size: 1Gi
        - id: v4
          title: Global Image Registry
          description: >-
            Write a <code>values.yaml</code> snippet that sets <code>global.imageRegistry</code> to
            <code>myregistry.example.com</code>. Then write the template expression for a container image
            that uses this global registry with a local <code>.Values.image.repository</code> and
            <code>.Values.image.tag</code>.
          hints:
            - "Combine global and local values: <code>{{ .Values.global.imageRegistry }}/{{ .Values.image.repository }}:{{ .Values.image.tag }}</code>."
            - "This pattern lets all subcharts use the same private registry."
          solution: |-
            # values.yaml:
            global:
              imageRegistry: myregistry.example.com
            image:
              repository: my-app
              tag: "1.0.0"

            # In template:
            image: {{ .Values.global.imageRegistry }}/{{ .Values.image.repository }}:{{ .Values.image.tag }}
        - id: v5
          title: Conditional Subchart Deployment
          description: >-
            Write the <code>Chart.yaml</code> dependency entry and <code>values.yaml</code> entry to include
            a <code>memcached</code> subchart that is only deployed when <code>.Values.memcached.enabled</code>
            is <code>true</code>.
          hints:
            - "Use the <code>condition</code> field in the dependency to control deployment."
            - "The condition references a values path that resolves to a boolean."
          solution: |-
            # Chart.yaml:
            dependencies:
              - name: memcached
                version: "6.x.x"
                repository: https://charts.bitnami.com/bitnami
                condition: memcached.enabled

            # values.yaml:
            memcached:
              enabled: true
        - id: v6
          title: Import Values from Subchart
          description: >-
            Write a <code>Chart.yaml</code> dependency that imports the <code>service.port</code> value from
            a <code>backend</code> subchart and makes it available as <code>backendPort</code> in the
            parent chart.
          hints:
            - "Use the <code>import-values</code> field in the dependency entry."
            - "This avoids having to reference <code>.Values.backend.service.port</code> everywhere."
          solution: |-
            # Chart.yaml:
            dependencies:
              - name: backend
                version: "1.0.0"
                repository: "file://../backend"
                import-values:
                  - child: service.port
                    parent: backendPort
        - id: v7
          title: Global Labels for All Subcharts
          description: >-
            Write a <code>values.yaml</code> snippet that sets global labels that should be applied to all
            resources across parent and child charts. Include labels for <code>company</code>,
            <code>team</code>, and <code>environment</code>.
          hints:
            - "Global values are shared across all charts in the dependency tree."
            - "Templates in each chart should reference <code>.Values.global.labels</code>."
          solution: |-
            # values.yaml:
            global:
              labels:
                company: acme
                team: platform
                environment: production

            # In templates (parent or any subchart):
            labels:
              {{- range $key, $val := .Values.global.labels }}
              {{ $key }}: {{ $val }}
              {{- end }}
        - id: v8
          title: Override Subchart with Tags
          description: >-
            Write a <code>Chart.yaml</code> snippet that uses the <code>tags</code> field to group an
            <code>elasticsearch</code> and <code>kibana</code> subchart under a <code>logging</code> tag.
            Then show how to enable/disable the entire group in <code>values.yaml</code>.
          hints:
            - "Tags group dependencies that can be enabled/disabled together."
            - "Tags are set in <code>values.yaml</code> under the <code>tags:</code> key."
          solution: |-
            # Chart.yaml:
            dependencies:
              - name: elasticsearch
                version: "19.x.x"
                repository: https://charts.bitnami.com/bitnami
                tags:
                  - logging
              - name: kibana
                version: "10.x.x"
                repository: https://charts.bitnami.com/bitnami
                tags:
                  - logging

            # values.yaml:
            tags:
              logging: true
        - id: v9
          title: Access Parent Values from Subchart
          description: >-
            A subchart needs to reference the parent chart's release name and namespace. Write the template
            expressions that a subchart would use to access these built-in objects. Also write how the
            subchart accesses a global value set by the parent.
          hints:
            - "Built-in objects like <code>.Release.Name</code> are available in all charts."
            - "Global values use <code>.Values.global.*</code> and are shared across the chart tree."
          solution: |-
            # Built-in objects work in any chart (parent or sub):
            release: {{ .Release.Name }}
            namespace: {{ .Release.Namespace }}

            # Global values set by parent:
            domain: {{ .Values.global.domain }}
        - id: v10
          title: Subchart Alias
          description: >-
            Write a <code>Chart.yaml</code> dependency that includes the <code>postgresql</code> chart twice:
            once as <code>primary-db</code> and once as <code>analytics-db</code>, using the <code>alias</code>
            field. Show how to configure each independently in <code>values.yaml</code>.
          hints:
            - "The <code>alias</code> field creates a different name for a dependency."
            - "Each alias has its own values section."
          solution: |-
            # Chart.yaml:
            dependencies:
              - name: postgresql
                version: "12.x.x"
                repository: https://charts.bitnami.com/bitnami
                alias: primary-db
              - name: postgresql
                version: "12.x.x"
                repository: https://charts.bitnami.com/bitnami
                alias: analytics-db

            # values.yaml:
            primary-db:
              auth:
                database: myapp
                postgresPassword: secret1
            analytics-db:
              auth:
                database: analytics
                postgresPassword: secret2
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Advanced Template Logic
      variants:
        - id: v1
          title: Conditional Service Ports
          description: >-
            Write a Helm template that renders a Kubernetes Service <code>ports</code> section. If
            <code>.Values.service.metricsPort</code> is set, include a second port for metrics in addition
            to the main port. Use <code>.Values.service.port</code> for the primary port and
            <code>.Values.service.metricsPort</code> for the optional metrics port.
          functionSignature: "{{ if .Values.service.metricsPort }} ... {{ end }}"
          testCases:
            - input: "service: {port: 8080}"
              output: |-
                ports:
                  - port: 8080
                    targetPort: http
                    name: http
            - input: "service: {port: 8080, metricsPort: 9090}"
              output: |-
                ports:
                  - port: 8080
                    targetPort: http
                    name: http
                  - port: 9090
                    targetPort: metrics
                    name: metrics
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The main port should always be rendered. The metrics port should only appear if the user
                has set a value for it.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>{{- if .Values.service.metricsPort }}</code> to conditionally include the second
                port entry. Remember to match the YAML list item format with <code>-</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>ports:
                  - port: {{ .Values.service.port }}
                    ...always present...
                  {{- if .Values.service.metricsPort }}
                  - port: {{ .Values.service.metricsPort }}
                    ...conditional...
                  {{- end }}</pre>
          solution: |-
            ports:
              - port: {{ .Values.service.port }}
                targetPort: http
                name: http
            {{- if .Values.service.metricsPort }}
              - port: {{ .Values.service.metricsPort }}
                targetPort: metrics
                name: metrics
            {{- end }}
          difficulty: 2
        - id: v2
          title: Build Labels from Dict
          description: >-
            Write a Helm template that iterates over <code>.Values.customLabels</code> (a dict) and renders
            each key-value pair as a Kubernetes label. Also include a fixed label
            <code>app.kubernetes.io/managed-by: Helm</code> that is always present.
          functionSignature: "{{ range $key, $val := .Values.customLabels }}"
          testCases:
            - input: "customLabels: {env: prod, team: backend}"
              output: |-
                labels:
                  app.kubernetes.io/managed-by: Helm
                  env: prod
                  team: backend
            - input: "customLabels: {}"
              output: |-
                labels:
                  app.kubernetes.io/managed-by: Helm
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need both a fixed label and dynamic labels from a dict. How do you iterate over a
                map in Go templates?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>range $key, $val := .Values.customLabels</code> to iterate the dict. The fixed
                label should be outside the range block.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>labels:
                  fixed-label: value
                  {{- range $key, $val := .Values.customLabels }}
                  {{ $key }}: {{ $val }}
                  {{- end }}</pre>
          solution: |-
            labels:
              app.kubernetes.io/managed-by: Helm
            {{- range $key, $val := .Values.customLabels }}
              {{ $key }}: {{ $val }}
            {{- end }}
          difficulty: 2
        - id: v3
          title: Nested Conditionals for Ingress TLS
          description: >-
            Write a Helm template for an Ingress <code>tls</code> section that supports three modes:
            (1) if <code>.Values.ingress.tls.secretName</code> is set, use that secret;
            (2) else if <code>.Values.ingress.tls.certManager</code> is true, auto-generate a secret name;
            (3) otherwise, omit the TLS section entirely.
          functionSignature: "{{ if .Values.ingress.tls.secretName }} ... {{ else if ... }} ... {{ end }}"
          testCases:
            - input: "ingress: {host: app.example.com, tls: {secretName: my-tls-secret}}"
              output: |-
                tls:
                  - secretName: my-tls-secret
                    hosts:
                      - app.example.com
            - input: "ingress: {host: app.example.com, tls: {certManager: true}}"
              output: |-
                tls:
                  - secretName: app.example.com-tls
                    hosts:
                      - app.example.com
            - input: "ingress: {host: app.example.com, tls: {}}"
              output: "(no tls section rendered)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Three possible states require nested if/else if logic. The entire TLS block should be
                omitted in the third case.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>if .Values.ingress.tls.secretName</code> for the explicit secret, then
                <code>else if .Values.ingress.tls.certManager</code> for auto-generation. Construct
                the auto name with <code>printf "%s-tls" .Values.ingress.host</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>{{- if .Values.ingress.tls.secretName }}
                tls:
                  - secretName: {{ .Values.ingress.tls.secretName }}
                    hosts: ...
                {{- else if .Values.ingress.tls.certManager }}
                tls:
                  - secretName: {{ printf "%s-tls" .Values.ingress.host }}
                    hosts: ...
                {{- end }}</pre>
          solution: |-
            {{- if .Values.ingress.tls.secretName }}
            tls:
              - secretName: {{ .Values.ingress.tls.secretName }}
                hosts:
                  - {{ .Values.ingress.host }}
            {{- else if .Values.ingress.tls.certManager }}
            tls:
              - secretName: {{ printf "%s-tls" .Values.ingress.host }}
                hosts:
                  - {{ .Values.ingress.host }}
            {{- end }}
          difficulty: 3
        - id: v4
          title: Dynamic ConfigMap from Dict
          description: >-
            Write a Helm template that generates a ConfigMap whose <code>data</code> section is dynamically
            built from <code>.Values.config</code> (a dict). Each key-value pair becomes a ConfigMap entry.
            Additionally, always include a <code>RELEASE_NAME</code> key set to <code>.Release.Name</code>.
          functionSignature: "{{ range $key, $val := .Values.config }}"
          testCases:
            - input: "config: {LOG_LEVEL: info, DB_HOST: postgres}"
              output: |-
                data:
                  RELEASE_NAME: my-release
                  DB_HOST: postgres
                  LOG_LEVEL: info
            - input: "config: {}"
              output: |-
                data:
                  RELEASE_NAME: my-release
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A ConfigMap's data section is a flat key-value map. You need to merge a fixed entry
                with dynamic entries from values.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>range $key, $val := .Values.config</code> to iterate, and pipe values through
                <code>quote</code> if they should be strings. The fixed <code>RELEASE_NAME</code> goes
                outside the range.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>apiVersion: v1
                kind: ConfigMap
                data:
                  RELEASE_NAME: {{ .Release.Name }}
                  {{- range $key, $val := .Values.config }}
                  {{ $key }}: {{ $val | quote }}
                  {{- end }}</pre>
          solution: |-
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: {{ .Release.Name }}-config
            data:
              RELEASE_NAME: {{ .Release.Name }}
            {{- range $key, $val := .Values.config }}
              {{ $key }}: {{ $val | quote }}
            {{- end }}
          difficulty: 3
        - id: v5
          title: Multi-Container Pod with Optional Sidecar
          description: >-
            Write a Helm template for a pod spec's <code>containers</code> section. Always include the main
            container from <code>.Values.image</code>. If <code>.Values.sidecar.enabled</code> is true,
            add a sidecar container from <code>.Values.sidecar.image</code>. Both containers should have
            configurable resource limits.
          functionSignature: "containers: [ main, {{ if .Values.sidecar.enabled }} sidecar {{ end }} ]"
          testCases:
            - input: "image: {repository: nginx, tag: latest}, sidecar: {enabled: false}"
              output: |-
                containers:
                  - name: main
                    image: nginx:latest
            - input: "image: {repository: nginx, tag: latest}, sidecar: {enabled: true, image: {repository: fluentd, tag: v1}}"
              output: |-
                containers:
                  - name: main
                    image: nginx:latest
                  - name: sidecar
                    image: fluentd:v1
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The containers list always has at least one entry. The sidecar is conditionally appended.
                How do you conditionally add a list item in YAML?
            - title: "\U0001F4A1 Hint"
              content: >-
                Render the main container first, then use <code>{{- if .Values.sidecar.enabled }}</code>
                to conditionally add the sidecar container block.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>containers:
                  - name: main
                    image: {{ .Values.image.repository }}:{{ .Values.image.tag }}
                  {{- if .Values.sidecar.enabled }}
                  - name: sidecar
                    image: {{ .Values.sidecar.image.repository }}:{{ .Values.sidecar.image.tag }}
                  {{- end }}</pre>
          solution: |-
            containers:
              - name: main
                image: {{ .Values.image.repository }}:{{ .Values.image.tag }}
            {{- if .Values.resources }}
                resources:
                  {{- toYaml .Values.resources | nindent 10 }}
            {{- end }}
            {{- if .Values.sidecar.enabled }}
              - name: sidecar
                image: {{ .Values.sidecar.image.repository }}:{{ .Values.sidecar.image.tag }}
            {{- if .Values.sidecar.resources }}
                resources:
                  {{- toYaml .Values.sidecar.resources | nindent 10 }}
            {{- end }}
            {{- end }}
          difficulty: 4
        - id: v6
          title: Range with Index for Init Containers
          description: >-
            Write a Helm template that generates init containers from a list
            <code>.Values.initContainers</code>. Each entry has <code>name</code>, <code>image</code>,
            and <code>command</code>. Use <code>range</code> to iterate the list and render each as an
            init container.
          functionSignature: "{{ range .Values.initContainers }}"
          testCases:
            - input: "initContainers: [{name: wait-db, image: busybox, command: ['sh','-c','until nc -z db 5432; do sleep 1; done']}]"
              output: |-
                initContainers:
                  - name: wait-db
                    image: busybox
                    command: ['sh','-c','until nc -z db 5432; do sleep 1; done']
            - input: "initContainers: []"
              output: "(no initContainers section rendered)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to iterate a list of objects and render each as a YAML list item. What happens
                if the list is empty?
            - title: "\U0001F4A1 Hint"
              content: >-
                Wrap the entire block in <code>{{- if .Values.initContainers }}</code> to avoid rendering
                an empty <code>initContainers:</code> key. Use <code>range</code> to iterate.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>{{- if .Values.initContainers }}
                initContainers:
                  {{- range .Values.initContainers }}
                  - name: {{ .name }}
                    image: {{ .image }}
                    command: {{ .command | toJson }}
                  {{- end }}
                {{- end }}</pre>
          solution: |-
            {{- if .Values.initContainers }}
            initContainers:
            {{- range .Values.initContainers }}
              - name: {{ .name }}
                image: {{ .image }}
                command: {{ .command | toJson }}
            {{- end }}
            {{- end }}
          difficulty: 3
    - id: challenge_2
      block: 2
      difficulty: 3
      concept: Chart Hooks
      variants:
        - id: v1
          title: Database Migration Hook
          description: >-
            Write a complete Helm hook Job that runs a database migration before install and before upgrade.
            The Job should use image <code>{{ .Values.migration.image }}</code>, run command
            <code>["migrate", "-path", "/migrations", "-database", "$(DATABASE_URL)", "up"]</code>,
            get the database URL from a Secret, and have a <code>restartPolicy: Never</code>. Set the hook
            weight to <code>-5</code> so it runs before the app deploys. Delete previous hook resources
            before creating new ones.
          functionSignature: "Helm hook Job with pre-install,pre-upgrade annotations"
          testCases:
            - input: "migration: {image: migrate/migrate:v4.16}"
              output: "A Job with pre-install,pre-upgrade hook, weight -5, migration container, env from Secret"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Database migrations should run before the application starts. What happens if the migration
                fails? The hook failure prevents the install/upgrade from continuing.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>helm.sh/hook: pre-install,pre-upgrade</code> so migrations run on both first
                install and upgrades. Use <code>envFrom</code> or <code>env.valueFrom</code> to inject
                the database URL from a Secret.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>apiVersion: batch/v1
                kind: Job
                metadata:
                  annotations:
                    "helm.sh/hook": pre-install,pre-upgrade
                    "helm.sh/hook-weight": "-5"
                    "helm.sh/hook-delete-policy": before-hook-creation
                spec:
                  template:
                    spec:
                      containers:
                        - name: migrate
                          env from secret
                          command: [migrate ...]
                      restartPolicy: Never</pre>
          solution: |-
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: {{ .Release.Name }}-migrate
              annotations:
                "helm.sh/hook": pre-install,pre-upgrade
                "helm.sh/hook-weight": "-5"
                "helm.sh/hook-delete-policy": before-hook-creation
            spec:
              template:
                spec:
                  containers:
                    - name: migrate
                      image: {{ .Values.migration.image }}
                      command: ["migrate", "-path", "/migrations", "-database", "$(DATABASE_URL)", "up"]
                      env:
                        - name: DATABASE_URL
                          valueFrom:
                            secretKeyRef:
                              name: {{ .Release.Name }}-db-secret
                              key: url
                  restartPolicy: Never
              backoffLimit: 1
          difficulty: 3
        - id: v2
          title: Backup Hook Before Delete
          description: >-
            Write a Helm hook Job that creates a database backup before the release is deleted. The Job
            should use <code>.Values.backup.image</code>, run a <code>pg_dump</code> command, and store
            the backup in a PersistentVolumeClaim. Set the delete policy to
            <code>before-hook-creation</code> so old backup jobs are cleaned up.
          functionSignature: "Helm hook Job with pre-delete annotation"
          testCases:
            - input: "backup: {image: postgres:15, pvcName: backup-storage}"
              output: "A Job with pre-delete hook, pg_dump command, volume mount to PVC"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When a release is deleted, all its resources are removed. A pre-delete hook runs before
                that happens, giving you a chance to back up data.
            - title: "\U0001F4A1 Hint"
              content: >-
                Mount the backup PVC as a volume. Use <code>pg_dump</code> with the database connection
                string from a Secret. Write the dump to the mounted volume path.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>apiVersion: batch/v1
                kind: Job
                metadata:
                  annotations:
                    "helm.sh/hook": pre-delete
                    "helm.sh/hook-delete-policy": before-hook-creation
                spec:
                  template:
                    spec:
                      containers:
                        - name: backup
                          command: pg_dump ...
                          volumeMounts: ...
                      volumes: ...
                      restartPolicy: Never</pre>
          solution: |-
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: {{ .Release.Name }}-backup
              annotations:
                "helm.sh/hook": pre-delete
                "helm.sh/hook-delete-policy": before-hook-creation
            spec:
              template:
                spec:
                  containers:
                    - name: backup
                      image: {{ .Values.backup.image }}
                      command:
                        - sh
                        - -c
                        - pg_dump $(DATABASE_URL) > /backup/dump-$(date +%Y%m%d%H%M%S).sql
                      env:
                        - name: DATABASE_URL
                          valueFrom:
                            secretKeyRef:
                              name: {{ .Release.Name }}-db-secret
                              key: url
                      volumeMounts:
                        - name: backup-vol
                          mountPath: /backup
                  volumes:
                    - name: backup-vol
                      persistentVolumeClaim:
                        claimName: {{ .Values.backup.pvcName }}
                  restartPolicy: Never
              backoffLimit: 0
          difficulty: 3
        - id: v3
          title: Smoke Test Hook
          description: >-
            Write a Helm test Pod that verifies the deployed application is responding correctly. The test
            should make an HTTP request to the service endpoint and check for a 200 status code. Use
            <code>wget</code> or <code>curl</code> in a <code>busybox</code> image. The test should run
            with <code>helm test RELEASE</code>.
          functionSignature: "Helm test Pod with test hook annotation"
          testCases:
            - input: "service: {name: my-app, port: 8080}"
              output: "A Pod with test hook annotation, wget/curl command hitting the service"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Helm tests validate that a release is working after deployment. They are Pods that exit
                0 on success and non-zero on failure.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>helm.sh/hook: test</code> for the annotation. The Pod should use
                <code>wget --spider</code> or <code>curl -f</code> to test the service URL. Use the
                Kubernetes DNS name: <code>{{ .Release.Name }}-{{ .Chart.Name }}:{{ .Values.service.port }}</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>apiVersion: v1
                kind: Pod
                metadata:
                  annotations:
                    "helm.sh/hook": test
                spec:
                  containers:
                    - name: test
                      image: busybox
                      command: ['wget', '--spider', 'http://SERVICE:PORT/health']
                  restartPolicy: Never</pre>
          solution: |-
            apiVersion: v1
            kind: Pod
            metadata:
              name: {{ .Release.Name }}-test
              annotations:
                "helm.sh/hook": test
                "helm.sh/hook-delete-policy": before-hook-creation
            spec:
              containers:
                - name: smoke-test
                  image: busybox:1.36
                  command:
                    - wget
                    - --spider
                    - --timeout=5
                    - http://{{ include "mychart.fullname" . }}:{{ .Values.service.port }}/health
              restartPolicy: Never
          difficulty: 3
        - id: v4
          title: Cache Warm-up Post-install Hook
          description: >-
            Write a Helm hook Job that runs after install and after upgrade to warm up the application
            cache. The Job should call several API endpoints using <code>curl</code>. Use a hook weight
            of <code>10</code> so it runs after other post-install hooks. Delete only on success.
          functionSignature: "Helm hook Job with post-install,post-upgrade annotations"
          testCases:
            - input: "warmup: {endpoints: ['/api/products', '/api/categories', '/api/health']}"
              output: "A Job that curls each endpoint after deployment"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Cache warm-up should happen after the application is fully deployed and ready. A high
                hook weight ensures it runs last among post-install hooks.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a shell script that iterates over the endpoints and curls each one. Use
                <code>range</code> to template the endpoint list into the command.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>spec:
                  template:
                    spec:
                      containers:
                        - name: warmup
                          image: curlimages/curl
                          command:
                            - sh
                            - -c
                            - |
                              for url in ENDPOINTS; do
                                curl -sf http://SERVICE$url || exit 1
                              done</pre>
          solution: |-
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: {{ .Release.Name }}-cache-warmup
              annotations:
                "helm.sh/hook": post-install,post-upgrade
                "helm.sh/hook-weight": "10"
                "helm.sh/hook-delete-policy": hook-succeeded
            spec:
              template:
                spec:
                  containers:
                    - name: warmup
                      image: curlimages/curl:latest
                      command:
                        - sh
                        - -c
                        - |
                          {{- range .Values.warmup.endpoints }}
                          curl -sf --retry 3 http://{{ include "mychart.fullname" $ }}:{{ $.Values.service.port }}{{ . }} || exit 1
                          {{- end }}
                  restartPolicy: Never
              backoffLimit: 3
          difficulty: 4
        - id: v5
          title: Schema Validation Hook
          description: >-
            Write a pre-install and pre-upgrade Helm hook Job that validates a database schema is compatible
            with the new application version before deploying. The Job runs a custom validation script. If
            it fails (non-zero exit), the deploy is aborted. Use hook weight <code>-10</code> to run
            before migration hooks.
          functionSignature: "Helm hook Job for schema validation"
          testCases:
            - input: "validation: {image: myapp/schema-check:1.0, dbSecretName: db-credentials}"
              output: "A Job that validates schema before deploy, exits non-zero on incompatibility"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Schema validation should run before migrations. If the current schema is incompatible
                with the new version, the deploy should be aborted entirely.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a very low hook weight (<code>-10</code>) to ensure this runs before migration hooks
                (which might use <code>-5</code>). The container should exit non-zero if validation fails.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>annotations:
                    "helm.sh/hook": pre-install,pre-upgrade
                    "helm.sh/hook-weight": "-10"
                    "helm.sh/hook-delete-policy": before-hook-creation
                spec:
                  containers:
                    - name: validate
                      command: ["schema-check", "--strict"]
                  restartPolicy: Never
                  backoffLimit: 0</pre>
          solution: |-
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: {{ .Release.Name }}-schema-validate
              annotations:
                "helm.sh/hook": pre-install,pre-upgrade
                "helm.sh/hook-weight": "-10"
                "helm.sh/hook-delete-policy": before-hook-creation
            spec:
              template:
                spec:
                  containers:
                    - name: validate
                      image: {{ .Values.validation.image }}
                      command: ["schema-check", "--strict", "--source", "$(DATABASE_URL)"]
                      env:
                        - name: DATABASE_URL
                          valueFrom:
                            secretKeyRef:
                              name: {{ .Values.validation.dbSecretName }}
                              key: url
                  restartPolicy: Never
              backoffLimit: 0
          difficulty: 4
        - id: v6
          title: Notification Hook on Upgrade
          description: >-
            Write a post-upgrade Helm hook Job that sends a Slack notification about the deployment. The
            Job should use <code>curl</code> to POST a JSON payload to <code>.Values.slack.webhookUrl</code>
            containing the release name, namespace, and chart version. Delete on success.
          functionSignature: "Helm hook Job for Slack notification"
          testCases:
            - input: "slack: {webhookUrl: https://hooks.slack.com/xxx, channel: '#deploys'}"
              output: "A Job that posts deployment info to Slack after upgrade"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Deployment notifications are a common use of post-upgrade hooks. The hook should not
                block the deployment if it fails, so consider the delete policy carefully.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>curl -X POST</code> with <code>-H 'Content-Type: application/json'</code>
                and <code>-d '{...}'</code> to send the Slack message. Template in the release metadata.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>command:
                  - curl
                  - -X POST
                  - -H 'Content-Type: application/json'
                  - -d '{"text":"Deployed RELEASE vVERSION to NAMESPACE"}'
                  - WEBHOOK_URL</pre>
          solution: |-
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: {{ .Release.Name }}-notify
              annotations:
                "helm.sh/hook": post-upgrade
                "helm.sh/hook-weight": "99"
                "helm.sh/hook-delete-policy": hook-succeeded,before-hook-creation
            spec:
              template:
                spec:
                  containers:
                    - name: notify
                      image: curlimages/curl:latest
                      command:
                        - curl
                        - -sf
                        - -X
                        - POST
                        - -H
                        - "Content-Type: application/json"
                        - -d
                        - '{"text":"Deployed {{ .Release.Name }} ({{ .Chart.Version }}) to {{ .Release.Namespace }}"}'
                        - {{ .Values.slack.webhookUrl }}
                  restartPolicy: Never
              backoffLimit: 1
          difficulty: 3
    - id: challenge_3
      block: 1
      difficulty: 2
      concept: Template Rendering
      variants:
        - id: v1
          title: Predict the Rendered Labels
          description: >-
            Given the following values and template, predict the rendered output.<br><br>
            <strong>values.yaml:</strong><br>
            <pre>app:
              name: web-frontend
              version: "2.1.0"
            environment: staging</pre><br>
            <strong>Template:</strong><br>
            <pre>metadata:
              labels:
                app: {{ .Values.app.name }}
                version: {{ .Values.app.version | quote }}
                env: {{ .Values.environment }}
                release: {{ .Release.Name }}</pre><br>
            Assume the release name is <code>my-release</code>.
          functionSignature: "Predict rendered YAML output"
          testCases:
            - input: "app: {name: web-frontend, version: '2.1.0'}, environment: staging, Release.Name: my-release"
              output: |-
                metadata:
                  labels:
                    app: web-frontend
                    version: "2.1.0"
                    env: staging
                    release: my-release
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each <code>{{ }}</code> expression is replaced with the corresponding value. The
                <code>quote</code> function wraps the value in double quotes.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>.Values.app.name</code> resolves to <code>web-frontend</code>.
                <code>.Values.app.version | quote</code> resolves to <code>"2.1.0"</code> (with quotes).
            - title: "\U0001F527 Pattern"
              content: >-
                Walk through each template expression one at a time and substitute the value from
                values.yaml or built-in objects.
          solution: |-
            metadata:
              labels:
                app: web-frontend
                version: "2.1.0"
                env: staging
                release: my-release
          difficulty: 2
        - id: v2
          title: Predict Conditional Output
          description: >-
            Given the following values and template, predict the rendered output.<br><br>
            <strong>values.yaml:</strong><br>
            <pre>ingress:
              enabled: true
              host: myapp.example.com
            tls:
              enabled: false</pre><br>
            <strong>Template:</strong><br>
            <pre>{{- if .Values.ingress.enabled }}
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            spec:
              rules:
                - host: {{ .Values.ingress.host }}
            {{- if .Values.tls.enabled }}
              tls:
                - hosts:
                    - {{ .Values.ingress.host }}
            {{- end }}
            {{- end }}</pre>
          functionSignature: "Predict rendered YAML output"
          testCases:
            - input: "ingress: {enabled: true, host: myapp.example.com}, tls: {enabled: false}"
              output: |-
                apiVersion: networking.k8s.io/v1
                kind: Ingress
                spec:
                  rules:
                    - host: myapp.example.com
            - input: "ingress: {enabled: true, host: myapp.example.com}, tls: {enabled: true}"
              output: |-
                apiVersion: networking.k8s.io/v1
                kind: Ingress
                spec:
                  rules:
                    - host: myapp.example.com
                  tls:
                    - hosts:
                        - myapp.example.com
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Two conditionals are at play: the outer one controls whether the Ingress exists at all,
                and the inner one controls whether TLS is configured.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>ingress.enabled</code> is <code>true</code>, so the Ingress is rendered.
                <code>tls.enabled</code> is <code>false</code>, so the TLS block is omitted.
            - title: "\U0001F527 Pattern"
              content: >-
                Evaluate each <code>if</code> condition. If true, include the block. If false, skip it.
                The <code>{{-</code> trims leading whitespace.
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            spec:
              rules:
                - host: myapp.example.com
          difficulty: 2
        - id: v3
          title: Predict Range Loop Output
          description: >-
            Given the following values and template, predict the rendered output.<br><br>
            <strong>values.yaml:</strong><br>
            <pre>ports:
              - name: http
                port: 80
                targetPort: 8080
              - name: https
                port: 443
                targetPort: 8443</pre><br>
            <strong>Template:</strong><br>
            <pre>spec:
              ports:
            {{- range .Values.ports }}
                - name: {{ .name }}
                  port: {{ .port }}
                  targetPort: {{ .targetPort }}
                  protocol: TCP
            {{- end }}</pre>
          functionSignature: "Predict rendered YAML output"
          testCases:
            - input: "ports: [{name: http, port: 80, targetPort: 8080}, {name: https, port: 443, targetPort: 8443}]"
              output: |-
                spec:
                  ports:
                    - name: http
                      port: 80
                      targetPort: 8080
                      protocol: TCP
                    - name: https
                      port: 443
                      targetPort: 8443
                      protocol: TCP
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The <code>range</code> iterates over the list. Inside the range, <code>.</code> (the dot)
                refers to the current list element, not the top-level context.
            - title: "\U0001F4A1 Hint"
              content: >-
                Each iteration produces one list item with the fields from the current port object.
                The <code>protocol: TCP</code> is a hardcoded value added to every port.
            - title: "\U0001F527 Pattern"
              content: >-
                Unroll the loop: first iteration uses the first list element, second iteration uses the
                second. Replace each <code>.name</code>, <code>.port</code>, <code>.targetPort</code>
                with values from each element.
          solution: |-
            spec:
              ports:
                - name: http
                  port: 80
                  targetPort: 8080
                  protocol: TCP
                - name: https
                  port: 443
                  targetPort: 8443
                  protocol: TCP
          difficulty: 2
        - id: v4
          title: Predict Sprig Function Output
          description: >-
            Given the following values and template, predict the rendered output.<br><br>
            <strong>values.yaml:</strong><br>
            <pre>app:
              name: My_Web_App
              domain: EXAMPLE.COM
              tag: "v1.2.3-beta"</pre><br>
            <strong>Template:</strong><br>
            <pre>name: {{ .Values.app.name | lower | replace "_" "-" }}
            domain: {{ .Values.app.domain | lower }}
            image: myrepo/app:{{ .Values.app.tag | trimPrefix "v" }}
            encoded: {{ .Values.app.name | b64enc }}</pre>
          functionSignature: "Predict rendered output"
          testCases:
            - input: "app: {name: My_Web_App, domain: EXAMPLE.COM, tag: 'v1.2.3-beta'}"
              output: |-
                name: my-web-app
                domain: example.com
                image: myrepo/app:1.2.3-beta
                encoded: TXlfV2ViX0FwcA==
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Trace each pipe chain left to right. <code>lower</code> converts to lowercase.
                <code>replace</code> substitutes characters. <code>trimPrefix</code> removes a leading
                string. <code>b64enc</code> base64-encodes.
            - title: "\U0001F4A1 Hint"
              content: >-
                For the name: <code>My_Web_App</code> -> <code>my_web_app</code> (lower) ->
                <code>my-web-app</code> (replace). For the tag: <code>v1.2.3-beta</code> ->
                <code>1.2.3-beta</code> (trimPrefix "v").
            - title: "\U0001F527 Pattern"
              content: >-
                Apply each function in order. For b64enc, <code>My_Web_App</code> in base64 is
                <code>TXlfV2ViX0FwcA==</code>.
          solution: |-
            name: my-web-app
            domain: example.com
            image: myrepo/app:1.2.3-beta
            encoded: TXlfV2ViX0FwcA==
          difficulty: 3
        - id: v5
          title: Predict toYaml with nindent
          description: >-
            Given the following values and template, predict the rendered output.<br><br>
            <strong>values.yaml:</strong><br>
            <pre>resources:
              limits:
                cpu: 500m
                memory: 256Mi
              requests:
                cpu: 100m
                memory: 128Mi
            nodeSelector:
              disktype: ssd</pre><br>
            <strong>Template:</strong><br>
            <pre>spec:
              containers:
                - name: app
                  resources:
                    {{- toYaml .Values.resources | nindent 12 }}
              nodeSelector:
                {{- toYaml .Values.nodeSelector | nindent 8 }}</pre>
          functionSignature: "Predict rendered YAML output"
          testCases:
            - input: "resources: {limits: {cpu: 500m, memory: 256Mi}, requests: {cpu: 100m, memory: 128Mi}}, nodeSelector: {disktype: ssd}"
              output: |-
                spec:
                  containers:
                    - name: app
                      resources:
                        limits:
                          cpu: 500m
                          memory: 256Mi
                        requests:
                          cpu: 100m
                          memory: 128Mi
                  nodeSelector:
                    disktype: ssd
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>toYaml</code> converts the value to YAML text. <code>nindent 12</code> adds a
                newline and indents every line by 12 spaces. The <code>{{-</code> trims whitespace
                before the tag.
            - title: "\U0001F4A1 Hint"
              content: >-
                The resources block gets indented to 12 spaces (4 levels deep: spec > containers > item >
                resources). The nodeSelector gets indented to 8 spaces (2 levels deep: spec > nodeSelector).
            - title: "\U0001F527 Pattern"
              content: >-
                First render what <code>toYaml</code> produces (the raw YAML), then mentally indent
                every line by the specified amount.
          solution: |-
            spec:
              containers:
                - name: app
                  resources:
                    limits:
                      cpu: 500m
                      memory: 256Mi
                    requests:
                      cpu: 100m
                      memory: 128Mi
              nodeSelector:
                disktype: ssd
          difficulty: 3
        - id: v6
          title: Predict Default Values and Ternary
          description: >-
            Given the following values and template, predict the rendered output.<br><br>
            <strong>values.yaml:</strong><br>
            <pre>replicas: 0
            image:
              repository: nginx
              tag: ""
            service:
              type: ""</pre><br>
            <strong>Template:</strong><br>
            <pre>replicas: {{ .Values.replicas | default 3 }}
            image: {{ .Values.image.repository }}:{{ .Values.image.tag | default "latest" }}
            serviceType: {{ .Values.service.type | default "ClusterIP" }}
            isProduction: {{ eq .Values.replicas 0.0 | ternary "no" "yes" }}</pre>
          functionSignature: "Predict rendered output"
          testCases:
            - input: "replicas: 0, image: {repository: nginx, tag: ''}, service: {type: ''}"
              output: |-
                replicas: 3
                image: nginx:latest
                serviceType: ClusterIP
                isProduction: no
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The <code>default</code> function returns the fallback when the input is empty, nil,
                zero, or false. Be careful: <code>0</code> is considered empty by <code>default</code>!
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>replicas</code> is <code>0</code>, which is falsy, so <code>default 3</code> gives
                <code>3</code>. Empty strings are also falsy. <code>ternary</code> is like a ternary
                operator: <code>condition | ternary trueVal falseVal</code>.
            - title: "\U0001F527 Pattern"
              content: >-
                Check each value: is it empty/zero/nil? If yes, <code>default</code> kicks in. For
                <code>ternary</code>, evaluate the condition first, then pick the matching value.
          solution: |-
            replicas: 3
            image: nginx:latest
            serviceType: ClusterIP
            isProduction: no
          difficulty: 3
        - id: v7
          title: Predict Dict and Range Output
          description: >-
            Given the following values and template, predict the rendered output.<br><br>
            <strong>values.yaml:</strong><br>
            <pre>env:
              DATABASE_URL: postgres://db:5432/app
              REDIS_URL: redis://cache:6379
              LOG_LEVEL: info</pre><br>
            <strong>Template:</strong><br>
            <pre>env:
            {{- range $key, $val := .Values.env }}
              - name: {{ $key }}
                value: {{ $val | quote }}
            {{- end }}</pre>
          functionSignature: "Predict rendered YAML output"
          testCases:
            - input: "env: {DATABASE_URL: 'postgres://db:5432/app', REDIS_URL: 'redis://cache:6379', LOG_LEVEL: info}"
              output: |-
                env:
                  - name: DATABASE_URL
                    value: "postgres://db:5432/app"
                  - name: LOG_LEVEL
                    value: "info"
                  - name: REDIS_URL
                    value: "redis://cache:6379"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When ranging over a dict, the keys are iterated in alphabetical order in Helm/Go templates.
                The <code>quote</code> function wraps each value in double quotes.
            - title: "\U0001F4A1 Hint"
              content: >-
                The keys sorted alphabetically are: DATABASE_URL, LOG_LEVEL, REDIS_URL. Each gets rendered
                as a <code>name</code>/<code>value</code> pair.
            - title: "\U0001F527 Pattern"
              content: >-
                Sort the keys alphabetically, then render each key-value pair using the template inside
                the range block.
          solution: |-
            env:
              - name: DATABASE_URL
                value: "postgres://db:5432/app"
              - name: LOG_LEVEL
                value: "info"
              - name: REDIS_URL
                value: "redis://cache:6379"
          difficulty: 3
        - id: v8
          title: Predict Named Template Include
          description: >-
            Given the following helper template and usage, predict the rendered output.<br><br>
            <strong>_helpers.tpl:</strong><br>
            <pre>{{- define "myapp.labels" -}}
            app.kubernetes.io/name: {{ .Chart.Name }}
            app.kubernetes.io/instance: {{ .Release.Name }}
            app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
            app.kubernetes.io/managed-by: {{ .Release.Service }}
            {{- end -}}</pre><br>
            <strong>Template:</strong><br>
            <pre>metadata:
              name: {{ .Release.Name }}-svc
              labels:
                {{- include "myapp.labels" . | nindent 4 }}</pre><br>
            Assume: Chart.Name=<code>myapp</code>, Release.Name=<code>prod</code>,
            Chart.AppVersion=<code>1.5.0</code>, Release.Service=<code>Helm</code>.
          functionSignature: "Predict rendered YAML output"
          testCases:
            - input: "Chart.Name: myapp, Release.Name: prod, Chart.AppVersion: 1.5.0, Release.Service: Helm"
              output: |-
                metadata:
                  name: prod-svc
                  labels:
                    app.kubernetes.io/name: myapp
                    app.kubernetes.io/instance: prod
                    app.kubernetes.io/version: "1.5.0"
                    app.kubernetes.io/managed-by: Helm
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The <code>include</code> function renders the named template and returns the result as
                a string. That string is then piped through <code>nindent 4</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                First render <code>myapp.labels</code> with the given values. Then apply
                <code>nindent 4</code> to indent the result 4 spaces. The <code>{{-</code> trims
                whitespace before the include.
            - title: "\U0001F527 Pattern"
              content: >-
                Render the named template as if it were inline, then indent it to the correct level.
                <code>include</code> differs from <code>template</code> in that it returns a string
                you can pipe.
          solution: |-
            metadata:
              name: prod-svc
              labels:
                app.kubernetes.io/name: myapp
                app.kubernetes.io/instance: prod
                app.kubernetes.io/version: "1.5.0"
                app.kubernetes.io/managed-by: Helm
          difficulty: 4
