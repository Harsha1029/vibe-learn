conceptLinks:
  Chart.yaml: "#lesson-chart-yaml"
  values.yaml: "#lesson-values-yaml"
  Go Template Basics: "#lesson-go-templates"
  Template Helpers: "#lesson-helpers-tpl"
  Deployment Template: "#lesson-deployment-template"
  Service Template: "#lesson-service-template"
  Template Debugging: "#lesson-template-debugging"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Chart.yaml
      variants:
        - id: v1
          title: Basic Chart.yaml
          description: >-
            Write a minimal <code>Chart.yaml</code> for a Helm chart named <code>webapp</code> at version
            <code>0.1.0</code> with <code>apiVersion: v2</code>.
          hints:
            - "A Chart.yaml requires at minimum: <code>apiVersion</code>, <code>name</code>, and <code>version</code>."
            - "Use <code>apiVersion: v2</code> for Helm 3 charts."
          solution: |-
            apiVersion: v2
            name: webapp
            version: 0.1.0
        - id: v2
          title: Chart.yaml with appVersion
          description: >-
            Write a <code>Chart.yaml</code> for a chart named <code>api-server</code> at chart version <code>1.2.0</code>
            with <code>appVersion: "3.5.1"</code>. Include a description.
          hints:
            - "<code>appVersion</code> tracks the version of the application being deployed, separate from the chart version."
            - "Always quote <code>appVersion</code> as a string."
          solution: |-
            apiVersion: v2
            name: api-server
            version: 1.2.0
            appVersion: "3.5.1"
            description: A Helm chart for the API server
        - id: v3
          title: Chart.yaml with Type
          description: >-
            Write a <code>Chart.yaml</code> for a library chart named <code>common-lib</code> at version
            <code>0.3.0</code>. Library charts use <code>type: library</code>.
          hints:
            - "Helm supports two chart types: <code>application</code> (default) and <code>library</code>."
            - "Library charts provide templates that other charts can reuse but cannot be installed directly."
          solution: |-
            apiVersion: v2
            name: common-lib
            version: 0.3.0
            type: library
            description: Common template helpers for all charts
        - id: v4
          title: Chart.yaml with a Dependency
          description: >-
            Write a <code>Chart.yaml</code> for <code>myapp</code> version <code>1.0.0</code> that depends on
            <code>postgresql</code> version <code>12.x.x</code> from the Bitnami repository at
            <code>https://charts.bitnami.com/bitnami</code>.
          hints:
            - "Dependencies are listed under the <code>dependencies</code> key as a list."
            - "Each dependency needs <code>name</code>, <code>version</code>, and <code>repository</code>."
          solution: |-
            apiVersion: v2
            name: myapp
            version: 1.0.0
            appVersion: "1.0.0"
            description: My application chart
            dependencies:
              - name: postgresql
                version: "12.x.x"
                repository: https://charts.bitnami.com/bitnami
        - id: v5
          title: Chart.yaml with Conditional Dependency
          description: >-
            Write a <code>Chart.yaml</code> for <code>backend</code> version <code>2.0.0</code> with a
            <code>redis</code> dependency from Bitnami that is conditionally enabled via <code>redis.enabled</code>.
          hints:
            - "Use the <code>condition</code> field on a dependency to make it toggleable."
            - "The condition references a values.yaml path like <code>redis.enabled</code>."
          solution: |-
            apiVersion: v2
            name: backend
            version: 2.0.0
            appVersion: "2.0.0"
            description: Backend service chart
            dependencies:
              - name: redis
                version: "17.x.x"
                repository: https://charts.bitnami.com/bitnami
                condition: redis.enabled
        - id: v6
          title: Chart.yaml with Multiple Dependencies
          description: >-
            Write a <code>Chart.yaml</code> for <code>fullstack</code> version <code>1.0.0</code> that depends on both
            <code>postgresql</code> (version <code>12.x.x</code>) and <code>redis</code> (version <code>17.x.x</code>),
            both from Bitnami. Redis should be optional via <code>redis.enabled</code>.
          hints:
            - "List multiple entries under <code>dependencies</code>."
            - "Only the optional dependency needs a <code>condition</code> field."
          solution: |-
            apiVersion: v2
            name: fullstack
            version: 1.0.0
            appVersion: "1.0.0"
            description: Full-stack application chart
            dependencies:
              - name: postgresql
                version: "12.x.x"
                repository: https://charts.bitnami.com/bitnami
              - name: redis
                version: "17.x.x"
                repository: https://charts.bitnami.com/bitnami
                condition: redis.enabled
        - id: v7
          title: Chart.yaml with Alias
          description: >-
            Write a <code>Chart.yaml</code> for <code>multi-db</code> version <code>1.0.0</code> that depends on
            <code>postgresql</code> twice -- once aliased as <code>primary-db</code> and once as <code>replica-db</code>.
          hints:
            - "Use the <code>alias</code> field to give a dependency a different name."
            - "This lets you include the same chart multiple times with different configurations."
          solution: |-
            apiVersion: v2
            name: multi-db
            version: 1.0.0
            appVersion: "1.0.0"
            description: Chart with primary and replica databases
            dependencies:
              - name: postgresql
                version: "12.x.x"
                repository: https://charts.bitnami.com/bitnami
                alias: primary-db
              - name: postgresql
                version: "12.x.x"
                repository: https://charts.bitnami.com/bitnami
                alias: replica-db
        - id: v8
          title: Chart.yaml with Maintainers
          description: >-
            Write a <code>Chart.yaml</code> for <code>monitoring</code> version <code>3.1.0</code> with a maintainer
            entry including <code>name</code>, <code>email</code>, and <code>url</code>. Add keywords and a home URL.
          hints:
            - "Maintainers is a list of objects with <code>name</code>, <code>email</code>, and optionally <code>url</code>."
            - "<code>keywords</code> is a list of strings that help users discover the chart."
          solution: |-
            apiVersion: v2
            name: monitoring
            version: 3.1.0
            appVersion: "2.45.0"
            description: Prometheus monitoring stack
            home: https://github.com/example/monitoring-chart
            keywords:
              - monitoring
              - prometheus
              - grafana
            maintainers:
              - name: Jane Doe
                email: jane@example.com
                url: https://example.com
        - id: v9
          title: Chart.yaml with Sources and Icon
          description: >-
            Write a <code>Chart.yaml</code> for <code>nginx-ingress</code> version <code>4.0.0</code>. Include
            <code>icon</code>, <code>sources</code>, and <code>kubeVersion</code> (require Kubernetes >=1.22.0).
          hints:
            - "<code>kubeVersion</code> accepts a SemVer constraint like <code>\">=1.22.0\"</code>."
            - "<code>sources</code> is a list of URLs pointing to source code."
          solution: |-
            apiVersion: v2
            name: nginx-ingress
            version: 4.0.0
            appVersion: "1.9.0"
            description: NGINX Ingress Controller
            kubeVersion: ">=1.22.0"
            icon: https://example.com/icons/nginx.png
            sources:
              - https://github.com/example/nginx-ingress
        - id: v10
          title: Chart.yaml with Deprecated Flag
          description: >-
            Write a <code>Chart.yaml</code> for <code>legacy-api</code> version <code>5.0.0</code> that marks the chart
            as deprecated. Include a description explaining the replacement.
          hints:
            - "Set <code>deprecated: true</code> to mark a chart as deprecated."
            - "Helm will show a warning when users try to install a deprecated chart."
          solution: |-
            apiVersion: v2
            name: legacy-api
            version: 5.0.0
            appVersion: "2.0.0"
            description: "DEPRECATED - use api-v2 chart instead"
            deprecated: true
    - id: warmup_2
      concept: values.yaml
      variants:
        - id: v1
          title: Basic values.yaml
          description: >-
            Write a <code>values.yaml</code> with <code>replicaCount: 1</code>, image repository
            <code>nginx</code> with tag <code>"1.25"</code>, and a ClusterIP service on port 80.
          hints:
            - "Follow the convention: <code>image.repository</code>, <code>image.tag</code>, <code>service.type</code>, <code>service.port</code>."
            - "Quote the image tag to prevent YAML from interpreting numeric tags as numbers."
          solution: |-
            replicaCount: 1

            image:
              repository: nginx
              tag: "1.25"
              pullPolicy: IfNotPresent

            service:
              type: ClusterIP
              port: 80
        - id: v2
          title: values.yaml with Resources
          description: >-
            Write a <code>values.yaml</code> that sets CPU requests to <code>100m</code>, memory requests to
            <code>128Mi</code>, CPU limits to <code>500m</code>, and memory limits to <code>256Mi</code>.
          hints:
            - "Resources go under <code>resources.requests</code> and <code>resources.limits</code>."
            - "CPU is measured in millicores (m) and memory in mebibytes (Mi)."
          solution: |-
            resources:
              requests:
                cpu: 100m
                memory: 128Mi
              limits:
                cpu: 500m
                memory: 256Mi
        - id: v3
          title: values.yaml with Ingress
          description: >-
            Write a <code>values.yaml</code> section for ingress configuration: enabled (<code>true</code>), class
            <code>nginx</code>, host <code>app.example.com</code>, and TLS with a secret named <code>app-tls</code>.
          hints:
            - "Ingress typically has <code>enabled</code>, <code>className</code>, <code>hosts</code>, and <code>tls</code>."
            - "Hosts and TLS are lists since you can serve multiple domains."
          solution: |-
            ingress:
              enabled: true
              className: nginx
              hosts:
                - host: app.example.com
                  paths:
                    - path: /
                      pathType: Prefix
              tls:
                - secretName: app-tls
                  hosts:
                    - app.example.com
        - id: v4
          title: values.yaml with NodePort Service
          description: >-
            Write a <code>values.yaml</code> for a NodePort service on port <code>80</code> with nodePort
            <code>30080</code>. Include 3 replicas of image <code>myapp:latest</code>.
          hints:
            - "NodePort services need <code>service.type: NodePort</code> and <code>service.nodePort</code>."
            - "NodePort range is 30000-32767."
          solution: |-
            replicaCount: 3

            image:
              repository: myapp
              tag: "latest"
              pullPolicy: Always

            service:
              type: NodePort
              port: 80
              nodePort: 30080
        - id: v5
          title: values.yaml with Environment Variables
          description: >-
            Write a <code>values.yaml</code> with an <code>env</code> section containing <code>DATABASE_URL</code>
            (value from a secret named <code>db-secret</code>, key <code>url</code>) and <code>LOG_LEVEL</code> (plain
            value <code>"info"</code>).
          hints:
            - "Environment variables can be plain values or references to secrets/configmaps."
            - "Structure them so templates can iterate over them."
          solution: |-
            env:
              - name: LOG_LEVEL
                value: "info"
              - name: DATABASE_URL
                valueFrom:
                  secretKeyRef:
                    name: db-secret
                    key: url
        - id: v6
          title: values.yaml with Probes
          description: >-
            Write a <code>values.yaml</code> section defining a liveness probe (HTTP GET on <code>/healthz</code> port
            <code>8080</code>) and a readiness probe (HTTP GET on <code>/ready</code> port <code>8080</code>).
          hints:
            - "Probes go under <code>livenessProbe</code> and <code>readinessProbe</code>."
            - "Include <code>initialDelaySeconds</code> and <code>periodSeconds</code> for timing."
          solution: |-
            livenessProbe:
              httpGet:
                path: /healthz
                port: 8080
              initialDelaySeconds: 15
              periodSeconds: 10

            readinessProbe:
              httpGet:
                path: /ready
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
        - id: v7
          title: values.yaml with Autoscaling
          description: >-
            Write a <code>values.yaml</code> section to configure horizontal pod autoscaling: enabled, min replicas 2,
            max replicas 10, target CPU utilization 80%.
          hints:
            - "Group autoscaling settings under an <code>autoscaling</code> key."
            - "Include an <code>enabled</code> toggle so templates can conditionally create the HPA."
          solution: |-
            autoscaling:
              enabled: true
              minReplicas: 2
              maxReplicas: 10
              targetCPUUtilizationPercentage: 80
        - id: v8
          title: values.yaml with ServiceAccount
          description: >-
            Write a <code>values.yaml</code> section for a service account: creation enabled, name
            <code>my-sa</code>, and an annotation for AWS IAM role
            <code>arn:aws:iam::123456789:role/my-role</code>.
          hints:
            - "Service account config typically goes under <code>serviceAccount</code>."
            - "Annotations is a map of key-value strings."
          solution: |-
            serviceAccount:
              create: true
              name: my-sa
              annotations:
                eks.amazonaws.com/role-arn: "arn:aws:iam::123456789:role/my-role"
        - id: v9
          title: values.yaml with Tolerations and NodeSelector
          description: >-
            Write a <code>values.yaml</code> section that targets nodes labeled <code>tier: backend</code> and tolerates
            the taint <code>dedicated=backend:NoSchedule</code>.
          hints:
            - "<code>nodeSelector</code> is a simple key-value map."
            - "Tolerations is a list of objects with <code>key</code>, <code>operator</code>, <code>value</code>, and <code>effect</code>."
          solution: |-
            nodeSelector:
              tier: backend

            tolerations:
              - key: dedicated
                operator: Equal
                value: backend
                effect: NoSchedule
        - id: v10
          title: values.yaml with PVC
          description: >-
            Write a <code>values.yaml</code> section for persistent storage: enabled, storage class
            <code>gp3</code>, access mode <code>ReadWriteOnce</code>, size <code>10Gi</code>.
          hints:
            - "Group persistence settings under a <code>persistence</code> key."
            - "Include <code>enabled</code> so the PVC creation is conditional."
          solution: |-
            persistence:
              enabled: true
              storageClass: gp3
              accessMode: ReadWriteOnce
              size: 10Gi
        - id: v11
          title: values.yaml with Image Pull Secret
          description: >-
            Write a <code>values.yaml</code> for image <code>registry.example.com/myapp</code> tag <code>"2.0"</code>
            with a private registry pull secret named <code>regcred</code>.
          hints:
            - "<code>imagePullSecrets</code> is a list of objects with a <code>name</code> field."
            - "The pull policy for private registries is often <code>Always</code>."
          solution: |-
            image:
              repository: registry.example.com/myapp
              tag: "2.0"
              pullPolicy: Always

            imagePullSecrets:
              - name: regcred
    - id: warmup_3
      concept: Go Template Basics
      variants:
        - id: v1
          title: Access a Value
          description: >-
            Write a Go template expression that renders the <code>replicaCount</code> value from
            <code>values.yaml</code>.
          hints:
            - "Values from values.yaml are accessed through the <code>.Values</code> object."
            - "Use double curly braces: <code>{{ }}</code>."
          solution: "{{ .Values.replicaCount }}"
        - id: v2
          title: Access Nested Values
          description: >-
            Write a Go template expression that renders the image as
            <code>repository:tag</code> using <code>.Values.image.repository</code> and <code>.Values.image.tag</code>.
          hints:
            - "You can concatenate values by placing them next to static text."
            - "Use a colon between the two expressions."
          solution: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
        - id: v3
          title: Release Name
          description: >-
            Write a Go template expression that outputs the Helm release name.
          hints:
            - "Built-in objects include <code>.Release</code> with fields like <code>.Release.Name</code>."
            - "This is set when you run <code>helm install my-release ./chart</code>."
          solution: "{{ .Release.Name }}"
        - id: v4
          title: Default Values
          description: >-
            Write a Go template expression that outputs <code>.Values.image.tag</code> but defaults to
            <code>"latest"</code> if the tag is not set.
          hints:
            - "The <code>default</code> function provides a fallback value."
            - "Syntax: <code>{{ default \"fallback\" .Values.path }}</code> or pipe syntax."
          solution: "{{ .Values.image.tag | default \"latest\" }}"
        - id: v5
          title: Quote a Value
          description: >-
            Write a Go template expression that outputs <code>.Values.app.name</code> wrapped in double quotes
            using the <code>quote</code> function.
          hints:
            - "The <code>quote</code> function wraps a value in double quotes, useful for YAML string safety."
            - "Use pipe syntax: <code>{{ .Values.x | quote }}</code>."
          solution: "{{ .Values.app.name | quote }}"
        - id: v6
          title: If/Else Conditional
          description: >-
            Write a Go template block that outputs <code>type: NodePort</code> if
            <code>.Values.service.type</code> equals <code>"NodePort"</code>, otherwise outputs
            <code>type: ClusterIP</code>.
          hints:
            - "Use <code>{{ if eq .Values.x \"value\" }}</code> for equality checks."
            - "Close with <code>{{ end }}</code>."
          solution: |-
            {{ if eq .Values.service.type "NodePort" }}
            type: NodePort
            {{ else }}
            type: ClusterIP
            {{ end }}
        - id: v7
          title: Range over a List
          description: >-
            Write a Go template that iterates over <code>.Values.env</code> (a list of objects with <code>name</code>
            and <code>value</code>) and renders each as <code>- name: X</code> / <code>  value: Y</code>.
          hints:
            - "Use <code>{{ range .Values.env }}</code> to iterate over a list."
            - "Inside range, <code>.</code> refers to the current element."
          solution: |-
            {{ range .Values.env }}
            - name: {{ .name }}
              value: {{ .value | quote }}
            {{ end }}
        - id: v8
          title: With Block
          description: >-
            Write a Go template that uses <code>{{ with }}</code> to scope into
            <code>.Values.resources</code> and render CPU and memory requests.
          hints:
            - "<code>{{ with .Values.resources }}</code> changes the scope so <code>.</code> refers to the resources block."
            - "If resources is nil/empty, the block is skipped entirely."
          solution: |-
            {{ with .Values.resources }}
            resources:
              requests:
                cpu: {{ .requests.cpu }}
                memory: {{ .requests.memory }}
              limits:
                cpu: {{ .limits.cpu }}
                memory: {{ .limits.memory }}
            {{ end }}
        - id: v9
          title: Ternary with Conditional
          description: >-
            Write a Go template expression that outputs <code>"true"</code> if <code>.Values.ingress.enabled</code>
            is true, otherwise <code>"false"</code>. Use a single-line ternary-style pattern.
          hints:
            - "Helm has a <code>ternary</code> function: <code>{{ ternary \"a\" \"b\" .condition }}</code>."
            - "The condition is the third argument."
          solution: "{{ ternary \"true\" \"false\" .Values.ingress.enabled }}"
        - id: v10
          title: Trim Whitespace
          description: >-
            Write a Go template <code>if</code> block for <code>.Values.podAnnotations</code> that trims leading and
            trailing whitespace using <code>{{-</code> and <code>-}}</code>.
          hints:
            - "<code>{{-</code> trims whitespace before the tag, <code>-}}</code> trims after."
            - "This prevents blank lines in rendered output."
          solution: |-
            {{- if .Values.podAnnotations }}
            annotations:
              {{- toYaml .Values.podAnnotations | nindent 4 }}
            {{- end }}
        - id: v11
          title: toYaml and nindent
          description: >-
            Write a Go template expression that converts <code>.Values.nodeSelector</code> to YAML and indents it
            by 8 spaces using <code>toYaml</code> and <code>nindent</code>.
          hints:
            - "<code>toYaml</code> converts a map/list to YAML string format."
            - "<code>nindent N</code> adds a newline then indents by N spaces."
          solution: "{{- toYaml .Values.nodeSelector | nindent 8 }}"
        - id: v12
          title: Release Namespace
          description: >-
            Write a Go template expression that outputs the Kubernetes namespace where the chart is being installed.
          hints:
            - "The release namespace is available as <code>.Release.Namespace</code>."
            - "This is set by <code>helm install --namespace</code>."
          solution: "{{ .Release.Namespace }}"
        - id: v13
          title: Chart Name and Version
          description: >-
            Write a Go template expression that outputs the chart name and version in the format
            <code>chartname-1.0.0</code> using <code>.Chart.Name</code> and <code>.Chart.Version</code>.
          hints:
            - "<code>.Chart</code> provides metadata from Chart.yaml."
            - "Use <code>printf</code> or concatenate with a hyphen."
          solution: "{{ .Chart.Name }}-{{ .Chart.Version }}"
    - id: warmup_4
      concept: Template Helpers
      variants:
        - id: v1
          title: Define a Named Template
          description: >-
            Write a named template in <code>_helpers.tpl</code> called <code>myapp.fullname</code> that outputs the
            release name.
          hints:
            - "Named templates use <code>{{- define \"name\" }}</code> and <code>{{- end }}</code>."
            - "The convention is <code>chartname.fullname</code>."
          solution: |-
            {{- define "myapp.fullname" -}}
            {{ .Release.Name }}
            {{- end -}}
        - id: v2
          title: Include a Named Template
          description: >-
            Write a Go template expression that calls a named template <code>myapp.fullname</code> and uses its output
            as a metadata name.
          hints:
            - "Use <code>{{ include \"templateName\" . }}</code> to call a named template."
            - "The second argument (<code>.</code>) passes the current scope."
          solution: "name: {{ include \"myapp.fullname\" . }}"
        - id: v3
          title: Fullname with Override
          description: >-
            Write a <code>myapp.fullname</code> named template that uses <code>.Values.fullnameOverride</code> if set,
            otherwise falls back to the release name with the chart name.
          hints:
            - "Use <code>{{ if .Values.fullnameOverride }}</code> to check for an override."
            - "The fallback pattern is typically <code>releaseName-chartName</code>."
          solution: |-
            {{- define "myapp.fullname" -}}
            {{- if .Values.fullnameOverride -}}
            {{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" -}}
            {{- else -}}
            {{- printf "%s-%s" .Release.Name .Chart.Name | trunc 63 | trimSuffix "-" -}}
            {{- end -}}
            {{- end -}}
        - id: v4
          title: Common Labels Template
          description: >-
            Write a named template <code>myapp.labels</code> that outputs standard Kubernetes labels:
            <code>app.kubernetes.io/name</code>, <code>app.kubernetes.io/instance</code>, and
            <code>app.kubernetes.io/version</code>.
          hints:
            - "Use <code>.Chart.Name</code> for the app name and <code>.Release.Name</code> for the instance."
            - "Use <code>.Chart.AppVersion</code> for the version label."
          solution: |-
            {{- define "myapp.labels" -}}
            app.kubernetes.io/name: {{ .Chart.Name }}
            app.kubernetes.io/instance: {{ .Release.Name }}
            app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
            app.kubernetes.io/managed-by: {{ .Release.Service }}
            {{- end -}}
        - id: v5
          title: Selector Labels Template
          description: >-
            Write a named template <code>myapp.selectorLabels</code> that outputs only the two labels used for pod
            selection: <code>app.kubernetes.io/name</code> and <code>app.kubernetes.io/instance</code>.
          hints:
            - "Selector labels are a subset of full labels -- they must stay immutable."
            - "They are used in both the Deployment selector and the Service selector."
          solution: |-
            {{- define "myapp.selectorLabels" -}}
            app.kubernetes.io/name: {{ .Chart.Name }}
            app.kubernetes.io/instance: {{ .Release.Name }}
            {{- end -}}
        - id: v6
          title: Include Labels with Indentation
          description: >-
            Write a metadata section that includes <code>myapp.labels</code> indented correctly under
            <code>labels:</code>.
          hints:
            - "Use <code>include</code> with <code>nindent</code> to control indentation."
            - "Metadata labels are typically indented 4 spaces."
          solution: |-
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
        - id: v7
          title: Image Pull Template
          description: >-
            Write a named template <code>myapp.image</code> that constructs a full image string from
            <code>.Values.image.repository</code> and <code>.Values.image.tag</code>, defaulting tag to
            <code>.Chart.AppVersion</code>.
          hints:
            - "Use <code>printf</code> to format <code>repo:tag</code>."
            - "Use <code>default .Chart.AppVersion</code> for the tag fallback."
          solution: |-
            {{- define "myapp.image" -}}
            {{- printf "%s:%s" .Values.image.repository (.Values.image.tag | default .Chart.AppVersion) -}}
            {{- end -}}
        - id: v8
          title: ServiceAccount Name Template
          description: >-
            Write a named template <code>myapp.serviceAccountName</code> that returns
            <code>.Values.serviceAccount.name</code> if set, otherwise returns the fullname.
          hints:
            - "Check if service account creation is enabled and if a name is provided."
            - "Fall back to <code>include \"myapp.fullname\" .</code> if no name is given."
          solution: |-
            {{- define "myapp.serviceAccountName" -}}
            {{- if .Values.serviceAccount.create -}}
            {{- default (include "myapp.fullname" .) .Values.serviceAccount.name -}}
            {{- else -}}
            {{- default "default" .Values.serviceAccount.name -}}
            {{- end -}}
            {{- end -}}
        - id: v9
          title: Chart Label Template
          description: >-
            Write a named template <code>myapp.chart</code> that outputs the chart name and version in the format
            <code>chartname-1.0.0</code>, replacing <code>+</code> with <code>_</code> (since <code>+</code> is not
            allowed in label values).
          hints:
            - "Use <code>printf</code> to combine name and version."
            - "Use the <code>replace</code> function to swap <code>+</code> for <code>_</code>."
          solution: |-
            {{- define "myapp.chart" -}}
            {{- printf "%s-%s" .Chart.Name .Chart.Version | replace "+" "_" | trunc 63 | trimSuffix "-" -}}
            {{- end -}}
        - id: v10
          title: Namespace Template
          description: >-
            Write a named template <code>myapp.namespace</code> that uses <code>.Values.namespaceOverride</code> if
            set, otherwise falls back to <code>.Release.Namespace</code>.
          hints:
            - "This follows the same pattern as fullname overrides."
            - "Use a simple if/else block."
          solution: |-
            {{- define "myapp.namespace" -}}
            {{- if .Values.namespaceOverride -}}
            {{- .Values.namespaceOverride -}}
            {{- else -}}
            {{- .Release.Namespace -}}
            {{- end -}}
            {{- end -}}
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Deployment Template
      variants:
        - id: v1
          title: Basic Deployment Template
          description: >-
            Write a complete Helm <code>deployment.yaml</code> template for a simple web application. It should use
            <code>.Values.replicaCount</code>, include standard labels via <code>myapp.labels</code>, use selector
            labels via <code>myapp.selectorLabels</code>, and configure the container with image, port 80, and
            resource limits from values.
          functionSignature: "templates/deployment.yaml"
          testCases:
            - input: "replicaCount: 2, image.repository: nginx, image.tag: \"1.25\""
              output: "Deployment with 2 replicas of nginx:1.25, port 80"
            - input: "replicaCount: 1, image.repository: myapp, image.tag: \"latest\""
              output: "Deployment with 1 replica of myapp:latest, port 80"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A Deployment template needs apiVersion, kind, metadata, and spec. The spec contains a selector (which
                must match pod labels) and a template for the pod.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>include "myapp.selectorLabels" .</code> in both <code>spec.selector.matchLabels</code> and
                <code>spec.template.metadata.labels</code> to ensure they match.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>apiVersion: apps/v1
                kind: Deployment
                metadata:
                  name: (fullname)
                  labels: (include labels)
                spec:
                  replicas: (from values)
                  selector:
                    matchLabels: (selectorLabels)
                  template:
                    metadata:
                      labels: (selectorLabels)
                    spec:
                      containers:
                        - name, image, ports, resources</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              replicas: {{ .Values.replicaCount }}
              selector:
                matchLabels:
                  {{- include "myapp.selectorLabels" . | nindent 6 }}
              template:
                metadata:
                  labels:
                    {{- include "myapp.selectorLabels" . | nindent 8 }}
                spec:
                  containers:
                    - name: {{ .Chart.Name }}
                      image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
                      imagePullPolicy: {{ .Values.image.pullPolicy }}
                      ports:
                        - name: http
                          containerPort: 80
                          protocol: TCP
                      {{- with .Values.resources }}
                      resources:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
          difficulty: 2
        - id: v2
          title: Deployment with Environment Variables
          description: >-
            Write a <code>deployment.yaml</code> template that includes environment variables from
            <code>.Values.env</code> (a list of env var objects). Use <code>range</code> to iterate and render each
            variable. Include probes from values if defined.
          functionSignature: "templates/deployment.yaml"
          testCases:
            - input: "env: [{name: LOG_LEVEL, value: info}, {name: PORT, value: \"8080\"}]"
              output: "Container with LOG_LEVEL=info and PORT=8080 env vars"
            - input: "env: [] (empty)"
              output: "Container with no env section"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you conditionally render the env section only when there are environment variables defined?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>{{- if .Values.env }}</code> to conditionally include the env block, then
                <code>toYaml</code> to render the list.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>containers:
                  - name: ...
                    image: ...
                    {{- if .Values.env }}
                    env:
                      {{- toYaml .Values.env | nindent 12 }}
                    {{- end }}
                    {{- if .Values.livenessProbe }}
                    livenessProbe:
                      {{- toYaml .Values.livenessProbe | nindent 14 }}
                    {{- end }}</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              replicas: {{ .Values.replicaCount }}
              selector:
                matchLabels:
                  {{- include "myapp.selectorLabels" . | nindent 6 }}
              template:
                metadata:
                  labels:
                    {{- include "myapp.selectorLabels" . | nindent 8 }}
                spec:
                  containers:
                    - name: {{ .Chart.Name }}
                      image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
                      imagePullPolicy: {{ .Values.image.pullPolicy }}
                      ports:
                        - name: http
                          containerPort: 80
                          protocol: TCP
                      {{- if .Values.env }}
                      env:
                        {{- toYaml .Values.env | nindent 12 }}
                      {{- end }}
                      {{- with .Values.livenessProbe }}
                      livenessProbe:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
                      {{- with .Values.readinessProbe }}
                      readinessProbe:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
                      {{- with .Values.resources }}
                      resources:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
          difficulty: 3
        - id: v3
          title: Deployment with Volume Mounts
          description: >-
            Write a <code>deployment.yaml</code> template that mounts a ConfigMap as a volume. The ConfigMap name
            comes from <code>.Values.config.name</code> and is mounted at <code>.Values.config.mountPath</code>.
            Only include the volume if <code>.Values.config.enabled</code> is true.
          functionSignature: "templates/deployment.yaml"
          testCases:
            - input: "config.enabled: true, config.name: app-config, config.mountPath: /etc/app"
              output: "Deployment with ConfigMap volume mounted at /etc/app"
            - input: "config.enabled: false"
              output: "Deployment with no volumes"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Volumes are defined at the pod spec level, and volumeMounts at the container level. Both need to be
                conditionally included.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the same <code>{{- if .Values.config.enabled }}</code> guard for both the <code>volumes</code>
                and <code>volumeMounts</code> sections.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>spec:
                  containers:
                    - name: ...
                      {{- if .Values.config.enabled }}
                      volumeMounts:
                        - name: config-volume
                          mountPath: {{ .Values.config.mountPath }}
                      {{- end }}
                  {{- if .Values.config.enabled }}
                  volumes:
                    - name: config-volume
                      configMap:
                        name: {{ .Values.config.name }}
                  {{- end }}</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              replicas: {{ .Values.replicaCount }}
              selector:
                matchLabels:
                  {{- include "myapp.selectorLabels" . | nindent 6 }}
              template:
                metadata:
                  labels:
                    {{- include "myapp.selectorLabels" . | nindent 8 }}
                spec:
                  containers:
                    - name: {{ .Chart.Name }}
                      image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
                      imagePullPolicy: {{ .Values.image.pullPolicy }}
                      ports:
                        - name: http
                          containerPort: 80
                          protocol: TCP
                      {{- if .Values.config.enabled }}
                      volumeMounts:
                        - name: config-volume
                          mountPath: {{ .Values.config.mountPath }}
                      {{- end }}
                      {{- with .Values.resources }}
                      resources:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
                  {{- if .Values.config.enabled }}
                  volumes:
                    - name: config-volume
                      configMap:
                        name: {{ .Values.config.name }}
                  {{- end }}
          difficulty: 3
        - id: v4
          title: Deployment with Autoscaling Toggle
          description: >-
            Write a <code>deployment.yaml</code> template where <code>spec.replicas</code> is only set when
            autoscaling is NOT enabled (<code>.Values.autoscaling.enabled</code> is false). When autoscaling is on,
            the HPA controls replica count, so the field must be omitted.
          functionSignature: "templates/deployment.yaml"
          testCases:
            - input: "autoscaling.enabled: false, replicaCount: 3"
              output: "Deployment with replicas: 3"
            - input: "autoscaling.enabled: true"
              output: "Deployment without replicas field (HPA manages it)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                If you set replicas in the Deployment AND have an HPA, they will fight each other. The Deployment
                should omit replicas when autoscaling is active.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>{{- if not .Values.autoscaling.enabled }}</code> to conditionally include the replicas
                field.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>spec:
                  {{- if not .Values.autoscaling.enabled }}
                  replicas: {{ .Values.replicaCount }}
                  {{- end }}
                  selector: ...</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              {{- if not .Values.autoscaling.enabled }}
              replicas: {{ .Values.replicaCount }}
              {{- end }}
              selector:
                matchLabels:
                  {{- include "myapp.selectorLabels" . | nindent 6 }}
              template:
                metadata:
                  labels:
                    {{- include "myapp.selectorLabels" . | nindent 8 }}
                spec:
                  containers:
                    - name: {{ .Chart.Name }}
                      image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
                      imagePullPolicy: {{ .Values.image.pullPolicy }}
                      ports:
                        - name: http
                          containerPort: 80
                          protocol: TCP
                      {{- with .Values.resources }}
                      resources:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
          difficulty: 2
        - id: v5
          title: Deployment with Pod Annotations
          description: >-
            Write a <code>deployment.yaml</code> template that conditionally renders pod annotations from
            <code>.Values.podAnnotations</code>. Also support <code>.Values.podSecurityContext</code> and
            <code>.Values.securityContext</code>.
          functionSignature: "templates/deployment.yaml"
          testCases:
            - input: "podAnnotations: {prometheus.io/scrape: \"true\", prometheus.io/port: \"8080\"}"
              output: "Pod template with prometheus annotations"
            - input: "podAnnotations: {} (empty)"
              output: "Pod template with no annotations section"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Annotations go in the pod template metadata, not the Deployment metadata. Use <code>toYaml</code>
                to render the map.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>{{- with .Values.podAnnotations }}</code> so the block is skipped when annotations are
                empty.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>template:
                  metadata:
                    labels: ...
                    {{- with .Values.podAnnotations }}
                    annotations:
                      {{- toYaml . | nindent 8 }}
                    {{- end }}
                  spec:
                    {{- with .Values.podSecurityContext }}
                    securityContext:
                      {{- toYaml . | nindent 8 }}
                    {{- end }}</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              replicas: {{ .Values.replicaCount }}
              selector:
                matchLabels:
                  {{- include "myapp.selectorLabels" . | nindent 6 }}
              template:
                metadata:
                  labels:
                    {{- include "myapp.selectorLabels" . | nindent 8 }}
                  {{- with .Values.podAnnotations }}
                  annotations:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                spec:
                  {{- with .Values.podSecurityContext }}
                  securityContext:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                  containers:
                    - name: {{ .Chart.Name }}
                      {{- with .Values.securityContext }}
                      securityContext:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
                      image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
                      imagePullPolicy: {{ .Values.image.pullPolicy }}
                      ports:
                        - name: http
                          containerPort: 80
                          protocol: TCP
                      {{- with .Values.resources }}
                      resources:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
          difficulty: 3
        - id: v6
          title: Deployment with Tolerations and Affinity
          description: >-
            Write a <code>deployment.yaml</code> template that includes <code>nodeSelector</code>,
            <code>tolerations</code>, and <code>affinity</code> from values. Each should only render if defined.
          functionSignature: "templates/deployment.yaml"
          testCases:
            - input: "nodeSelector: {tier: backend}, tolerations: [{key: dedicated, value: backend, effect: NoSchedule}]"
              output: "Pod spec with nodeSelector and tolerations"
            - input: "nodeSelector: {}, tolerations: [], affinity: {}"
              output: "Pod spec with no scheduling constraints"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Scheduling constraints (nodeSelector, tolerations, affinity) go at the pod spec level, not the
                container level.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>{{- with .Values.nodeSelector }}</code> for each section. The <code>with</code> block
                skips empty maps and nil values.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>spec:
                  containers: [...]
                  {{- with .Values.nodeSelector }}
                  nodeSelector:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                  {{- with .Values.tolerations }}
                  tolerations:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                  {{- with .Values.affinity }}
                  affinity:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              replicas: {{ .Values.replicaCount }}
              selector:
                matchLabels:
                  {{- include "myapp.selectorLabels" . | nindent 6 }}
              template:
                metadata:
                  labels:
                    {{- include "myapp.selectorLabels" . | nindent 8 }}
                spec:
                  containers:
                    - name: {{ .Chart.Name }}
                      image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
                      imagePullPolicy: {{ .Values.image.pullPolicy }}
                      ports:
                        - name: http
                          containerPort: 80
                          protocol: TCP
                      {{- with .Values.resources }}
                      resources:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
                  {{- with .Values.nodeSelector }}
                  nodeSelector:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                  {{- with .Values.tolerations }}
                  tolerations:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                  {{- with .Values.affinity }}
                  affinity:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
          difficulty: 3
        - id: v7
          title: Deployment with ImagePullSecrets and ServiceAccount
          description: >-
            Write a <code>deployment.yaml</code> template that includes <code>imagePullSecrets</code> from values
            and sets <code>serviceAccountName</code> using the <code>myapp.serviceAccountName</code> helper.
          functionSignature: "templates/deployment.yaml"
          testCases:
            - input: "imagePullSecrets: [{name: regcred}], serviceAccount.create: true, serviceAccount.name: my-sa"
              output: "Pod spec with imagePullSecrets and serviceAccountName: my-sa"
            - input: "imagePullSecrets: [], serviceAccount.create: false"
              output: "Pod spec with serviceAccountName: default, no imagePullSecrets"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>imagePullSecrets</code> and <code>serviceAccountName</code> go in the pod spec. The service
                account name should come from your helper template.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>{{- with .Values.imagePullSecrets }}</code> for pull secrets and
                <code>{{ include "myapp.serviceAccountName" . }}</code> for the SA name.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>spec:
                  {{- with .Values.imagePullSecrets }}
                  imagePullSecrets:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                  serviceAccountName: {{ include "myapp.serviceAccountName" . }}
                  containers: [...]</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              replicas: {{ .Values.replicaCount }}
              selector:
                matchLabels:
                  {{- include "myapp.selectorLabels" . | nindent 6 }}
              template:
                metadata:
                  labels:
                    {{- include "myapp.selectorLabels" . | nindent 8 }}
                spec:
                  {{- with .Values.imagePullSecrets }}
                  imagePullSecrets:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                  serviceAccountName: {{ include "myapp.serviceAccountName" . }}
                  containers:
                    - name: {{ .Chart.Name }}
                      image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
                      imagePullPolicy: {{ .Values.image.pullPolicy }}
                      ports:
                        - name: http
                          containerPort: 80
                          protocol: TCP
                      {{- with .Values.resources }}
                      resources:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
          difficulty: 2
        - id: v8
          title: Full Production Deployment Template
          description: >-
            Write a production-ready <code>deployment.yaml</code> template with all common features: autoscaling
            toggle for replicas, imagePullSecrets, serviceAccount, podAnnotations, podSecurityContext,
            securityContext, env vars, probes, resources, volumes, nodeSelector, tolerations, and affinity.
          functionSignature: "templates/deployment.yaml"
          testCases:
            - input: "Full values with autoscaling.enabled: true, podAnnotations, probes, resources, tolerations"
              output: "Complete production deployment manifest"
            - input: "Minimal values: only image and replicaCount"
              output: "Minimal deployment with defaults"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A production template uses <code>with</code> and <code>if</code> blocks for every optional section,
                ensuring clean output when values are not provided.
            - title: "\U0001F4A1 Hint"
              content: >-
                Build it piece by piece: start with the basic structure, then add each optional section using
                <code>{{- with }}</code> or <code>{{- if }}</code> guards.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>Combine all previous patterns:
                1. Conditional replicas (autoscaling toggle)
                2. imagePullSecrets, serviceAccountName
                3. podAnnotations, podSecurityContext
                4. Container: securityContext, image, ports
                5. env, probes, resources
                6. volumeMounts + volumes
                7. nodeSelector, tolerations, affinity</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              {{- if not .Values.autoscaling.enabled }}
              replicas: {{ .Values.replicaCount }}
              {{- end }}
              selector:
                matchLabels:
                  {{- include "myapp.selectorLabels" . | nindent 6 }}
              template:
                metadata:
                  labels:
                    {{- include "myapp.selectorLabels" . | nindent 8 }}
                  {{- with .Values.podAnnotations }}
                  annotations:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                spec:
                  {{- with .Values.imagePullSecrets }}
                  imagePullSecrets:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                  serviceAccountName: {{ include "myapp.serviceAccountName" . }}
                  {{- with .Values.podSecurityContext }}
                  securityContext:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                  containers:
                    - name: {{ .Chart.Name }}
                      {{- with .Values.securityContext }}
                      securityContext:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
                      image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
                      imagePullPolicy: {{ .Values.image.pullPolicy }}
                      ports:
                        - name: http
                          containerPort: 80
                          protocol: TCP
                      {{- if .Values.env }}
                      env:
                        {{- toYaml .Values.env | nindent 12 }}
                      {{- end }}
                      {{- with .Values.livenessProbe }}
                      livenessProbe:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
                      {{- with .Values.readinessProbe }}
                      readinessProbe:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
                      {{- with .Values.resources }}
                      resources:
                        {{- toYaml . | nindent 12 }}
                      {{- end }}
                  {{- with .Values.nodeSelector }}
                  nodeSelector:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                  {{- with .Values.tolerations }}
                  tolerations:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
                  {{- with .Values.affinity }}
                  affinity:
                    {{- toYaml . | nindent 8 }}
                  {{- end }}
          difficulty: 4
    - id: challenge_2
      block: 1
      difficulty: 1
      concept: Service Template
      variants:
        - id: v1
          title: Basic ClusterIP Service
          description: >-
            Write a Helm <code>service.yaml</code> template for a ClusterIP service. Use
            <code>.Values.service.type</code> and <code>.Values.service.port</code>. Selector labels should use the
            <code>myapp.selectorLabels</code> helper.
          functionSignature: "templates/service.yaml"
          testCases:
            - input: "service.type: ClusterIP, service.port: 80"
              output: "ClusterIP Service on port 80 targeting port http"
            - input: "service.type: ClusterIP, service.port: 8080"
              output: "ClusterIP Service on port 8080"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A Service needs apiVersion, kind, metadata, and spec. The spec includes type, ports, and selector.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>include "myapp.selectorLabels"</code> for the selector so it matches the pod labels in
                the Deployment template.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>apiVersion: v1
                kind: Service
                metadata:
                  name: (fullname)
                  labels: (include labels)
                spec:
                  type: (from values)
                  ports:
                    - port: (from values)
                      targetPort: http
                  selector: (selectorLabels)</pre>
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              type: {{ .Values.service.type }}
              ports:
                - port: {{ .Values.service.port }}
                  targetPort: http
                  protocol: TCP
                  name: http
              selector:
                {{- include "myapp.selectorLabels" . | nindent 4 }}
          difficulty: 1
        - id: v2
          title: Service with Conditional NodePort
          description: >-
            Write a <code>service.yaml</code> template where the <code>nodePort</code> field is only rendered when
            the service type is <code>NodePort</code> and <code>.Values.service.nodePort</code> is set.
          functionSignature: "templates/service.yaml"
          testCases:
            - input: "service.type: NodePort, service.port: 80, service.nodePort: 30080"
              output: "NodePort Service with nodePort: 30080"
            - input: "service.type: ClusterIP, service.port: 80"
              output: "ClusterIP Service without nodePort field"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The <code>nodePort</code> field is only valid for NodePort and LoadBalancer service types. Including
                it on a ClusterIP service causes an error.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>{{- if and (eq .Values.service.type "NodePort") .Values.service.nodePort }}</code> to
                guard the nodePort field.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>ports:
                  - port: {{ .Values.service.port }}
                    targetPort: http
                    protocol: TCP
                    name: http
                    {{- if contains "NodePort" .Values.service.type }}
                    nodePort: {{ .Values.service.nodePort }}
                    {{- end }}</pre>
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              type: {{ .Values.service.type }}
              ports:
                - port: {{ .Values.service.port }}
                  targetPort: http
                  protocol: TCP
                  name: http
                  {{- if and (or (eq .Values.service.type "NodePort") (eq .Values.service.type "LoadBalancer")) .Values.service.nodePort }}
                  nodePort: {{ .Values.service.nodePort }}
                  {{- end }}
              selector:
                {{- include "myapp.selectorLabels" . | nindent 4 }}
          difficulty: 2
        - id: v3
          title: Service with Multiple Ports
          description: >-
            Write a <code>service.yaml</code> template that supports multiple ports from
            <code>.Values.service.ports</code> (a list of objects with <code>name</code>, <code>port</code>, and
            <code>targetPort</code>).
          functionSignature: "templates/service.yaml"
          testCases:
            - input: "service.ports: [{name: http, port: 80, targetPort: 8080}, {name: metrics, port: 9090, targetPort: 9090}]"
              output: "Service with two ports: http:80 and metrics:9090"
            - input: "service.ports: [{name: grpc, port: 50051, targetPort: 50051}]"
              output: "Service with single gRPC port"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When service ports are a list in values, you can use <code>range</code> to iterate, or simply use
                <code>toYaml</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>{{- range .Values.service.ports }}</code> to iterate over the port list and render each
                port entry.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>ports:
                  {{- range .Values.service.ports }}
                  - name: {{ .name }}
                    port: {{ .port }}
                    targetPort: {{ .targetPort }}
                    protocol: TCP
                  {{- end }}</pre>
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              type: {{ .Values.service.type | default "ClusterIP" }}
              ports:
                {{- range .Values.service.ports }}
                - name: {{ .name }}
                  port: {{ .port }}
                  targetPort: {{ .targetPort }}
                  protocol: TCP
                {{- end }}
              selector:
                {{- include "myapp.selectorLabels" . | nindent 4 }}
          difficulty: 2
        - id: v4
          title: Service with Annotations
          description: >-
            Write a <code>service.yaml</code> template that conditionally includes annotations from
            <code>.Values.service.annotations</code>. This is common for LoadBalancer services that need
            cloud-provider annotations.
          functionSignature: "templates/service.yaml"
          testCases:
            - input: "service.annotations: {service.beta.kubernetes.io/aws-load-balancer-type: nlb}"
              output: "Service with AWS NLB annotation"
            - input: "service.annotations: {} (empty)"
              output: "Service with no annotations"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Annotations on Services are used to configure cloud load balancers, enable features, etc.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>{{- with .Values.service.annotations }}</code> to conditionally include the annotations
                block.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>metadata:
                  name: ...
                  labels: ...
                  {{- with .Values.service.annotations }}
                  annotations:
                    {{- toYaml . | nindent 4 }}
                  {{- end }}</pre>
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
              {{- with .Values.service.annotations }}
              annotations:
                {{- toYaml . | nindent 4 }}
              {{- end }}
            spec:
              type: {{ .Values.service.type }}
              ports:
                - port: {{ .Values.service.port }}
                  targetPort: http
                  protocol: TCP
                  name: http
              selector:
                {{- include "myapp.selectorLabels" . | nindent 4 }}
          difficulty: 2
        - id: v5
          title: Headless Service
          description: >-
            Write a <code>service.yaml</code> template that creates a headless service (used for StatefulSets) when
            <code>.Values.service.clusterIP</code> is set to <code>"None"</code>.
          functionSignature: "templates/service.yaml"
          testCases:
            - input: "service.type: ClusterIP, service.clusterIP: None, service.port: 5432"
              output: "Headless service (clusterIP: None) on port 5432"
            - input: "service.type: ClusterIP, service.port: 80"
              output: "Regular ClusterIP service (no clusterIP field)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A headless service sets <code>clusterIP: None</code>, which tells Kubernetes not to assign a
                virtual IP. DNS returns individual pod IPs instead.
            - title: "\U0001F4A1 Hint"
              content: >-
                Conditionally include the <code>clusterIP</code> field only when
                <code>.Values.service.clusterIP</code> is defined.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>spec:
                  type: {{ .Values.service.type }}
                  {{- if .Values.service.clusterIP }}
                  clusterIP: {{ .Values.service.clusterIP }}
                  {{- end }}
                  ports: ...</pre>
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              type: {{ .Values.service.type }}
              {{- if .Values.service.clusterIP }}
              clusterIP: {{ .Values.service.clusterIP }}
              {{- end }}
              ports:
                - port: {{ .Values.service.port }}
                  targetPort: http
                  protocol: TCP
                  name: http
              selector:
                {{- include "myapp.selectorLabels" . | nindent 4 }}
          difficulty: 2
        - id: v6
          title: LoadBalancer Service with IP
          description: >-
            Write a <code>service.yaml</code> template for a LoadBalancer service that optionally sets
            <code>loadBalancerIP</code> from <code>.Values.service.loadBalancerIP</code> and
            <code>loadBalancerSourceRanges</code> from <code>.Values.service.loadBalancerSourceRanges</code>.
          functionSignature: "templates/service.yaml"
          testCases:
            - input: "service.type: LoadBalancer, service.loadBalancerIP: 10.0.0.50, service.loadBalancerSourceRanges: [10.0.0.0/8]"
              output: "LoadBalancer with static IP and source range restriction"
            - input: "service.type: LoadBalancer, service.port: 443"
              output: "LoadBalancer with cloud-assigned IP"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                LoadBalancer services can optionally request a specific IP and restrict source ranges for security.
            - title: "\U0001F4A1 Hint"
              content: >-
                Both fields are optional. Use <code>{{- if }}</code> to conditionally include each one.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>spec:
                  type: LoadBalancer
                  {{- if .Values.service.loadBalancerIP }}
                  loadBalancerIP: {{ .Values.service.loadBalancerIP }}
                  {{- end }}
                  {{- if .Values.service.loadBalancerSourceRanges }}
                  loadBalancerSourceRanges:
                    {{- toYaml .Values.service.loadBalancerSourceRanges | nindent 4 }}
                  {{- end }}</pre>
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: {{ include "myapp.fullname" . }}
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
            spec:
              type: {{ .Values.service.type }}
              {{- if .Values.service.loadBalancerIP }}
              loadBalancerIP: {{ .Values.service.loadBalancerIP }}
              {{- end }}
              {{- with .Values.service.loadBalancerSourceRanges }}
              loadBalancerSourceRanges:
                {{- toYaml . | nindent 4 }}
              {{- end }}
              ports:
                - port: {{ .Values.service.port }}
                  targetPort: http
                  protocol: TCP
                  name: http
              selector:
                {{- include "myapp.selectorLabels" . | nindent 4 }}
          difficulty: 3
    - id: challenge_3
      block: 2
      difficulty: 2
      concept: Template Debugging
      variants:
        - id: v1
          title: "Fix: Whitespace Causing Invalid YAML"
          description: >-
            The following template renders with blank lines that break YAML parsing. Fix the whitespace issue.
            <pre>apiVersion: v1
            kind: ConfigMap
            metadata:
              name: {{ include "myapp.fullname" . }}
            data:
              {{ if .Values.config.debug }}
              debug: "true"
              {{ end }}
              app: {{ .Values.app.name }}</pre>
            <strong>Error:</strong> <code>error converting YAML to JSON: yaml: line 6: did not find expected key</code>
          functionSignature: "templates/configmap.yaml (fix whitespace)"
          testCases:
            - input: "config.debug: true, app.name: myapp"
              output: "Valid ConfigMap with debug: \"true\" and app: myapp"
            - input: "config.debug: false, app.name: myapp"
              output: "Valid ConfigMap with only app: myapp (no blank lines)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The <code>{{ if }}</code> and <code>{{ end }}</code> tags produce blank lines when they render to
                nothing. These blank lines can break YAML indentation context.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the dash modifier <code>{{-</code> and <code>-}}</code> to trim whitespace around control
                structures.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>Replace {{ if }} with {{- if }}
                Replace {{ end }} with {{- end }}
                This trims the blank lines produced by control flow tags.</pre>
          solution: |-
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: {{ include "myapp.fullname" . }}
            data:
              {{- if .Values.config.debug }}
              debug: "true"
              {{- end }}
              app: {{ .Values.app.name }}
          difficulty: 2
        - id: v2
          title: "Fix: Nil Pointer on Missing Value"
          description: >-
            The following template crashes when <code>monitoring</code> is not defined in values.yaml. Fix it.
            <pre>metadata:
              annotations:
                prometheus.io/scrape: {{ .Values.monitoring.scrape | quote }}
                prometheus.io/port: {{ .Values.monitoring.port | quote }}</pre>
            <strong>Error:</strong> <code>nil pointer evaluating interface {}.scrape</code>
          functionSignature: "templates/deployment.yaml (fix nil pointer)"
          testCases:
            - input: "monitoring.scrape: true, monitoring.port: 9090"
              output: "Annotations rendered with scrape and port values"
            - input: "monitoring: not defined"
              output: "No crash, annotations section skipped"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When <code>.Values.monitoring</code> is nil, accessing <code>.scrape</code> on nil causes a nil
                pointer error. You need to guard against the parent being undefined.
            - title: "\U0001F4A1 Hint"
              content: >-
                Wrap the block in <code>{{- with .Values.monitoring }}</code> so it only executes when monitoring
                is defined.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>{{- with .Values.monitoring }}
                  annotations:
                    prometheus.io/scrape: {{ .scrape | quote }}
                    prometheus.io/port: {{ .port | quote }}
                {{- end }}</pre>
          solution: |-
            metadata:
              {{- with .Values.monitoring }}
              annotations:
                prometheus.io/scrape: {{ .scrape | quote }}
                prometheus.io/port: {{ .port | quote }}
              {{- end }}
          difficulty: 2
        - id: v3
          title: "Fix: Wrong Indentation with toYaml"
          description: >-
            The following template produces incorrectly indented YAML for resources. Fix the indentation.
            <pre>containers:
              - name: app
                resources:
                  {{ toYaml .Values.resources }}</pre>
            <strong>Error:</strong> Resources block is not indented under the <code>resources:</code> key, causing
            invalid YAML.
          functionSignature: "templates/deployment.yaml (fix indentation)"
          testCases:
            - input: "resources: {requests: {cpu: 100m, memory: 128Mi}}"
              output: "Resources properly indented under the resources: key"
            - input: "resources: {limits: {cpu: 500m, memory: 256Mi}}"
              output: "Limits properly nested"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>toYaml</code> outputs YAML starting at column 0. You need to indent the output to match the
                surrounding structure.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the pipe with <code>nindent N</code> to add a newline and indent. Count the spaces needed from
                the left margin to where the content should start.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>resources:
                  {{- toYaml .Values.resources | nindent 10 }}
                (use nindent with the correct number of spaces)</pre>
          solution: |-
            containers:
              - name: app
                resources:
                  {{- toYaml .Values.resources | nindent 10 }}
          difficulty: 2
        - id: v4
          title: "Fix: Scope Lost Inside range"
          description: >-
            The following template tries to use <code>.Release.Name</code> inside a <code>range</code> loop, but it
            fails. Fix it.
            <pre>{{- range .Values.ingress.hosts }}
            - host: {{ .host }}
              http:
                paths:
                  - path: {{ .path }}
                    backend:
                      service:
                        name: {{ .Release.Name }}-svc
            {{- end }}</pre>
            <strong>Error:</strong> <code>can't evaluate field Release in type interface {}</code>
          functionSignature: "templates/ingress.yaml (fix scope)"
          testCases:
            - input: "Release.Name: myrelease, ingress.hosts: [{host: app.example.com, path: /}]"
              output: "backend service name: myrelease-svc"
            - input: "Release.Name: prod, ingress.hosts: [{host: api.example.com, path: /api}]"
              output: "backend service name: prod-svc"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Inside <code>range</code>, the dot (<code>.</code>) is rebound to the current element. The root
                scope (<code>.Release</code>) is no longer accessible via <code>.</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>$</code> to access the root scope inside range. <code>$</code> always refers to the
                top-level scope.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>Inside range, replace:
                  .Release.Name  ->  $.Release.Name
                $ always refers to the root context.</pre>
          solution: |-
            {{- range .Values.ingress.hosts }}
            - host: {{ .host }}
              http:
                paths:
                  - path: {{ .path }}
                    backend:
                      service:
                        name: {{ $.Release.Name }}-svc
            {{- end }}
          difficulty: 3
        - id: v5
          title: "Fix: Missing quote Around Numeric Value"
          description: >-
            The following template produces invalid YAML because a numeric annotation value is not quoted. Fix it.
            <pre>metadata:
              annotations:
                app.kubernetes.io/version: {{ .Chart.AppVersion }}
                checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}</pre>
            When <code>appVersion</code> is <code>2.0</code>, Helm renders it as <code>2</code> (a number), which is
            invalid for an annotation value.
            <strong>Error:</strong> <code>annotations values must be strings</code>
          functionSignature: "templates/deployment.yaml (fix quoting)"
          testCases:
            - input: "Chart.AppVersion: 2.0"
              output: 'app.kubernetes.io/version: "2.0"'
            - input: "Chart.AppVersion: 1.16.0"
              output: 'app.kubernetes.io/version: "1.16.0"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                YAML treats <code>2.0</code> as a float, not a string. Kubernetes annotation values must be
                strings.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the <code>quote</code> function to ensure the value is wrapped in double quotes in the rendered
                output.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>Add | quote to ensure string output:
                  {{ .Chart.AppVersion | quote }}
                This wraps the value in double quotes.</pre>
          solution: |-
            metadata:
              annotations:
                app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
                checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
          difficulty: 2
        - id: v6
          title: "Fix: if vs with for Empty Map"
          description: >-
            The following template renders an empty <code>nodeSelector: {}</code> when no nodeSelector values are
            provided, which is unnecessary. Fix it to omit the section entirely when empty.
            <pre>spec:
              {{ if .Values.nodeSelector }}
              nodeSelector:
                {{ toYaml .Values.nodeSelector | indent 4 }}
              {{ end }}</pre>
            <strong>Problem:</strong> When <code>nodeSelector</code> is <code>{}</code>, the <code>if</code> still
            evaluates to true for an empty map in some contexts, producing blank lines.
          functionSignature: "templates/deployment.yaml (fix empty map handling)"
          testCases:
            - input: "nodeSelector: {tier: backend}"
              output: "nodeSelector rendered with tier: backend"
            - input: "nodeSelector: {}"
              output: "No nodeSelector section rendered at all"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>with</code> treats an empty map as falsy, while <code>if</code> may still enter the block.
                Also, the whitespace trimming is missing.
            - title: "\U0001F4A1 Hint"
              content: >-
                Replace <code>{{ if }}</code> with <code>{{- with }}</code> and use <code>nindent</code> instead
                of <code>indent</code> for proper formatting.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>{{- with .Values.nodeSelector }}
                nodeSelector:
                  {{- toYaml . | nindent 8 }}
                {{- end }}
                (with skips empty maps; nindent handles whitespace)</pre>
          solution: |-
            spec:
              {{- with .Values.nodeSelector }}
              nodeSelector:
                {{- toYaml . | nindent 8 }}
              {{- end }}
          difficulty: 3
        - id: v7
          title: "Fix: include vs template"
          description: >-
            The following template uses <code>template</code> instead of <code>include</code>, and the output
            is not indented correctly. Fix it.
            <pre>metadata:
              name: my-service
              labels:
                {{ template "myapp.labels" . }}</pre>
            <strong>Problem:</strong> <code>template</code> inserts output inline and cannot be piped to
            <code>nindent</code>. The labels render at column 0 instead of indented under <code>labels:</code>.
          functionSignature: "templates/service.yaml (fix template vs include)"
          testCases:
            - input: "Chart.Name: myapp, Release.Name: prod"
              output: "Labels properly indented 4 spaces under labels:"
            - input: "Chart.Name: api, Release.Name: staging"
              output: "Labels properly indented 4 spaces under labels:"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>template</code> is an action that directly inserts text; it cannot be piped.
                <code>include</code> is a function that returns a string, which can be piped.
            - title: "\U0001F4A1 Hint"
              content: >-
                Replace <code>{{ template "name" . }}</code> with <code>{{- include "name" . | nindent 4 }}</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>Always use include instead of template when you need
                to control indentation:
                  {{- include "myapp.labels" . | nindent 4 }}
                include returns a string that you can pipe.</pre>
          solution: |-
            metadata:
              name: my-service
              labels:
                {{- include "myapp.labels" . | nindent 4 }}
          difficulty: 2
        - id: v8
          title: "Fix: Incorrect default Function Order"
          description: >-
            The following template does not apply the default correctly. When <code>image.tag</code> is empty,
            it still renders an empty string instead of <code>latest</code>. Fix it.
            <pre>image: {{ .Values.image.repository }}:{{ default .Values.image.tag "latest" }}</pre>
            <strong>Problem:</strong> The arguments to <code>default</code> are in the wrong order.
          functionSignature: "templates/deployment.yaml (fix default order)"
          testCases:
            - input: "image.repository: nginx, image.tag: (empty)"
              output: "image: nginx:latest"
            - input: "image.repository: nginx, image.tag: 1.25"
              output: "image: nginx:1.25"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The <code>default</code> function signature is <code>default DEFAULT_VALUE INPUT</code>. The
                default (fallback) value comes first, then the value to test.
            - title: "\U0001F4A1 Hint"
              content: >-
                Swap the arguments: <code>{{ default "latest" .Values.image.tag }}</code>, or use pipe syntax:
                <code>{{ .Values.image.tag | default "latest" }}</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>default takes the fallback FIRST, then the value:
                  {{ default "fallback" .Values.actual }}
                Or use pipe syntax (more readable):
                  {{ .Values.actual | default "fallback" }}</pre>
          solution: |-
            image: {{ .Values.image.repository }}:{{ .Values.image.tag | default "latest" }}
          difficulty: 2
