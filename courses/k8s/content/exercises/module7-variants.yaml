conceptLinks:
  "Path-Based Routing": "#lesson-path-based-routing"
  "Host-Based Routing": "#lesson-host-based-routing"
  "TLS Termination": "#lesson-tls-termination"
  "Ingress Annotations": "#lesson-common-nginx-ingress-annotations"
  "Gateway API": "#lesson-gateway-api-the-future"
  "Traffic Splitting": "#lesson-traffic-splitting-with-gateway-api"
  "pathType": "#lesson-pathtype-explained"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: "Path-Based Routing"
      variants:
        - id: v1
          title: Basic Path Routing
          description: >-
            Write an Ingress resource named <code>web-ingress</code> that routes
            <code>/</code> (Prefix) to the <code>frontend</code> Service on port
            <code>80</code>. Use <code>ingressClassName: nginx</code> and host
            <code>myapp.local</code>.
          hints:
            - "apiVersion is <code>networking.k8s.io/v1</code>, kind is <code>Ingress</code>."
            - "Each path entry needs <code>path</code>, <code>pathType</code>, and <code>backend</code>."
            - "The backend references a <code>service.name</code> and <code>service.port.number</code>."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: web-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: myapp.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: frontend
                        port:
                          number: 80
        - id: v2
          title: Two-Path Routing
          description: >-
            Write an Ingress named <code>app-ingress</code> for host <code>shop.local</code>
            that routes <code>/</code> (Prefix) to <code>storefront</code> on port <code>80</code>
            and <code>/api</code> (Prefix) to <code>shop-api</code> on port <code>8080</code>.
          hints:
            - "Both paths go under the same host rule."
            - "List the more specific path (<code>/api</code>) first for clarity."
            - "Each path needs its own <code>backend</code> block."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: app-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: shop.local
                http:
                  paths:
                  - path: /api
                    pathType: Prefix
                    backend:
                      service:
                        name: shop-api
                        port:
                          number: 8080
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: storefront
                        port:
                          number: 80
        - id: v3
          title: Exact Path Match
          description: >-
            Write an Ingress named <code>exact-ingress</code> for host <code>app.local</code>
            that routes <code>/healthz</code> with <code>pathType: Exact</code> to a
            <code>health-check</code> Service on port <code>8080</code>, and <code>/</code>
            with <code>pathType: Prefix</code> to <code>main-app</code> on port <code>80</code>.
          hints:
            - "<code>Exact</code> matches only the literal path, not sub-paths."
            - "<code>/healthz</code> with Exact will NOT match <code>/healthz/</code>."
            - "Combine Exact and Prefix pathTypes in the same rule."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: exact-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /healthz
                    pathType: Exact
                    backend:
                      service:
                        name: health-check
                        port:
                          number: 8080
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: main-app
                        port:
                          number: 80
        - id: v4
          title: Three-Path API Gateway
          description: >-
            Write an Ingress named <code>api-gateway</code> for host <code>api.local</code>
            with three Prefix paths: <code>/users</code> to <code>users-svc</code> port
            <code>8080</code>, <code>/orders</code> to <code>orders-svc</code> port
            <code>8080</code>, and <code>/products</code> to <code>products-svc</code>
            port <code>8080</code>.
          hints:
            - "All three paths are siblings under the same host rule."
            - "Each path needs its own complete backend block."
            - "All use <code>pathType: Prefix</code> so sub-paths like <code>/users/123</code> also match."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: api-gateway
            spec:
              ingressClassName: nginx
              rules:
              - host: api.local
                http:
                  paths:
                  - path: /users
                    pathType: Prefix
                    backend:
                      service:
                        name: users-svc
                        port:
                          number: 8080
                  - path: /orders
                    pathType: Prefix
                    backend:
                      service:
                        name: orders-svc
                        port:
                          number: 8080
                  - path: /products
                    pathType: Prefix
                    backend:
                      service:
                        name: products-svc
                        port:
                          number: 8080
        - id: v5
          title: Default Backend
          description: >-
            Write an Ingress named <code>fallback-ingress</code> that sets a
            <code>defaultBackend</code> to the <code>default-app</code> Service on port
            <code>80</code>. This catches all traffic that does not match any rule.
          hints:
            - "The <code>defaultBackend</code> goes under <code>spec</code>, not under <code>rules</code>."
            - "It uses the same <code>service.name</code> and <code>service.port.number</code> structure."
            - "You can have a defaultBackend with or without additional rules."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: fallback-ingress
            spec:
              ingressClassName: nginx
              defaultBackend:
                service:
                  name: default-app
                  port:
                    number: 80
        - id: v6
          title: Rewrite-Target Path Routing
          description: >-
            Write an Ingress named <code>rewrite-ingress</code> for host <code>app.local</code>
            that routes <code>/v1/api</code> (Prefix) to the <code>api-v1</code> Service on
            port <code>80</code>. Add the annotation
            <code>nginx.ingress.kubernetes.io/rewrite-target: /</code> so the backend
            receives <code>/</code> instead of <code>/v1/api</code>.
          hints:
            - "Annotations go under <code>metadata.annotations</code>."
            - "The rewrite-target annotation strips the matched prefix before forwarding."
            - "This is essential when backend services expect requests at <code>/</code>."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: rewrite-ingress
              annotations:
                nginx.ingress.kubernetes.io/rewrite-target: /
            spec:
              ingressClassName: nginx
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /v1/api
                    pathType: Prefix
                    backend:
                      service:
                        name: api-v1
                        port:
                          number: 80
        - id: v7
          title: Named Port Backend
          description: >-
            Write an Ingress named <code>named-port-ingress</code> for host
            <code>web.local</code> that routes <code>/</code> (Prefix) to the
            <code>web-app</code> Service using a named port <code>http-web</code>
            instead of a port number.
          hints:
            - "Instead of <code>port.number</code>, use <code>port.name</code>."
            - "The port name must match a named port on the target Service."
            - "Named ports make configuration more readable and resilient to port changes."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: named-port-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: web.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: web-app
                        port:
                          name: http-web
        - id: v8
          title: Path Routing with Default Backend
          description: >-
            Write an Ingress named <code>combo-ingress</code> for host <code>app.local</code>
            that routes <code>/api</code> (Prefix) to <code>api-svc</code> on port
            <code>8080</code>, and uses a <code>defaultBackend</code> pointing to
            <code>catch-all</code> on port <code>80</code> for everything else.
          hints:
            - "Combine <code>defaultBackend</code> at the spec level with <code>rules</code>."
            - "Traffic matching a rule goes to that backend; unmatched traffic goes to defaultBackend."
            - "The defaultBackend acts as a 404 handler or catch-all."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: combo-ingress
            spec:
              ingressClassName: nginx
              defaultBackend:
                service:
                  name: catch-all
                  port:
                    number: 80
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /api
                    pathType: Prefix
                    backend:
                      service:
                        name: api-svc
                        port:
                          number: 8080
        - id: v9
          title: Static Assets Path
          description: >-
            Write an Ingress named <code>static-ingress</code> for host <code>cdn.local</code>
            that routes <code>/static</code> (Prefix) to <code>static-files</code> on port
            <code>80</code> and <code>/media</code> (Prefix) to <code>media-server</code>
            on port <code>9000</code>.
          hints:
            - "Both paths are Prefix so <code>/static/css/main.css</code> will match."
            - "Different services can listen on different ports."
            - "List the paths under the same host rule."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: static-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: cdn.local
                http:
                  paths:
                  - path: /static
                    pathType: Prefix
                    backend:
                      service:
                        name: static-files
                        port:
                          number: 80
                  - path: /media
                    pathType: Prefix
                    backend:
                      service:
                        name: media-server
                        port:
                          number: 9000
        - id: v10
          title: Exact Login Endpoint
          description: >-
            Write an Ingress named <code>auth-ingress</code> for host <code>auth.local</code>
            with two paths: <code>/login</code> (Exact) to <code>auth-svc</code> on port
            <code>443</code>, and <code>/</code> (Prefix) to <code>portal</code> on port
            <code>80</code>.
          hints:
            - "<code>Exact</code> on <code>/login</code> means <code>/login/reset</code> will NOT match."
            - "The catch-all <code>/</code> Prefix handles everything not matched by Exact."
            - "Exact paths should be listed before Prefix paths."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: auth-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: auth.local
                http:
                  paths:
                  - path: /login
                    pathType: Exact
                    backend:
                      service:
                        name: auth-svc
                        port:
                          number: 443
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: portal
                        port:
                          number: 80
        - id: v11
          title: Four-Path Microservices Routing
          description: >-
            Write an Ingress named <code>micro-ingress</code> for host <code>micro.local</code>
            with four Prefix paths: <code>/auth</code> to <code>auth-svc</code> port
            <code>8081</code>, <code>/cart</code> to <code>cart-svc</code> port
            <code>8082</code>, <code>/search</code> to <code>search-svc</code> port
            <code>8083</code>, and <code>/</code> to <code>homepage</code> port <code>80</code>.
          hints:
            - "List specific paths before the catch-all <code>/</code>."
            - "Each microservice can run on a different port."
            - "Prefix matching on <code>/auth</code> also catches <code>/auth/callback</code>."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: micro-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: micro.local
                http:
                  paths:
                  - path: /auth
                    pathType: Prefix
                    backend:
                      service:
                        name: auth-svc
                        port:
                          number: 8081
                  - path: /cart
                    pathType: Prefix
                    backend:
                      service:
                        name: cart-svc
                        port:
                          number: 8082
                  - path: /search
                    pathType: Prefix
                    backend:
                      service:
                        name: search-svc
                        port:
                          number: 8083
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: homepage
                        port:
                          number: 80
    - id: warmup_2
      concept: "Host-Based Routing"
      variants:
        - id: v1
          title: Two-Host Ingress
          description: >-
            Write an Ingress named <code>multi-host</code> that routes
            <code>app.example.com</code> to the <code>app</code> Service on port <code>80</code>
            and <code>api.example.com</code> to the <code>api</code> Service on port <code>80</code>.
            Both use path <code>/</code> with Prefix.
          hints:
            - "Each host gets its own entry in the <code>rules</code> list."
            - "Every host rule contains an <code>http.paths</code> section."
            - "Two rules, two hosts, two backends."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: multi-host
            spec:
              ingressClassName: nginx
              rules:
              - host: app.example.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: app
                        port:
                          number: 80
              - host: api.example.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: api
                        port:
                          number: 80
        - id: v2
          title: Three-Host Ingress
          description: >-
            Write an Ingress named <code>triple-host</code> that routes
            <code>web.mysite.com</code> to <code>web-svc</code> port <code>80</code>,
            <code>api.mysite.com</code> to <code>api-svc</code> port <code>8080</code>, and
            <code>admin.mysite.com</code> to <code>admin-svc</code> port <code>3000</code>.
          hints:
            - "Three separate entries in the <code>rules</code> list."
            - "Each host can route to a service on a different port."
            - "All three domains share the same Ingress Controller."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: triple-host
            spec:
              ingressClassName: nginx
              rules:
              - host: web.mysite.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: web-svc
                        port:
                          number: 80
              - host: api.mysite.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: api-svc
                        port:
                          number: 8080
              - host: admin.mysite.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: admin-svc
                        port:
                          number: 3000
        - id: v3
          title: Host with Multiple Paths
          description: >-
            Write an Ingress named <code>host-paths</code> with two host rules:
            <code>frontend.local</code> routes <code>/</code> to <code>frontend</code> port
            <code>80</code>, and <code>backend.local</code> routes <code>/api</code> to
            <code>api-svc</code> port <code>8080</code> and <code>/admin</code> to
            <code>admin-svc</code> port <code>3000</code>.
          hints:
            - "The second host has two paths in its <code>http.paths</code> list."
            - "Host-based and path-based routing can be combined."
            - "Each host rule can have any number of path entries."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: host-paths
            spec:
              ingressClassName: nginx
              rules:
              - host: frontend.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: frontend
                        port:
                          number: 80
              - host: backend.local
                http:
                  paths:
                  - path: /api
                    pathType: Prefix
                    backend:
                      service:
                        name: api-svc
                        port:
                          number: 8080
                  - path: /admin
                    pathType: Prefix
                    backend:
                      service:
                        name: admin-svc
                        port:
                          number: 3000
        - id: v4
          title: Staging and Production Hosts
          description: >-
            Write an Ingress named <code>env-ingress</code> that routes
            <code>app.prod.example.com</code> to <code>app-prod</code> on port <code>80</code>
            and <code>app.staging.example.com</code> to <code>app-staging</code> on port
            <code>80</code>.
          hints:
            - "Subdomain-based environment separation is a common pattern."
            - "Each environment maps to a different Service (and thus different Pods)."
            - "Both rules use the same port but different Service names."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: env-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: app.prod.example.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: app-prod
                        port:
                          number: 80
              - host: app.staging.example.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: app-staging
                        port:
                          number: 80
        - id: v5
          title: Tenant-Based Hosting
          description: >-
            Write an Ingress named <code>tenant-ingress</code> that routes three tenants:
            <code>acme.saas.local</code> to <code>acme-app</code>,
            <code>globex.saas.local</code> to <code>globex-app</code>, and
            <code>initech.saas.local</code> to <code>initech-app</code>. All on port
            <code>80</code>.
          hints:
            - "Multi-tenant SaaS apps often use subdomain-per-tenant routing."
            - "Three host rules, each pointing to a tenant-specific Service."
            - "All tenants share the same Ingress Controller."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: tenant-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: acme.saas.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: acme-app
                        port:
                          number: 80
              - host: globex.saas.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: globex-app
                        port:
                          number: 80
              - host: initech.saas.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: initech-app
                        port:
                          number: 80
        - id: v6
          title: Wildcard Host Rule
          description: >-
            Write an Ingress named <code>wildcard-ingress</code> with a wildcard host
            <code>*.apps.local</code> that routes all matching subdomains to the
            <code>wildcard-handler</code> Service on port <code>80</code>.
          hints:
            - "Wildcard hosts use <code>*.domain.com</code> syntax."
            - "A wildcard matches one DNS label: <code>foo.apps.local</code> matches but <code>foo.bar.apps.local</code> does not."
            - "Wildcards only work at the first DNS label position."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: wildcard-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: "*.apps.local"
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: wildcard-handler
                        port:
                          number: 80
        - id: v7
          title: Blog and Docs Hosts
          description: >-
            Write an Ingress named <code>content-ingress</code> that routes
            <code>blog.company.com</code> to <code>blog-svc</code> port <code>80</code>
            and <code>docs.company.com</code> to <code>docs-svc</code> port <code>8080</code>.
          hints:
            - "Two host rules, each with a single <code>/</code> Prefix path."
            - "Common pattern for routing different content sites through one LB."
            - "Each Service can run a different application."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: content-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: blog.company.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: blog-svc
                        port:
                          number: 80
              - host: docs.company.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: docs-svc
                        port:
                          number: 8080
        - id: v8
          title: Host with Default Backend
          description: >-
            Write an Ingress named <code>host-default</code> that routes
            <code>main.local</code> to <code>main-app</code> port <code>80</code>
            and sets a <code>defaultBackend</code> to <code>not-found-svc</code> port
            <code>80</code> for unmatched hosts.
          hints:
            - "The <code>defaultBackend</code> handles traffic for hostnames not listed in rules."
            - "Combine <code>defaultBackend</code> under spec with host rules."
            - "Useful for showing a custom 404 page for unknown domains."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: host-default
            spec:
              ingressClassName: nginx
              defaultBackend:
                service:
                  name: not-found-svc
                  port:
                    number: 80
              rules:
              - host: main.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: main-app
                        port:
                          number: 80
        - id: v9
          title: Regional Hosts
          description: >-
            Write an Ingress named <code>region-ingress</code> with three host rules:
            <code>us.app.com</code> to <code>us-backend</code>,
            <code>eu.app.com</code> to <code>eu-backend</code>, and
            <code>ap.app.com</code> to <code>ap-backend</code>. All on port <code>80</code>.
          hints:
            - "Regional routing uses subdomain prefixes for geographic regions."
            - "Each region points to its own backend Service."
            - "Three rules in one Ingress resource."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: region-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: us.app.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: us-backend
                        port:
                          number: 80
              - host: eu.app.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: eu-backend
                        port:
                          number: 80
              - host: ap.app.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: ap-backend
                        port:
                          number: 80
        - id: v10
          title: API Versioned Hosts
          description: >-
            Write an Ingress named <code>api-version-ingress</code> with two host rules:
            <code>v1.api.local</code> to <code>api-v1</code> port <code>8080</code>
            and <code>v2.api.local</code> to <code>api-v2</code> port <code>8080</code>.
          hints:
            - "API versioning via subdomains keeps each version fully isolated."
            - "Each version runs as a separate Service and Deployment."
            - "Two host rules, same port, different Service names."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: api-version-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: v1.api.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: api-v1
                        port:
                          number: 8080
              - host: v2.api.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: api-v2
                        port:
                          number: 8080
    - id: warmup_3
      concept: "TLS Termination"
      variants:
        - id: v1
          title: Basic TLS Ingress
          description: >-
            Write an Ingress named <code>secure-app</code> for host <code>myapp.local</code>
            that terminates TLS using a Secret named <code>myapp-tls</code>. Route
            <code>/</code> (Prefix) to <code>frontend</code> on port <code>80</code>.
          hints:
            - "The <code>tls</code> section is a list under <code>spec</code>."
            - "Each TLS entry has <code>hosts</code> (a list) and <code>secretName</code>."
            - "The Secret must contain <code>tls.crt</code> and <code>tls.key</code> data keys."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: secure-app
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - myapp.local
                secretName: myapp-tls
              rules:
              - host: myapp.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: frontend
                        port:
                          number: 80
        - id: v2
          title: TLS with Two Hosts
          description: >-
            Write an Ingress named <code>multi-tls</code> with TLS for both
            <code>app.example.com</code> and <code>api.example.com</code>. Use a single
            TLS Secret named <code>example-tls</code> covering both hosts. Route each
            host to its respective Service (<code>app</code> and <code>api</code>) on port <code>80</code>.
          hints:
            - "A single TLS entry can list multiple hosts if the cert covers them (SAN cert)."
            - "Both hostnames go in the same <code>hosts</code> list under one <code>tls</code> entry."
            - "The Secret must contain a certificate valid for both hostnames."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: multi-tls
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - app.example.com
                - api.example.com
                secretName: example-tls
              rules:
              - host: app.example.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: app
                        port:
                          number: 80
              - host: api.example.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: api
                        port:
                          number: 80
        - id: v3
          title: Separate TLS Secrets per Host
          description: >-
            Write an Ingress named <code>dual-tls</code> with two separate TLS entries:
            <code>shop.local</code> using Secret <code>shop-tls</code> and
            <code>blog.local</code> using Secret <code>blog-tls</code>. Route each host
            to its Service on port <code>80</code>.
          hints:
            - "Multiple TLS entries allow different certificates per host."
            - "Each <code>tls</code> list entry has its own <code>hosts</code> and <code>secretName</code>."
            - "This is common when hosts have separate certificates."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: dual-tls
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - shop.local
                secretName: shop-tls
              - hosts:
                - blog.local
                secretName: blog-tls
              rules:
              - host: shop.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: shop
                        port:
                          number: 80
              - host: blog.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: blog
                        port:
                          number: 80
        - id: v4
          title: TLS with SSL Redirect
          description: >-
            Write an Ingress named <code>force-https</code> for host <code>secure.local</code>
            with TLS Secret <code>secure-tls</code>. Add the annotation
            <code>nginx.ingress.kubernetes.io/ssl-redirect: "true"</code> to force HTTP to
            HTTPS redirect. Route <code>/</code> to <code>web</code> port <code>80</code>.
          hints:
            - "The <code>ssl-redirect</code> annotation forces all HTTP traffic to HTTPS."
            - "Annotation values are always strings, so <code>\"true\"</code> is quoted."
            - "Combine the TLS section with the annotation for full HTTPS enforcement."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: force-https
              annotations:
                nginx.ingress.kubernetes.io/ssl-redirect: "true"
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - secure.local
                secretName: secure-tls
              rules:
              - host: secure.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: web
                        port:
                          number: 80
        - id: v5
          title: Create TLS Secret Command
          description: >-
            Write the <code>kubectl</code> command to create a TLS Secret named
            <code>app-tls</code> from certificate file <code>tls.crt</code> and key file
            <code>tls.key</code> in the <code>production</code> namespace.
          hints:
            - "Use <code>kubectl create secret tls</code> with <code>--cert</code> and <code>--key</code> flags."
            - "Specify the namespace with <code>-n</code> or <code>--namespace</code>."
            - "The Secret type will automatically be <code>kubernetes.io/tls</code>."
          solution: |-
            kubectl create secret tls app-tls \
              --cert=tls.crt \
              --key=tls.key \
              -n production
        - id: v6
          title: TLS Secret YAML
          description: >-
            Write the YAML for a TLS Secret named <code>mysite-tls</code> in the
            <code>default</code> namespace. Use placeholder base64-encoded values
            <code>LS0tLS1CRUdJTi...</code> for <code>tls.crt</code> and
            <code>LS0tLS1CRUdJTi...</code> for <code>tls.key</code>.
          hints:
            - "The Secret <code>type</code> must be <code>kubernetes.io/tls</code>."
            - "Data keys must be exactly <code>tls.crt</code> and <code>tls.key</code>."
            - "Values in <code>data</code> must be base64-encoded."
          solution: |-
            apiVersion: v1
            kind: Secret
            metadata:
              name: mysite-tls
              namespace: default
            type: kubernetes.io/tls
            data:
              tls.crt: LS0tLS1CRUdJTi...
              tls.key: LS0tLS1CRUdJTi...
        - id: v7
          title: TLS with Path Routing
          description: >-
            Write an Ingress named <code>secure-api</code> for host <code>api.secure.com</code>
            with TLS Secret <code>api-secure-tls</code>. Route <code>/v1</code> (Prefix) to
            <code>api-v1</code> port <code>8080</code> and <code>/v2</code> (Prefix) to
            <code>api-v2</code> port <code>8080</code>.
          hints:
            - "TLS and path-based routing work together."
            - "TLS terminates at the Ingress Controller; backend traffic is plain HTTP."
            - "Multiple paths under a single TLS-protected host."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: secure-api
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - api.secure.com
                secretName: api-secure-tls
              rules:
              - host: api.secure.com
                http:
                  paths:
                  - path: /v1
                    pathType: Prefix
                    backend:
                      service:
                        name: api-v1
                        port:
                          number: 8080
                  - path: /v2
                    pathType: Prefix
                    backend:
                      service:
                        name: api-v2
                        port:
                          number: 8080
        - id: v8
          title: Wildcard TLS Certificate
          description: >-
            Write an Ingress named <code>wildcard-tls</code> with a TLS entry for
            <code>*.example.com</code> using Secret <code>wildcard-example-tls</code>.
            Add one rule for <code>app.example.com</code> routing to <code>app-svc</code>
            port <code>80</code>.
          hints:
            - "Wildcard TLS covers all subdomains of the domain."
            - "The host in <code>tls.hosts</code> can be <code>*.example.com</code>."
            - "Individual rules still specify exact hostnames."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: wildcard-tls
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - "*.example.com"
                secretName: wildcard-example-tls
              rules:
              - host: app.example.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: app-svc
                        port:
                          number: 80
        - id: v9
          title: TLS with Backend Protocol
          description: >-
            Write an Ingress named <code>backend-https</code> for host <code>internal.local</code>
            with TLS Secret <code>internal-tls</code>. Add the annotation
            <code>nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"</code> to use HTTPS
            when connecting to the backend. Route <code>/</code> to <code>secure-backend</code>
            port <code>443</code>.
          hints:
            - "By default, Ingress talks plain HTTP to backends even when TLS terminates at the controller."
            - "The <code>backend-protocol</code> annotation overrides this to use HTTPS to the backend."
            - "Useful when the backend requires end-to-end encryption."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: backend-https
              annotations:
                nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - internal.local
                secretName: internal-tls
              rules:
              - host: internal.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: secure-backend
                        port:
                          number: 443
        - id: v10
          title: TLS Ingress with Cert-Manager Annotation
          description: >-
            Write an Ingress named <code>auto-tls</code> for host <code>app.prod.com</code>
            with TLS Secret <code>app-prod-tls</code>. Add the annotation
            <code>cert-manager.io/cluster-issuer: "letsencrypt-prod"</code> to have
            cert-manager auto-provision the certificate. Route <code>/</code> to
            <code>app</code> port <code>80</code>.
          hints:
            - "cert-manager watches for Ingress resources with its annotation."
            - "It automatically creates and renews the TLS Secret referenced in the <code>tls</code> section."
            - "The <code>cluster-issuer</code> annotation specifies which ClusterIssuer to use."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: auto-tls
              annotations:
                cert-manager.io/cluster-issuer: "letsencrypt-prod"
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - app.prod.com
                secretName: app-prod-tls
              rules:
              - host: app.prod.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: app
                        port:
                          number: 80
    - id: warmup_4
      concept: "Ingress Annotations"
      variants:
        - id: v1
          title: Rewrite Target Annotation
          description: >-
            Write an Ingress named <code>rewrite-demo</code> for host <code>app.local</code>
            with the annotation <code>nginx.ingress.kubernetes.io/rewrite-target: /</code>.
            Route <code>/backend</code> (Prefix) to <code>backend-svc</code> port
            <code>80</code>.
          hints:
            - "Without rewrite, the backend receives <code>/backend/...</code> paths."
            - "With rewrite-target set to <code>/</code>, the backend receives <code>/...</code> instead."
            - "Essential when backends expect requests at the root path."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: rewrite-demo
              annotations:
                nginx.ingress.kubernetes.io/rewrite-target: /
            spec:
              ingressClassName: nginx
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /backend
                    pathType: Prefix
                    backend:
                      service:
                        name: backend-svc
                        port:
                          number: 80
        - id: v2
          title: Rate Limiting Annotation
          description: >-
            Write an Ingress named <code>rate-limited</code> for host <code>api.local</code>
            with annotations for rate limiting: <code>nginx.ingress.kubernetes.io/limit-rps: "10"</code>
            and <code>nginx.ingress.kubernetes.io/limit-burst-multiplier: "5"</code>.
            Route <code>/</code> to <code>api-svc</code> port <code>80</code>.
          hints:
            - "<code>limit-rps</code> sets the maximum requests per second per client IP."
            - "<code>limit-burst-multiplier</code> allows short bursts above the rate limit."
            - "Both annotation values must be strings (quoted numbers)."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: rate-limited
              annotations:
                nginx.ingress.kubernetes.io/limit-rps: "10"
                nginx.ingress.kubernetes.io/limit-burst-multiplier: "5"
            spec:
              ingressClassName: nginx
              rules:
              - host: api.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: api-svc
                        port:
                          number: 80
        - id: v3
          title: CORS Annotations
          description: >-
            Write an Ingress named <code>cors-ingress</code> for host <code>api.local</code>
            with CORS annotations: <code>enable-cors: "true"</code>,
            <code>cors-allow-origin: "https://frontend.local"</code>, and
            <code>cors-allow-methods: "GET, POST, PUT, DELETE"</code>. Route <code>/</code>
            to <code>api</code> port <code>80</code>.
          hints:
            - "All three annotations use the <code>nginx.ingress.kubernetes.io/</code> prefix."
            - "CORS headers are added by the Ingress Controller, not your backend."
            - "Restrict <code>cors-allow-origin</code> to specific domains in production."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: cors-ingress
              annotations:
                nginx.ingress.kubernetes.io/enable-cors: "true"
                nginx.ingress.kubernetes.io/cors-allow-origin: "https://frontend.local"
                nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE"
            spec:
              ingressClassName: nginx
              rules:
              - host: api.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: api
                        port:
                          number: 80
        - id: v4
          title: Proxy Timeout Annotations
          description: >-
            Write an Ingress named <code>long-poll</code> for host <code>ws.local</code>
            with timeout annotations: <code>proxy-read-timeout: "3600"</code> and
            <code>proxy-send-timeout: "3600"</code> (both in seconds). Route <code>/</code>
            to <code>websocket-svc</code> port <code>8080</code>.
          hints:
            - "Default nginx timeouts are 60 seconds, too short for WebSocket connections."
            - "Set both read and send timeouts to keep long-lived connections alive."
            - "Values are in seconds and must be quoted strings."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: long-poll
              annotations:
                nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
                nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
            spec:
              ingressClassName: nginx
              rules:
              - host: ws.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: websocket-svc
                        port:
                          number: 8080
        - id: v5
          title: Body Size Annotation
          description: >-
            Write an Ingress named <code>upload-ingress</code> for host
            <code>upload.local</code> with the annotation
            <code>nginx.ingress.kubernetes.io/proxy-body-size: "100m"</code> to allow
            large file uploads. Route <code>/</code> to <code>upload-svc</code> port
            <code>8080</code>.
          hints:
            - "The default body size limit is 1m (1 megabyte)."
            - "Set <code>proxy-body-size</code> to allow larger request bodies."
            - "Use <code>0</code> to disable the body size check entirely."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: upload-ingress
              annotations:
                nginx.ingress.kubernetes.io/proxy-body-size: "100m"
            spec:
              ingressClassName: nginx
              rules:
              - host: upload.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: upload-svc
                        port:
                          number: 8080
        - id: v6
          title: SSL Redirect Annotation
          description: >-
            Write an Ingress named <code>redirect-ingress</code> for host
            <code>secure.local</code> with the annotation
            <code>nginx.ingress.kubernetes.io/ssl-redirect: "true"</code>. Include a TLS
            section with Secret <code>secure-tls</code>. Route <code>/</code> to
            <code>web</code> port <code>80</code>.
          hints:
            - "<code>ssl-redirect</code> sends a 308 redirect from HTTP to HTTPS."
            - "This only works when TLS is also configured on the Ingress."
            - "Users hitting <code>http://secure.local</code> are redirected to <code>https://secure.local</code>."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: redirect-ingress
              annotations:
                nginx.ingress.kubernetes.io/ssl-redirect: "true"
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - secure.local
                secretName: secure-tls
              rules:
              - host: secure.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: web
                        port:
                          number: 80
        - id: v7
          title: Regex Rewrite Annotation
          description: >-
            Write an Ingress named <code>regex-rewrite</code> for host <code>app.local</code>
            with annotations: <code>nginx.ingress.kubernetes.io/use-regex: "true"</code>
            and <code>nginx.ingress.kubernetes.io/rewrite-target: /$2</code>.
            Route the path <code>/svc(/|$)(.*)</code> (Prefix) to <code>backend</code>
            port <code>80</code>.
          hints:
            - "The <code>use-regex</code> annotation enables regex path matching."
            - "Capture groups in the path can be referenced in <code>rewrite-target</code>."
            - "<code>$2</code> refers to the second capture group <code>(.*)</code>."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: regex-rewrite
              annotations:
                nginx.ingress.kubernetes.io/use-regex: "true"
                nginx.ingress.kubernetes.io/rewrite-target: /$2
            spec:
              ingressClassName: nginx
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /svc(/|$)(.*)
                    pathType: ImplementationSpecific
                    backend:
                      service:
                        name: backend
                        port:
                          number: 80
        - id: v8
          title: Session Affinity Annotation
          description: >-
            Write an Ingress named <code>sticky-ingress</code> for host
            <code>app.local</code> with annotations for cookie-based session affinity:
            <code>nginx.ingress.kubernetes.io/affinity: "cookie"</code> and
            <code>nginx.ingress.kubernetes.io/session-cookie-name: "SERVERID"</code>.
            Route <code>/</code> to <code>web-app</code> port <code>80</code>.
          hints:
            - "Session affinity ensures a client always reaches the same backend Pod."
            - "The controller sets a cookie so subsequent requests go to the same Pod."
            - "Useful for apps that store session state in memory."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: sticky-ingress
              annotations:
                nginx.ingress.kubernetes.io/affinity: "cookie"
                nginx.ingress.kubernetes.io/session-cookie-name: "SERVERID"
            spec:
              ingressClassName: nginx
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: web-app
                        port:
                          number: 80
        - id: v9
          title: Custom Headers Annotation
          description: >-
            Write an Ingress named <code>header-ingress</code> for host <code>app.local</code>
            with the annotation
            <code>nginx.ingress.kubernetes.io/configuration-snippet</code> set to add a
            custom header: <code>more_set_headers "X-Frame-Options: DENY";</code>. Route
            <code>/</code> to <code>web</code> port <code>80</code>.
          hints:
            - "<code>configuration-snippet</code> injects raw nginx config into the location block."
            - "Use it for headers or directives not covered by other annotations."
            - "The value is a raw nginx directive string."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: header-ingress
              annotations:
                nginx.ingress.kubernetes.io/configuration-snippet: |
                  more_set_headers "X-Frame-Options: DENY";
            spec:
              ingressClassName: nginx
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: web
                        port:
                          number: 80
        - id: v10
          title: Multiple Annotations Combined
          description: >-
            Write an Ingress named <code>full-featured</code> for host <code>app.local</code>
            with these annotations: <code>rewrite-target: /</code>,
            <code>ssl-redirect: "true"</code>, <code>proxy-body-size: "50m"</code>, and
            <code>limit-rps: "20"</code>. Include TLS with Secret <code>app-tls</code>.
            Route <code>/app</code> (Prefix) to <code>main-app</code> port <code>80</code>.
          hints:
            - "All annotations use the <code>nginx.ingress.kubernetes.io/</code> prefix."
            - "Annotations are combined as key-value pairs under <code>metadata.annotations</code>."
            - "Combine TLS, routing rules, and annotations in one Ingress."
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: full-featured
              annotations:
                nginx.ingress.kubernetes.io/rewrite-target: /
                nginx.ingress.kubernetes.io/ssl-redirect: "true"
                nginx.ingress.kubernetes.io/proxy-body-size: "50m"
                nginx.ingress.kubernetes.io/limit-rps: "20"
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - app.local
                secretName: app-tls
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /app
                    pathType: Prefix
                    backend:
                      service:
                        name: main-app
                        port:
                          number: 80
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: "Multi-Service Routing"
      variants:
        - id: v1
          title: E-Commerce Platform Routing
          description: >-
            Design an Ingress named <code>ecommerce-ingress</code> for an e-commerce
            platform. Host <code>shop.example.com</code> should route: <code>/</code> to
            <code>storefront</code> port <code>80</code>, <code>/api/products</code> to
            <code>product-api</code> port <code>8080</code>, <code>/api/orders</code> to
            <code>order-api</code> port <code>8080</code>, and <code>/api/users</code> to
            <code>user-api</code> port <code>8080</code>. Add rewrite-target annotation.
          functionSignature: "Ingress"
          testCases:
            - input: "curl http://shop.example.com/"
              output: "Routes to storefront:80"
            - input: "curl http://shop.example.com/api/products/123"
              output: "Routes to product-api:8080"
            - input: "curl http://shop.example.com/api/orders"
              output: "Routes to order-api:8080"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need four path entries under one host rule. More specific paths
                like <code>/api/products</code> should be listed before the catch-all
                <code>/</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                All API paths use Prefix matching. The rewrite-target annotation strips
                the path prefix so backends receive clean paths.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>spec:
                  rules:
                  - host: shop.example.com
                    http:
                      paths:
                      - path: /api/products
                        pathType: Prefix
                        backend: ...
                      - path: /api/orders
                        ...</pre>
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: ecommerce-ingress
              annotations:
                nginx.ingress.kubernetes.io/rewrite-target: /
            spec:
              ingressClassName: nginx
              rules:
              - host: shop.example.com
                http:
                  paths:
                  - path: /api/products
                    pathType: Prefix
                    backend:
                      service:
                        name: product-api
                        port:
                          number: 8080
                  - path: /api/orders
                    pathType: Prefix
                    backend:
                      service:
                        name: order-api
                        port:
                          number: 8080
                  - path: /api/users
                    pathType: Prefix
                    backend:
                      service:
                        name: user-api
                        port:
                          number: 8080
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: storefront
                        port:
                          number: 80
          difficulty: 2
        - id: v2
          title: Multi-Host with TLS
          description: >-
            Design an Ingress named <code>platform-ingress</code> with three hosts, each
            TLS-protected: <code>www.platform.com</code> (Secret <code>www-tls</code>) to
            <code>web-app</code> port <code>80</code>, <code>api.platform.com</code>
            (Secret <code>api-tls</code>) to <code>api-gateway</code> port <code>8080</code>
            with paths <code>/v1</code> and <code>/v2</code> to separate services, and
            <code>admin.platform.com</code> (Secret <code>admin-tls</code>) to
            <code>admin-panel</code> port <code>3000</code>. Add ssl-redirect annotation.
          functionSignature: "Ingress"
          testCases:
            - input: "curl https://www.platform.com/"
              output: "Routes to web-app:80"
            - input: "curl https://api.platform.com/v1/data"
              output: "Routes to api-v1:8080"
            - input: "curl https://admin.platform.com/"
              output: "Routes to admin-panel:3000"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Three TLS entries (one per host with separate Secrets) and three host
                rules. The API host has multiple path entries.
            - title: "\U0001F4A1 Hint"
              content: >-
                Each TLS entry maps a list of hosts to a Secret. The api host has two
                path rules for <code>/v1</code> and <code>/v2</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>spec:
                  tls:
                  - hosts: [www.platform.com]
                    secretName: www-tls
                  - hosts: [api.platform.com]
                    secretName: api-tls
                  - hosts: [admin.platform.com]
                    secretName: admin-tls
                  rules:
                  - host: www.platform.com
                    ...</pre>
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: platform-ingress
              annotations:
                nginx.ingress.kubernetes.io/ssl-redirect: "true"
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - www.platform.com
                secretName: www-tls
              - hosts:
                - api.platform.com
                secretName: api-tls
              - hosts:
                - admin.platform.com
                secretName: admin-tls
              rules:
              - host: www.platform.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: web-app
                        port:
                          number: 80
              - host: api.platform.com
                http:
                  paths:
                  - path: /v1
                    pathType: Prefix
                    backend:
                      service:
                        name: api-v1
                        port:
                          number: 8080
                  - path: /v2
                    pathType: Prefix
                    backend:
                      service:
                        name: api-v2
                        port:
                          number: 8080
              - host: admin.platform.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: admin-panel
                        port:
                          number: 3000
          difficulty: 3
        - id: v3
          title: SaaS Multi-Tenant Routing
          description: >-
            Design an Ingress named <code>saas-ingress</code> for a multi-tenant SaaS.
            Route <code>*.tenants.saas.com</code> to <code>tenant-router</code> port
            <code>80</code>, <code>api.saas.com</code> with paths <code>/v1</code>
            and <code>/v2</code> to separate API services on port <code>8080</code>,
            <code>admin.saas.com</code> to <code>admin-svc</code> port <code>3000</code>.
            Add TLS with a wildcard Secret <code>saas-wildcard-tls</code> for
            <code>*.tenants.saas.com</code> and <code>saas-tls</code> for the other two hosts.
          functionSignature: "Ingress"
          testCases:
            - input: "curl https://acme.tenants.saas.com/"
              output: "Routes to tenant-router:80"
            - input: "curl https://api.saas.com/v1/users"
              output: "Routes to api-v1:8080"
            - input: "curl https://admin.saas.com/"
              output: "Routes to admin-svc:3000"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need wildcard TLS and host matching for tenants, plus specific TLS
                and host rules for api and admin subdomains.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use separate TLS entries: one with wildcard host and one with the
                specific hosts. The wildcard host rule catches all tenant subdomains.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>tls:
                - hosts: ["*.tenants.saas.com"]
                  secretName: saas-wildcard-tls
                - hosts: [api.saas.com, admin.saas.com]
                  secretName: saas-tls
                rules:
                - host: "*.tenants.saas.com"
                  ...</pre>
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: saas-ingress
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - "*.tenants.saas.com"
                secretName: saas-wildcard-tls
              - hosts:
                - api.saas.com
                - admin.saas.com
                secretName: saas-tls
              rules:
              - host: "*.tenants.saas.com"
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: tenant-router
                        port:
                          number: 80
              - host: api.saas.com
                http:
                  paths:
                  - path: /v1
                    pathType: Prefix
                    backend:
                      service:
                        name: api-v1
                        port:
                          number: 8080
                  - path: /v2
                    pathType: Prefix
                    backend:
                      service:
                        name: api-v2
                        port:
                          number: 8080
              - host: admin.saas.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: admin-svc
                        port:
                          number: 3000
          difficulty: 3
        - id: v4
          title: Full-Stack App with Annotations
          description: >-
            Design an Ingress named <code>fullstack-ingress</code> for host
            <code>myapp.com</code> with TLS (Secret <code>myapp-tls</code>). Routes:
            <code>/</code> to <code>frontend</code> port <code>80</code>,
            <code>/api</code> to <code>backend</code> port <code>8080</code>,
            <code>/ws</code> to <code>websocket-svc</code> port <code>9090</code>,
            <code>/uploads</code> to <code>upload-svc</code> port <code>8080</code>.
            Annotations: ssl-redirect true, proxy-body-size 50m, proxy-read-timeout 300,
            rewrite-target /.
          functionSignature: "Ingress"
          testCases:
            - input: "curl https://myapp.com/"
              output: "Routes to frontend:80"
            - input: "curl https://myapp.com/api/data"
              output: "Routes to backend:8080"
            - input: "WebSocket connect to wss://myapp.com/ws"
              output: "Routes to websocket-svc:9090"
            - input: "POST https://myapp.com/uploads (50MB file)"
              output: "Routes to upload-svc:8080 (body size limit 50m)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Combine TLS, multiple annotations, and four path rules. The annotations
                apply to all paths in this Ingress.
            - title: "\U0001F4A1 Hint"
              content: >-
                List specific paths before the catch-all. The proxy-read-timeout helps
                with WebSocket connections. The proxy-body-size allows large uploads.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>metadata:
                  annotations:
                    nginx.ingress.kubernetes.io/ssl-redirect: "true"
                    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
                    nginx.ingress.kubernetes.io/proxy-read-timeout: "300"
                    nginx.ingress.kubernetes.io/rewrite-target: /</pre>
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: fullstack-ingress
              annotations:
                nginx.ingress.kubernetes.io/ssl-redirect: "true"
                nginx.ingress.kubernetes.io/proxy-body-size: "50m"
                nginx.ingress.kubernetes.io/proxy-read-timeout: "300"
                nginx.ingress.kubernetes.io/rewrite-target: /
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - myapp.com
                secretName: myapp-tls
              rules:
              - host: myapp.com
                http:
                  paths:
                  - path: /api
                    pathType: Prefix
                    backend:
                      service:
                        name: backend
                        port:
                          number: 8080
                  - path: /ws
                    pathType: Prefix
                    backend:
                      service:
                        name: websocket-svc
                        port:
                          number: 9090
                  - path: /uploads
                    pathType: Prefix
                    backend:
                      service:
                        name: upload-svc
                        port:
                          number: 8080
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: frontend
                        port:
                          number: 80
          difficulty: 3
        - id: v5
          title: Microservices Gateway with Rate Limiting
          description: >-
            Design an Ingress named <code>gateway-ingress</code> for host
            <code>gateway.prod.com</code> with TLS (Secret <code>gw-tls</code>,
            cert-manager annotation <code>letsencrypt-prod</code>). Five microservice
            paths: <code>/auth</code> to <code>auth-svc</code>, <code>/users</code> to
            <code>users-svc</code>, <code>/products</code> to <code>products-svc</code>,
            <code>/orders</code> to <code>orders-svc</code>, <code>/payments</code> to
            <code>payments-svc</code>, all on port <code>8080</code>. Add rate limiting
            at 50 rps and ssl-redirect.
          functionSignature: "Ingress"
          testCases:
            - input: "curl https://gateway.prod.com/auth/login"
              output: "Routes to auth-svc:8080"
            - input: "curl https://gateway.prod.com/products"
              output: "Routes to products-svc:8080"
            - input: "51st request in 1 second"
              output: "HTTP 429 Too Many Requests"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Five path rules under one host, combined with TLS, cert-manager, rate
                limiting, and SSL redirect annotations.
            - title: "\U0001F4A1 Hint"
              content: >-
                The cert-manager annotation is <code>cert-manager.io/cluster-issuer</code>
                (not the nginx prefix). Rate limiting uses <code>limit-rps</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>annotations:
                  cert-manager.io/cluster-issuer: "letsencrypt-prod"
                  nginx.ingress.kubernetes.io/ssl-redirect: "true"
                  nginx.ingress.kubernetes.io/limit-rps: "50"</pre>
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: gateway-ingress
              annotations:
                cert-manager.io/cluster-issuer: "letsencrypt-prod"
                nginx.ingress.kubernetes.io/ssl-redirect: "true"
                nginx.ingress.kubernetes.io/limit-rps: "50"
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - gateway.prod.com
                secretName: gw-tls
              rules:
              - host: gateway.prod.com
                http:
                  paths:
                  - path: /auth
                    pathType: Prefix
                    backend:
                      service:
                        name: auth-svc
                        port:
                          number: 8080
                  - path: /users
                    pathType: Prefix
                    backend:
                      service:
                        name: users-svc
                        port:
                          number: 8080
                  - path: /products
                    pathType: Prefix
                    backend:
                      service:
                        name: products-svc
                        port:
                          number: 8080
                  - path: /orders
                    pathType: Prefix
                    backend:
                      service:
                        name: orders-svc
                        port:
                          number: 8080
                  - path: /payments
                    pathType: Prefix
                    backend:
                      service:
                        name: payments-svc
                        port:
                          number: 8080
          difficulty: 4
    - id: challenge_2
      block: 2
      difficulty: 2
      concept: "Gateway API"
      variants:
        - id: v1
          title: Basic Gateway and HTTPRoute
          description: >-
            Write a Gateway named <code>main-gateway</code> using gatewayClassName
            <code>nginx</code> with an HTTP listener on port <code>80</code> that allows
            routes from all namespaces. Then write an HTTPRoute named <code>app-route</code>
            referencing this gateway, matching host <code>app.local</code> with a PathPrefix
            <code>/</code> routing to <code>app-svc</code> port <code>80</code>.
          functionSignature: "Gateway + HTTPRoute"
          testCases:
            - input: "curl http://app.local/"
              output: "Routes to app-svc:80 via Gateway"
            - input: "kubectl get gateway main-gateway"
              output: "Shows gateway with HTTP listener on port 80"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Gateway API separates infrastructure (Gateway) from routing (HTTPRoute).
                The Gateway defines listeners; the HTTPRoute defines rules.
            - title: "\U0001F4A1 Hint"
              content: >-
                The Gateway uses <code>gateway.networking.k8s.io/v1</code> apiVersion.
                HTTPRoute references the Gateway via <code>parentRefs</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>kind: Gateway
                spec:
                  gatewayClassName: nginx
                  listeners:
                  - name: http
                    protocol: HTTP
                    port: 80
                ---
                kind: HTTPRoute
                spec:
                  parentRefs:
                  - name: main-gateway</pre>
          solution: |-
            apiVersion: gateway.networking.k8s.io/v1
            kind: Gateway
            metadata:
              name: main-gateway
            spec:
              gatewayClassName: nginx
              listeners:
              - name: http
                protocol: HTTP
                port: 80
                allowedRoutes:
                  namespaces:
                    from: All
            ---
            apiVersion: gateway.networking.k8s.io/v1
            kind: HTTPRoute
            metadata:
              name: app-route
            spec:
              parentRefs:
              - name: main-gateway
              hostnames:
              - "app.local"
              rules:
              - matches:
                - path:
                    type: PathPrefix
                    value: /
                backendRefs:
                - name: app-svc
                  port: 80
          difficulty: 2
        - id: v2
          title: Traffic Splitting (Canary)
          description: >-
            Write an HTTPRoute named <code>canary-route</code> referencing gateway
            <code>main-gateway</code> for host <code>app.local</code>. Split traffic:
            90% to <code>app-v1</code> port <code>80</code> and 10% to
            <code>app-v2</code> port <code>80</code>.
          functionSignature: "HTTPRoute"
          testCases:
            - input: "100 requests to http://app.local/"
              output: "~90 to app-v1, ~10 to app-v2"
            - input: "kubectl get httproute canary-route"
              output: "Shows route with two weighted backends"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Gateway API supports traffic splitting natively via <code>weight</code>
                on backendRefs. No annotations needed.
            - title: "\U0001F4A1 Hint"
              content: >-
                List both backends in the same <code>backendRefs</code> list with
                <code>weight</code> fields that sum to 100.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>rules:
                - backendRefs:
                  - name: app-v1
                    port: 80
                    weight: 90
                  - name: app-v2
                    port: 80
                    weight: 10</pre>
          solution: |-
            apiVersion: gateway.networking.k8s.io/v1
            kind: HTTPRoute
            metadata:
              name: canary-route
            spec:
              parentRefs:
              - name: main-gateway
              hostnames:
              - "app.local"
              rules:
              - backendRefs:
                - name: app-v1
                  port: 80
                  weight: 90
                - name: app-v2
                  port: 80
                  weight: 10
          difficulty: 2
        - id: v3
          title: Multi-Path HTTPRoute
          description: >-
            Write an HTTPRoute named <code>multi-path-route</code> referencing gateway
            <code>main-gateway</code> for host <code>shop.local</code>. Route
            <code>/api</code> (PathPrefix) to <code>api-svc</code> port <code>8080</code>,
            <code>/static</code> (PathPrefix) to <code>static-svc</code> port <code>80</code>,
            and <code>/</code> (PathPrefix) to <code>frontend</code> port <code>80</code>.
          functionSignature: "HTTPRoute"
          testCases:
            - input: "curl http://shop.local/api/users"
              output: "Routes to api-svc:8080"
            - input: "curl http://shop.local/static/logo.png"
              output: "Routes to static-svc:80"
            - input: "curl http://shop.local/"
              output: "Routes to frontend:80"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each path becomes a separate rule in the HTTPRoute. Rules are evaluated
                in order; more specific paths should come first.
            - title: "\U0001F4A1 Hint"
              content: >-
                Each rule has a <code>matches</code> list and a <code>backendRefs</code>
                list. Path type in Gateway API is <code>PathPrefix</code> (not <code>Prefix</code>).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>rules:
                - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                  backendRefs:
                  - name: api-svc
                    port: 8080</pre>
          solution: |-
            apiVersion: gateway.networking.k8s.io/v1
            kind: HTTPRoute
            metadata:
              name: multi-path-route
            spec:
              parentRefs:
              - name: main-gateway
              hostnames:
              - "shop.local"
              rules:
              - matches:
                - path:
                    type: PathPrefix
                    value: /api
                backendRefs:
                - name: api-svc
                  port: 8080
              - matches:
                - path:
                    type: PathPrefix
                    value: /static
                backendRefs:
                - name: static-svc
                  port: 80
              - matches:
                - path:
                    type: PathPrefix
                    value: /
                backendRefs:
                - name: frontend
                  port: 80
          difficulty: 2
        - id: v4
          title: Header-Based Routing
          description: >-
            Write an HTTPRoute named <code>header-route</code> referencing gateway
            <code>main-gateway</code> for host <code>app.local</code>. Route requests
            with header <code>X-Version: v2</code> to <code>app-v2</code> port
            <code>80</code>, and all other requests to <code>app-v1</code> port
            <code>80</code>.
          functionSignature: "HTTPRoute"
          testCases:
            - input: "curl -H 'X-Version: v2' http://app.local/"
              output: "Routes to app-v2:80"
            - input: "curl http://app.local/"
              output: "Routes to app-v1:80"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Gateway API supports header matching natively. More specific matches
                (header + path) are evaluated before less specific ones.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>matches.headers</code> with <code>type: Exact</code> and
                <code>name/value</code> fields. The rule without header match acts as
                the fallback.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>rules:
                - matches:
                  - headers:
                    - type: Exact
                      name: X-Version
                      value: v2
                  backendRefs:
                  - name: app-v2
                    port: 80
                - backendRefs:
                  - name: app-v1
                    port: 80</pre>
          solution: |-
            apiVersion: gateway.networking.k8s.io/v1
            kind: HTTPRoute
            metadata:
              name: header-route
            spec:
              parentRefs:
              - name: main-gateway
              hostnames:
              - "app.local"
              rules:
              - matches:
                - headers:
                  - type: Exact
                    name: X-Version
                    value: v2
                backendRefs:
                - name: app-v2
                  port: 80
              - backendRefs:
                - name: app-v1
                  port: 80
          difficulty: 3
        - id: v5
          title: Gateway with TLS
          description: >-
            Write a Gateway named <code>secure-gateway</code> with two listeners: HTTP on
            port <code>80</code> and HTTPS on port <code>443</code> using TLS mode
            <code>Terminate</code> with certificate Secret <code>gateway-cert</code> in
            namespace <code>default</code>. Allow routes from the <code>Same</code>
            namespace. Then write an HTTPRoute named <code>secure-route</code> for host
            <code>secure.local</code> routing <code>/</code> to <code>web</code> port
            <code>80</code>.
          functionSignature: "Gateway + HTTPRoute"
          testCases:
            - input: "curl https://secure.local/"
              output: "Routes to web:80 via HTTPS listener"
            - input: "curl http://secure.local/"
              output: "Routes to web:80 via HTTP listener"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The Gateway defines TLS in its listener config, not in the route.
                This separates TLS concerns (infra team) from routing (app team).
            - title: "\U0001F4A1 Hint"
              content: >-
                The HTTPS listener needs <code>tls.mode: Terminate</code> and
                <code>tls.certificateRefs</code> pointing to a Secret. Use
                <code>protocol: HTTPS</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>listeners:
                - name: https
                  protocol: HTTPS
                  port: 443
                  tls:
                    mode: Terminate
                    certificateRefs:
                    - kind: Secret
                      name: gateway-cert</pre>
          solution: |-
            apiVersion: gateway.networking.k8s.io/v1
            kind: Gateway
            metadata:
              name: secure-gateway
            spec:
              gatewayClassName: nginx
              listeners:
              - name: http
                protocol: HTTP
                port: 80
                allowedRoutes:
                  namespaces:
                    from: Same
              - name: https
                protocol: HTTPS
                port: 443
                tls:
                  mode: Terminate
                  certificateRefs:
                  - kind: Secret
                    name: gateway-cert
                allowedRoutes:
                  namespaces:
                    from: Same
            ---
            apiVersion: gateway.networking.k8s.io/v1
            kind: HTTPRoute
            metadata:
              name: secure-route
            spec:
              parentRefs:
              - name: secure-gateway
              hostnames:
              - "secure.local"
              rules:
              - matches:
                - path:
                    type: PathPrefix
                    value: /
                backendRefs:
                - name: web
                  port: 80
          difficulty: 3
        - id: v6
          title: Blue-Green with Traffic Splitting
          description: >-
            Write an HTTPRoute named <code>blue-green-route</code> referencing gateway
            <code>main-gateway</code> for host <code>app.prod.com</code>. Implement
            blue-green deployment: route 100% to <code>app-blue</code> port <code>80</code>
            and 0% to <code>app-green</code> port <code>80</code>. (Flip weights to switch.)
          functionSignature: "HTTPRoute"
          testCases:
            - input: "curl http://app.prod.com/ (blue active)"
              output: "100% to app-blue:80"
            - input: "After flipping weights"
              output: "100% to app-green:80"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Blue-green is traffic splitting at 100/0. Keep both backends listed
                so you only need to swap weights to switch.
            - title: "\U0001F4A1 Hint"
              content: >-
                Set <code>weight: 100</code> on the active backend and
                <code>weight: 0</code> on the standby. Update the YAML and re-apply
                to switch.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>backendRefs:
                - name: app-blue
                  port: 80
                  weight: 100   # active
                - name: app-green
                  port: 80
                  weight: 0     # standby</pre>
          solution: |-
            apiVersion: gateway.networking.k8s.io/v1
            kind: HTTPRoute
            metadata:
              name: blue-green-route
            spec:
              parentRefs:
              - name: main-gateway
              hostnames:
              - "app.prod.com"
              rules:
              - backendRefs:
                - name: app-blue
                  port: 80
                  weight: 100
                - name: app-green
                  port: 80
                  weight: 0
          difficulty: 2
        - id: v7
          title: Gateway with Namespace Routing
          description: >-
            Write a Gateway named <code>shared-gateway</code> with an HTTP listener on
            port <code>80</code> allowing routes from namespaces labeled
            <code>gateway-access: "true"</code>. Then write an HTTPRoute named
            <code>team-a-route</code> in namespace <code>team-a</code> for host
            <code>team-a.local</code> routing to <code>team-a-app</code> port <code>80</code>.
          functionSignature: "Gateway + HTTPRoute"
          testCases:
            - input: "HTTPRoute in namespace with label gateway-access=true"
              output: "Route is accepted by the Gateway"
            - input: "HTTPRoute in namespace without the label"
              output: "Route is rejected by the Gateway"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Gateway API's role model lets infra teams control which namespaces can
                attach routes using label selectors on <code>allowedRoutes</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>allowedRoutes.namespaces.from: Selector</code> with a
                <code>matchLabels</code> selector to restrict route attachment.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>allowedRoutes:
                  namespaces:
                    from: Selector
                    selector:
                      matchLabels:
                        gateway-access: "true"</pre>
          solution: |-
            apiVersion: gateway.networking.k8s.io/v1
            kind: Gateway
            metadata:
              name: shared-gateway
            spec:
              gatewayClassName: nginx
              listeners:
              - name: http
                protocol: HTTP
                port: 80
                allowedRoutes:
                  namespaces:
                    from: Selector
                    selector:
                      matchLabels:
                        gateway-access: "true"
            ---
            apiVersion: gateway.networking.k8s.io/v1
            kind: HTTPRoute
            metadata:
              name: team-a-route
              namespace: team-a
            spec:
              parentRefs:
              - name: shared-gateway
                namespace: default
              hostnames:
              - "team-a.local"
              rules:
              - matches:
                - path:
                    type: PathPrefix
                    value: /
                backendRefs:
                - name: team-a-app
                  port: 80
          difficulty: 3
        - id: v8
          title: Canary with Header Match
          description: >-
            Write an HTTPRoute named <code>canary-header-route</code> referencing gateway
            <code>main-gateway</code> for host <code>app.local</code>. Route requests
            with header <code>X-Canary: true</code> to <code>app-canary</code> port
            <code>80</code>. Route all other traffic with 95/5 split between
            <code>app-stable</code> and <code>app-canary</code> on port <code>80</code>.
          functionSignature: "HTTPRoute"
          testCases:
            - input: "curl -H 'X-Canary: true' http://app.local/"
              output: "Always routes to app-canary:80"
            - input: "curl http://app.local/ (no header)"
              output: "95% app-stable, 5% app-canary"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Two rules: one with a header match (100% canary) and one fallback
                with weighted splitting. Header-matched rules take priority.
            - title: "\U0001F4A1 Hint"
              content: >-
                The header match rule routes entirely to canary. The second rule
                (no match criteria) splits traffic between stable and canary.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>rules:
                - matches:
                  - headers:
                    - type: Exact
                      name: X-Canary
                      value: "true"
                  backendRefs:
                  - name: app-canary
                    port: 80
                - backendRefs:
                  - name: app-stable
                    port: 80
                    weight: 95
                  - name: app-canary
                    port: 80
                    weight: 5</pre>
          solution: |-
            apiVersion: gateway.networking.k8s.io/v1
            kind: HTTPRoute
            metadata:
              name: canary-header-route
            spec:
              parentRefs:
              - name: main-gateway
              hostnames:
              - "app.local"
              rules:
              - matches:
                - headers:
                  - type: Exact
                    name: X-Canary
                    value: "true"
                backendRefs:
                - name: app-canary
                  port: 80
              - backendRefs:
                - name: app-stable
                  port: 80
                  weight: 95
                - name: app-canary
                  port: 80
                  weight: 5
          difficulty: 4
    - id: challenge_3
      block: 2
      difficulty: 2
      concept: "Ingress Troubleshooting"
      variants:
        - id: v1
          title: "Diagnose: Ingress Has No ADDRESS"
          description: >-
            You created an Ingress but <code>kubectl get ingress</code> shows no ADDRESS.
            The Ingress YAML below is applied but not working. Identify the problem and
            write the corrected YAML.<br><br>
            <pre>apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: my-ingress
            spec:
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: web
                        port:
                          number: 80</pre>
          functionSignature: "Ingress"
          testCases:
            - input: "kubectl get ingress my-ingress"
              output: "ADDRESS column is empty"
            - input: "After fix, kubectl get ingress"
              output: "ADDRESS shows the controller IP"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The Ingress resource exists but no controller is processing it. What
                tells a controller to handle this Ingress?
            - title: "\U0001F4A1 Hint"
              content: >-
                The Ingress is missing <code>ingressClassName</code>. Without it, the
                controller does not know to process this resource.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>spec:
                  ingressClassName: nginx   # <-- this was missing
                  rules:
                  ...</pre>
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: my-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: web
                        port:
                          number: 80
          difficulty: 2
        - id: v2
          title: "Diagnose: 502 Bad Gateway"
          description: >-
            Your Ingress returns 502 Bad Gateway. The Ingress references a Service named
            <code>api</code> on port <code>8080</code>, but the Service actually exposes
            port <code>80</code> (targetPort <code>8080</code>). Write the corrected
            Ingress backend section.
          functionSignature: "Ingress"
          testCases:
            - input: "curl http://app.local/api"
              output: "502 Bad Gateway"
            - input: "After fix: curl http://app.local/api"
              output: "200 OK (API response)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The Ingress backend port must match the Service's <code>port</code>, not
                the <code>targetPort</code>. The Service translates port to targetPort.
            - title: "\U0001F4A1 Hint"
              content: >-
                If the Service has <code>port: 80, targetPort: 8080</code>, the Ingress
                must reference port <code>80</code>, not <code>8080</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>backend:
                  service:
                    name: api
                    port:
                      number: 80   # match Service port, not targetPort</pre>
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: api-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /api
                    pathType: Prefix
                    backend:
                      service:
                        name: api
                        port:
                          number: 80
          difficulty: 2
        - id: v3
          title: "Diagnose: TLS Not Working"
          description: >-
            HTTPS returns a fake/default certificate instead of your certificate. The
            Ingress below has a TLS section but it does not match the host rule. Identify
            the problem and write the corrected YAML.<br><br>
            <pre>apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: secure-ingress
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - secure.example.com
                secretName: secure-tls
              rules:
              - host: app.example.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: web
                        port:
                          number: 80</pre>
          functionSignature: "Ingress"
          testCases:
            - input: "curl -k https://app.example.com/"
              output: "Shows Kubernetes Ingress Controller Fake Certificate"
            - input: "After fix: curl -k https://app.example.com/"
              output: "Shows certificate from secure-tls Secret"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The TLS hostname and the rule hostname must match. If they differ, the
                controller uses its default (fake) certificate.
            - title: "\U0001F4A1 Hint"
              content: >-
                The TLS section covers <code>secure.example.com</code> but the rule
                uses <code>app.example.com</code>. Change one to match the other.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>tls:
                - hosts:
                  - app.example.com    # must match rule host
                  secretName: secure-tls
                rules:
                - host: app.example.com</pre>
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: secure-ingress
            spec:
              ingressClassName: nginx
              tls:
              - hosts:
                - app.example.com
                secretName: secure-tls
              rules:
              - host: app.example.com
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: web
                        port:
                          number: 80
          difficulty: 2
        - id: v4
          title: "Diagnose: Path Not Matching"
          description: >-
            Requests to <code>/api/users</code> return 404 instead of routing to the API
            service. The Ingress uses <code>pathType: Exact</code> for <code>/api</code>.
            Explain the issue and write the corrected YAML.
          functionSignature: "Ingress"
          testCases:
            - input: "curl http://app.local/api"
              output: "200 OK (matches Exact)"
            - input: "curl http://app.local/api/users"
              output: "404 Not Found (Exact does not match sub-paths)"
            - input: "After fix: curl http://app.local/api/users"
              output: "200 OK (Prefix matches sub-paths)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>pathType: Exact</code> matches only <code>/api</code> literally.
                Sub-paths like <code>/api/users</code> do not match.
            - title: "\U0001F4A1 Hint"
              content: >-
                Change <code>pathType</code> from <code>Exact</code> to
                <code>Prefix</code> to match <code>/api</code> and all its sub-paths.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>- path: /api
                  pathType: Prefix    # was Exact -- Prefix matches sub-paths</pre>
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: api-ingress
            spec:
              ingressClassName: nginx
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /api
                    pathType: Prefix
                    backend:
                      service:
                        name: api
                        port:
                          number: 8080
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: frontend
                        port:
                          number: 80
          difficulty: 2
        - id: v5
          title: "Diagnose: Service Not Found"
          description: >-
            The Ingress controller logs show <code>service "backend-api" not found</code>.
            The Service is named <code>backend</code> in the <code>production</code>
            namespace but the Ingress references <code>backend-api</code>. The Ingress
            is also in the <code>production</code> namespace. Write the corrected
            Ingress.
          functionSignature: "Ingress"
          testCases:
            - input: "kubectl logs ingress-nginx-controller-xxx"
              output: "service \"backend-api\" not found"
            - input: "kubectl get svc -n production"
              output: "backend ClusterIP 10.96.x.x 8080/TCP"
            - input: "After fix: curl http://app.local/api"
              output: "200 OK"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The Ingress backend Service name must exactly match the Service resource
                name. A typo causes the controller to fail routing.
            - title: "\U0001F4A1 Hint"
              content: >-
                Change <code>backend-api</code> to <code>backend</code> in the Ingress
                backend to match the actual Service name.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>backend:
                  service:
                    name: backend    # was backend-api (typo)</pre>
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: api-ingress
              namespace: production
            spec:
              ingressClassName: nginx
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /api
                    pathType: Prefix
                    backend:
                      service:
                        name: backend
                        port:
                          number: 8080
          difficulty: 2
        - id: v6
          title: "Diagnose: Wrong Ingress Class"
          description: >-
            You have both nginx and traefik Ingress Controllers installed. Your Ingress
            uses <code>ingressClassName: traefik</code> but you intended to use the nginx
            controller. Traffic is being handled by Traefik with unexpected behavior.
            Write the corrected Ingress using nginx.
          functionSignature: "Ingress"
          testCases:
            - input: "kubectl get ingressclass"
              output: "nginx, traefik"
            - input: "Ingress with ingressClassName: traefik"
              output: "Handled by Traefik (unexpected annotations ignored)"
            - input: "After fix: ingressClassName: nginx"
              output: "Handled by nginx controller (annotations work)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                nginx-specific annotations like <code>nginx.ingress.kubernetes.io/*</code>
                are ignored by Traefik. The Ingress must target the right controller.
            - title: "\U0001F4A1 Hint"
              content: >-
                Change <code>ingressClassName</code> from <code>traefik</code> to
                <code>nginx</code> so the nginx controller picks up the Ingress.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>spec:
                  ingressClassName: nginx    # was traefik</pre>
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: app-ingress
              annotations:
                nginx.ingress.kubernetes.io/rewrite-target: /
            spec:
              ingressClassName: nginx
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: app
                        port:
                          number: 80
          difficulty: 2
        - id: v7
          title: "Diagnose: Backend Returns Wrong Content"
          description: >-
            Requests to <code>/api/users</code> reach the backend but the app returns 404
            because it receives <code>/api/users</code> instead of <code>/users</code>.
            The backend expects paths relative to <code>/</code>. The Ingress is missing
            the rewrite-target annotation. Write the corrected Ingress.
          functionSignature: "Ingress"
          testCases:
            - input: "curl http://app.local/api/users (no rewrite)"
              output: "Backend receives /api/users, returns 404"
            - input: "After fix: curl http://app.local/api/users"
              output: "Backend receives /users, returns 200"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Without rewrite-target, the full request path is forwarded to the
                backend. If the backend does not handle the prefix, it returns 404.
            - title: "\U0001F4A1 Hint"
              content: >-
                Add <code>nginx.ingress.kubernetes.io/rewrite-target: /$2</code> and use
                a regex capture group in the path, or use the simpler
                <code>rewrite-target: /</code> for basic stripping.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>annotations:
                  nginx.ingress.kubernetes.io/rewrite-target: /
                # This strips the matched prefix from the forwarded path</pre>
          solution: |-
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: api-ingress
              annotations:
                nginx.ingress.kubernetes.io/rewrite-target: /
            spec:
              ingressClassName: nginx
              rules:
              - host: app.local
                http:
                  paths:
                  - path: /api
                    pathType: Prefix
                    backend:
                      service:
                        name: api-backend
                        port:
                          number: 8080
          difficulty: 3
