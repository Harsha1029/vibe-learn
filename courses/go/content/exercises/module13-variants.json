{
  "conceptLinks": {
    "Multiple Files": "#lesson-multiple-files",
    "Packages": "#lesson-packages",
    "Exported/Unexported": "#lesson-exported",
    "internal/ Directory": "#lesson-internal",
    "Project Layout": "#lesson-layout",
    "Circular Imports": "#lesson-circular"
  },
  "sharedContent": {},
  "variants": {
    "warmups": [
      {
        "id": "warmup_1",
        "concept": "Multiple Files",
        "variants": [
          {
            "id": "v1",
            "title": "Split Code Across Files",
            "description": "You have a program with a <code>Config</code> struct and a <code>Process</code> function. Show how to split them into <code>config.go</code> and <code>process.go</code> in the same package. Write the code for both files.",
            "hints": [
              "Both files must have <code>package main</code> at the top.",
              "No imports are needed between files in the same package.",
              "<code>config.go</code> defines the struct, <code>process.go</code> uses it directly."
            ],
            "solution": "// config.go\npackage main\n\ntype Config struct {\n    Name string\n    Port int\n}\n\nfunc LoadConfig() *Config {\n    return &Config{Name: \"app\", Port: 8080}\n}\n\n// process.go\npackage main\n\nimport \"fmt\"\n\nfunc Process(cfg *Config) {\n    fmt.Printf(\"Processing %s on port %d\\n\", cfg.Name, cfg.Port)\n}",
            "annotations": [
              { "type": "idiom", "label": "Same Package", "text": "Files in the same directory with the same <code>package</code> declaration share everything automatically. No imports needed." },
              { "type": "gotcha", "label": "go run .", "text": "Use <code>go run .</code> to compile all files in the directory. <code>go run main.go</code> alone won't include other files." }
            ]
          },
          {
            "id": "v2",
            "title": "When to Split Files",
            "description": "You have a <code>main.go</code> file with 400 lines containing a <code>Server</code> struct, an <code>App</code> struct, and their methods. Describe how you'd split this and write the package declaration for each file.",
            "hints": [
              "Split by type: <code>server.go</code> for Server, <code>app.go</code> for App.",
              "Keep <code>main()</code> in <code>main.go</code> — it's the entry point.",
              "All files use <code>package main</code>."
            ],
            "solution": "// main.go — entry point only\npackage main\n\nfunc main() {\n    app := NewApp()\n    srv := NewServer(app)\n    srv.Start()\n}\n\n// app.go — App type and its methods\npackage main\n\ntype App struct { /* fields */ }\nfunc NewApp() *App { return &App{} }\n\n// server.go — Server type and its methods\npackage main\n\ntype Server struct { app *App }\nfunc NewServer(app *App) *Server { return &Server{app: app} }\nfunc (s *Server) Start() { /* ... */ }",
            "annotations": [
              { "type": "idiom", "label": "One Type Per File", "text": "A common Go convention: one major type and its methods per file, named after the type (<code>server.go</code>, <code>app.go</code>)." },
              { "type": "pattern", "label": "Thin main()", "text": "Keep <code>main()</code> thin — just create objects and wire them together. Business logic belongs in other files." }
            ]
          },
          {
            "id": "v3",
            "title": "Run Multi-File Program",
            "description": "You have <code>main.go</code>, <code>config.go</code>, and <code>helpers.go</code> in the same directory, all with <code>package main</code>. Write the command to compile and run all of them.",
            "hints": [
              "<code>go run .</code> compiles all <code>.go</code> files in the current directory.",
              "Alternatively: <code>go run main.go config.go helpers.go</code>.",
              "<code>go build .</code> to compile into a binary."
            ],
            "solution": "// Run all files in current directory:\n// $ go run .\n\n// Or explicitly list files:\n// $ go run main.go config.go helpers.go\n\n// Build a binary:\n// $ go build -o myapp .\n// $ ./myapp",
            "annotations": [
              { "type": "idiom", "label": "go run .", "text": "The dot <code>.</code> tells Go to compile all Go files in the current directory. This is the standard way to run multi-file programs." },
              { "type": "gotcha", "label": "go run main.go", "text": "Running just <code>go run main.go</code> won't include other files. You'll get \"undefined\" errors for types and functions in other files." }
            ]
          }
        ]
      },
      {
        "id": "warmup_2",
        "concept": "Packages",
        "variants": [
          {
            "id": "v1",
            "title": "Create a Package",
            "description": "Create a <code>utils</code> package in a <code>utils/</code> directory with a function <code>Greet(name string) string</code>. Import and use it from <code>main.go</code>.",
            "hints": [
              "File <code>utils/utils.go</code> with <code>package utils</code>.",
              "Function must be uppercase to be exported: <code>func Greet</code>.",
              "Import with the module path: <code>import \"myproject/utils\"</code>."
            ],
            "solution": "// utils/utils.go\npackage utils\n\nimport \"fmt\"\n\nfunc Greet(name string) string {\n    return fmt.Sprintf(\"Hello, %s!\", name)\n}\n\n// main.go\npackage main\n\nimport (\n    \"fmt\"\n    \"myproject/utils\"\n)\n\nfunc main() {\n    msg := utils.Greet(\"Alice\")\n    fmt.Println(msg)\n}",
            "annotations": [
              { "type": "idiom", "label": "Package = Directory", "text": "In Go, each directory is one package. The package name is declared in the source file, not the directory name (though they usually match)." },
              { "type": "idiom", "label": "Import Path", "text": "The import path is your module name (from <code>go.mod</code>) plus the directory path. Not the file path." }
            ]
          },
          {
            "id": "v2",
            "title": "Package with Multiple Functions",
            "description": "Create a <code>math</code> package with two files: <code>add.go</code> with <code>Add(a, b int) int</code> and <code>multiply.go</code> with <code>Multiply(a, b int) int</code>. Show the directory structure.",
            "hints": [
              "Both files use <code>package math</code>.",
              "Both functions are uppercase (exported).",
              "From main: <code>math.Add(1, 2)</code> and <code>math.Multiply(3, 4)</code>."
            ],
            "solution": "// Directory structure:\n// myproject/\n// ├── go.mod\n// ├── main.go\n// └── math/\n//     ├── add.go\n//     └── multiply.go\n\n// math/add.go\npackage math\n\nfunc Add(a, b int) int {\n    return a + b\n}\n\n// math/multiply.go\npackage math\n\nfunc Multiply(a, b int) int {\n    return a * b\n}\n\n// main.go\npackage main\n\nimport (\n    \"fmt\"\n    \"myproject/math\"\n)\n\nfunc main() {\n    fmt.Println(math.Add(1, 2))\n    fmt.Println(math.Multiply(3, 4))\n}",
            "annotations": [
              { "type": "idiom", "label": "Multi-File Package", "text": "A package can span multiple files. The compiler merges all files in the same directory into one package." }
            ]
          },
          {
            "id": "v3",
            "title": "Nested Packages",
            "description": "Show the import path for a file at <code>internal/database/postgres.go</code> in a module named <code>github.com/you/myapp</code>.",
            "hints": [
              "The import path follows the directory structure from the module root.",
              "Module name + directory: <code>github.com/you/myapp/internal/database</code>.",
              "The package declaration in the file would be <code>package database</code>."
            ],
            "solution": "// internal/database/postgres.go\npackage database\n\ntype DB struct { /* ... */ }\n\nfunc Connect(dsn string) (*DB, error) {\n    // ...\n    return &DB{}, nil\n}\n\n// Import from within the module:\nimport \"github.com/you/myapp/internal/database\"\n\ndb, err := database.Connect(\"postgres://...\")",
            "annotations": [
              { "type": "idiom", "label": "Import = Module + Dir", "text": "Import paths are always the module name from <code>go.mod</code> concatenated with the directory path from the module root." },
              { "type": "gotcha", "label": "Package vs Directory Name", "text": "The package name and directory name don't have to match, but by convention they should. The package declaration in the file is what matters for code references." }
            ]
          }
        ]
      },
      {
        "id": "warmup_3",
        "concept": "Exported/Unexported",
        "variants": [
          {
            "id": "v1",
            "title": "Identify Exported Names",
            "description": "Given a package with <code>Config</code>, <code>loadDefaults</code>, <code>Port</code>, and <code>httpClient</code>, identify which are exported (visible outside the package) and which are unexported.",
            "hints": [
              "Uppercase first letter = exported.",
              "Lowercase first letter = unexported.",
              "This applies to types, functions, variables, and constants."
            ],
            "solution": "package server\n\n// Exported — visible from other packages\ntype Config struct{}     // ✓ Uppercase C\nvar Port = 8080          // ✓ Uppercase P\n\n// Unexported — only visible within this package\nfunc loadDefaults() {}   // ✗ Lowercase l\nvar httpClient = &http.Client{} // ✗ Lowercase h",
            "annotations": [
              { "type": "idiom", "label": "Visibility Rule", "text": "Go's visibility is the simplest of any language: uppercase = public, lowercase = private. No keywords needed." },
              { "type": "gotcha", "label": "Struct Fields Too", "text": "The uppercase/lowercase rule applies to struct fields as well. Lowercase fields won't be visible in JSON encoding or from other packages." }
            ]
          },
          {
            "id": "v2",
            "title": "Exported Struct with Unexported Fields",
            "description": "Create an exported <code>User</code> struct where <code>Name</code> is exported but <code>password</code> is unexported. Write a constructor <code>NewUser</code> that sets both fields.",
            "hints": [
              "Exported type: <code>type User struct</code> (uppercase U).",
              "Unexported field: <code>password string</code> (lowercase p).",
              "The constructor can set unexported fields because it's in the same package."
            ],
            "solution": "package auth\n\ntype User struct {\n    Name     string  // Exported — other packages can read this\n    password string  // Unexported — only this package can access\n}\n\nfunc NewUser(name, password string) *User {\n    return &User{\n        Name:     name,\n        password: password,\n    }\n}\n\nfunc (u *User) CheckPassword(attempt string) bool {\n    return u.password == attempt\n}",
            "annotations": [
              { "type": "pattern", "label": "Encapsulation", "text": "Unexported fields + exported methods is Go's encapsulation pattern. External code can't access <code>password</code> directly but can use <code>CheckPassword()</code>." },
              { "type": "idiom", "label": "Constructor Required", "text": "If a struct has unexported fields, external code can't initialize them. A constructor like <code>NewUser()</code> is the only way to create a complete instance." }
            ]
          },
          {
            "id": "v3",
            "title": "Unexported Interface Implementation",
            "description": "Create an unexported <code>storage</code> interface with a <code>Save(data []byte) error</code> method. Create an exported <code>NewFileStorage</code> function that returns the interface.",
            "hints": [
              "Lowercase interface name: <code>type storage interface</code>.",
              "The implementation struct can also be unexported: <code>type fileStorage struct</code>.",
              "The constructor returns the interface type, hiding the implementation."
            ],
            "solution": "package store\n\n// Unexported interface — implementation detail\ntype storage interface {\n    Save(data []byte) error\n}\n\n// Unexported implementation\ntype fileStorage struct {\n    path string\n}\n\nfunc (f *fileStorage) Save(data []byte) error {\n    return os.WriteFile(f.path, data, 0644)\n}\n\n// Exported constructor — returns the unexported interface\nfunc NewFileStorage(path string) storage {\n    return &fileStorage{path: path}\n}",
            "annotations": [
              { "type": "pattern", "label": "Hidden Implementation", "text": "Returning an unexported interface from an exported constructor hides the implementation completely. Callers only see the interface methods." },
              { "type": "gotcha", "label": "Unexported Return Type", "text": "Go allows exported functions to return unexported types. The caller can use the value but can't name the type in their own code." }
            ]
          }
        ]
      },
      {
        "id": "warmup_4",
        "concept": "internal/ Directory",
        "variants": [
          {
            "id": "v1",
            "title": "internal/ Access Rules",
            "description": "Given a module <code>github.com/you/myapp</code> with an <code>internal/auth</code> package, which of these can import it: <code>main.go</code> (root), <code>cmd/server/main.go</code>, and an external package that depends on your module?",
            "hints": [
              "<code>internal/</code> is accessible to the parent directory tree.",
              "Both <code>main.go</code> and <code>cmd/server/main.go</code> are within the module.",
              "External packages CANNOT import anything under <code>internal/</code>."
            ],
            "solution": "// Directory structure:\n// github.com/you/myapp/\n// ├── main.go                  ✓ Can import internal/auth\n// ├── cmd/server/main.go       ✓ Can import internal/auth\n// └── internal/auth/auth.go    Package being imported\n\n// External module:\n// github.com/other/project/\n// └── main.go                  ✗ CANNOT import internal/auth\n//                              Compiler error: use of internal package not allowed",
            "annotations": [
              { "type": "idiom", "label": "internal/ Convention", "text": "<code>internal/</code> is the only magic directory name in Go. The compiler enforces that only code in the parent tree can import from it." },
              { "type": "pattern", "label": "API Boundary", "text": "Use <code>internal/</code> for implementation details you want to refactor freely. Your public API stays stable while internals can change." }
            ]
          },
          {
            "id": "v2",
            "title": "Move Code to internal/",
            "description": "You have a <code>database</code> package that external users shouldn't depend on. Show the directory structure before and after moving it to <code>internal/</code>, and update the import path.",
            "hints": [
              "Before: <code>database/db.go</code> → import <code>myapp/database</code>.",
              "After: <code>internal/database/db.go</code> → import <code>myapp/internal/database</code>.",
              "The package declaration stays <code>package database</code>."
            ],
            "solution": "// BEFORE:\n// myapp/\n// ├── database/\n// │   └── db.go          package database\n// └── main.go            import \"myapp/database\"\n\n// AFTER:\n// myapp/\n// ├── internal/\n// │   └── database/\n// │       └── db.go      package database (unchanged)\n// └── main.go            import \"myapp/internal/database\"\n\n// The only change in code is the import path:\nimport \"myapp/internal/database\"  // was: \"myapp/database\"",
            "annotations": [
              { "type": "idiom", "label": "Refactoring to internal/", "text": "Moving packages to <code>internal/</code> only changes import paths. The package declaration and code remain the same." }
            ]
          },
          {
            "id": "v3",
            "title": "Nested internal/ Directories",
            "description": "In a module with <code>pkg/server/internal/handler</code>, who can import the <code>handler</code> package? Can <code>pkg/server/server.go</code>? Can <code>main.go</code> at the root?",
            "hints": [
              "<code>internal/</code> restricts access to its parent directory tree.",
              "The parent of <code>pkg/server/internal/</code> is <code>pkg/server/</code>.",
              "Code above <code>pkg/server/</code> cannot access it."
            ],
            "solution": "// Directory structure:\n// myapp/\n// ├── main.go                          ✗ Cannot import handler\n// ├── pkg/\n// │   ├── client/client.go             ✗ Cannot import handler\n// │   └── server/\n// │       ├── server.go                ✓ CAN import handler\n// │       └── internal/\n// │           └── handler/handler.go   The restricted package\n\n// pkg/server/server.go:\nimport \"myapp/pkg/server/internal/handler\"  // ✓ Works\n\n// main.go:\nimport \"myapp/pkg/server/internal/handler\"  // ✗ Compiler error",
            "annotations": [
              { "type": "idiom", "label": "Scoped internal/", "text": "<code>internal/</code> scopes to its parent. You can have multiple <code>internal/</code> directories at different levels, each with different access scopes." }
            ]
          }
        ]
      }
    ],
    "challenges": [
      {
        "id": "challenge_1",
        "concept": "Project Layout",
        "variants": [
          {
            "id": "v1",
            "title": "Design CLI Tool Layout",
            "description": "Design the directory structure for a CLI tool called <code>taskctl</code> that has: a main entry point, command handlers (list, add, delete), a config loader, and a task storage layer. Show the files and their package declarations.",
            "hints": [
              "Use <code>cmd/</code> for command definitions or keep it flat for small CLIs.",
              "Put storage in <code>internal/</code> to hide the implementation.",
              "Config can be in the main package for simple tools."
            ],
            "solution": "// taskctl/\n// ├── go.mod              module github.com/you/taskctl\n// ├── main.go             package main — entry point, wires everything\n// ├── commands.go         package main — list, add, delete handlers\n// ├── config.go           package main — config loading\n// └── internal/\n//     └── store/\n//         └── store.go    package store — task persistence\n\n// main.go\npackage main\n\nfunc main() {\n    cfg := LoadConfig()\n    store := store.New(cfg.DBPath)\n    runCLI(store)\n}\n\n// internal/store/store.go\npackage store\n\ntype Store struct { path string }\nfunc New(path string) *Store { return &Store{path: path} }\nfunc (s *Store) List() ([]Task, error) { /* ... */ }",
            "annotations": [
              { "type": "pattern", "label": "Flat Main Package", "text": "Small CLI tools can keep everything in <code>package main</code> with multiple files. Only extract packages when complexity grows." },
              { "type": "idiom", "label": "internal/ for Storage", "text": "Storage implementations are internal details. Users of your tool don't need to import your database layer." }
            ]
          },
          {
            "id": "v2",
            "title": "Design Library Layout",
            "description": "Design the directory structure for a reusable Go library called <code>httputil</code> that provides: public middleware functions, a public client wrapper, and internal rate limiting logic.",
            "hints": [
              "The root package is the public API: <code>package httputil</code>.",
              "Rate limiting goes in <code>internal/</code>.",
              "Middleware and client can be in the root or separate public packages."
            ],
            "solution": "// httputil/\n// ├── go.mod             module github.com/you/httputil\n// ├── client.go          package httputil — public client wrapper\n// ├── middleware.go       package httputil — public middleware\n// └── internal/\n//     └── ratelimit/\n//         └── limiter.go  package ratelimit — hidden implementation\n\n// client.go\npackage httputil\n\nimport \"github.com/you/httputil/internal/ratelimit\"\n\ntype Client struct {\n    limiter *ratelimit.Limiter\n}\n\n// middleware.go\npackage httputil\n\nfunc LoggingMiddleware(next http.Handler) http.Handler { /* ... */ }\nfunc AuthMiddleware(next http.Handler) http.Handler { /* ... */ }",
            "annotations": [
              { "type": "pattern", "label": "Library Root = API", "text": "For libraries, the root package IS the public API. Users import just <code>httputil</code> and access all public functions." },
              { "type": "idiom", "label": "Hide Complexity", "text": "Internal packages keep implementation details private. The rate limiter can change freely without breaking library users." }
            ]
          },
          {
            "id": "v3",
            "title": "Resolve Circular Import",
            "description": "Package <code>user</code> imports <code>order</code> to get user's orders, and package <code>order</code> imports <code>user</code> to get order's owner. This causes a circular import. Design a solution.",
            "hints": [
              "Option 1: Extract shared types into a third package (e.g., <code>models</code>).",
              "Option 2: Use an interface to break the dependency.",
              "Option 3: Merge the packages if they're tightly coupled."
            ],
            "solution": "// PROBLEM: user ↔ order circular import\n\n// SOLUTION: Extract shared types into a models package\n\n// models/models.go\npackage models\n\ntype User struct {\n    ID   int\n    Name string\n}\n\ntype Order struct {\n    ID     int\n    UserID int\n    Amount float64\n}\n\n// user/user.go\npackage user\n\nimport \"myapp/models\"\n\nfunc GetUser(id int) *models.User { /* ... */ }\n\n// order/order.go\npackage order\n\nimport \"myapp/models\"\n\nfunc GetOrders(userID int) []models.Order { /* ... */ }\n\n// No circular import — both packages import models, not each other",
            "annotations": [
              { "type": "pattern", "label": "Third Package", "text": "The most common fix for circular imports: extract shared types into a neutral <code>models</code> or <code>types</code> package that both can import." },
              { "type": "pattern", "label": "Interface Solution", "text": "Alternatively, define an interface in one package and have the other implement it. This breaks the compile-time dependency." }
            ]
          }
        ]
      }
    ]
  }
}
