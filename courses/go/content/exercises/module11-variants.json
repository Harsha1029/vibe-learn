{
  "conceptLinks": {
    "HTTP GET": "#lesson-http-get",
    "JSON Decoding": "#lesson-json-decode",
    "Custom Requests": "#lesson-custom-request",
    "API Client": "#lesson-api-client",
    "HTTP Server": "#lesson-http-server",
    "Middleware": "#lesson-middleware"
  },
  "sharedContent": {},
  "variants": {
    "warmups": [
      {
        "id": "warmup_1",
        "concept": "HTTP GET",
        "variants": [
          {
            "id": "v1",
            "title": "Simple GET Request",
            "description": "Make an HTTP GET request to <code>\"https://api.example.com/health\"</code>. Print the status code and read the response body as a string.",
            "hints": [
              "Use <code>http.Get(url)</code> — returns <code>(*http.Response, error)</code>.",
              "Always <code>defer resp.Body.Close()</code>.",
              "Read body with <code>io.ReadAll(resp.Body)</code>."
            ],
            "solution": "resp, err := http.Get(\"https://api.example.com/health\")\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\ndefer resp.Body.Close()\n\nbody, _ := io.ReadAll(resp.Body)\nfmt.Println(\"Status:\", resp.StatusCode)\nfmt.Println(\"Body:\", string(body))",
            "annotations": [
              { "type": "idiom", "label": "Defer Close", "text": "Always <code>defer resp.Body.Close()</code> immediately after checking the error. Forgetting this leaks connections." },
              { "type": "gotcha", "label": "Body Close", "text": "The response body must be closed even if you don't read it. An unclosed body prevents connection reuse." }
            ]
          },
          {
            "id": "v2",
            "title": "GET with Status Check",
            "description": "Make a GET request and check if the status code is <code>200 OK</code>. If not, print an error with the status. If it is, print the body.",
            "hints": [
              "Compare <code>resp.StatusCode != http.StatusOK</code>.",
              "<code>resp.Status</code> gives you a human-readable status like <code>\"200 OK\"</code>.",
              "Read body only if the status is OK."
            ],
            "solution": "resp, err := http.Get(\"https://api.example.com/data\")\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\ndefer resp.Body.Close()\n\nif resp.StatusCode != http.StatusOK {\n    fmt.Printf(\"API error: %s\\n\", resp.Status)\n    return\n}\n\nbody, _ := io.ReadAll(resp.Body)\nfmt.Println(string(body))",
            "annotations": [
              { "type": "idiom", "label": "Status Constants", "text": "Use <code>http.StatusOK</code>, <code>http.StatusNotFound</code>, etc. instead of raw numbers. They're self-documenting." },
              { "type": "gotcha", "label": "Error vs Bad Status", "text": "<code>http.Get</code> only returns an error for network failures. A 404 or 500 response is NOT an error — you must check <code>resp.StatusCode</code>." }
            ]
          },
          {
            "id": "v3",
            "title": "GET with Timeout",
            "description": "Create an <code>http.Client</code> with a 10-second timeout. Use it to make a GET request instead of the default client.",
            "hints": [
              "Create: <code>&http.Client{Timeout: 10 * time.Second}</code>.",
              "Use <code>client.Get(url)</code> instead of <code>http.Get(url)</code>.",
              "Import <code>time</code> for <code>time.Second</code>."
            ],
            "solution": "client := &http.Client{Timeout: 10 * time.Second}\n\nresp, err := client.Get(\"https://api.example.com/data\")\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\ndefer resp.Body.Close()\n\nbody, _ := io.ReadAll(resp.Body)\nfmt.Println(string(body))",
            "annotations": [
              { "type": "idiom", "label": "Custom Client", "text": "Always use a custom <code>http.Client</code> with a timeout in production. The default client has no timeout and can hang forever." },
              { "type": "gotcha", "label": "Default Client", "text": "<code>http.Get()</code> uses the default client with zero timeout. A slow server will block your goroutine indefinitely." }
            ]
          }
        ]
      },
      {
        "id": "warmup_2",
        "concept": "JSON Decoding",
        "variants": [
          {
            "id": "v1",
            "title": "Decode JSON Response",
            "description": "Define a <code>User</code> struct with <code>Login</code>, <code>Name</code>, and <code>Followers int</code> fields (with JSON tags). Decode an HTTP response body into it.",
            "hints": [
              "JSON tags: <code>`json:\"login\"`</code>.",
              "Use <code>json.NewDecoder(resp.Body).Decode(&user)</code>.",
              "This streams the JSON — no need to read the whole body first."
            ],
            "solution": "type User struct {\n    Login     string `json:\"login\"`\n    Name      string `json:\"name\"`\n    Followers int    `json:\"followers\"`\n}\n\n// After making the HTTP request:\nvar user User\nif err := json.NewDecoder(resp.Body).Decode(&user); err != nil {\n    fmt.Println(\"Decode error:\", err)\n    return\n}\nfmt.Printf(\"%s (%s) - %d followers\\n\", user.Name, user.Login, user.Followers)",
            "annotations": [
              { "type": "idiom", "label": "Stream Decode", "text": "<code>json.NewDecoder</code> reads from an <code>io.Reader</code> directly — no need to buffer the whole body with <code>io.ReadAll</code> first." },
              { "type": "idiom", "label": "JSON Tags", "text": "JSON tags map Go's uppercase field names to the API's lowercase/snake_case keys. Without tags, Go uses the field name as-is." }
            ]
          },
          {
            "id": "v2",
            "title": "Decode JSON Array",
            "description": "Define a <code>Repo</code> struct with <code>Name string</code> and <code>Stars int</code> (JSON key: <code>stargazers_count</code>). Decode an array of repos from a response body.",
            "hints": [
              "Decode into a slice: <code>var repos []Repo</code>.",
              "The JSON tag for stars is <code>`json:\"stargazers_count\"`</code>.",
              "Iterate and print each repo's name and star count."
            ],
            "solution": "type Repo struct {\n    Name  string `json:\"name\"`\n    Stars int    `json:\"stargazers_count\"`\n}\n\nvar repos []Repo\nif err := json.NewDecoder(resp.Body).Decode(&repos); err != nil {\n    fmt.Println(\"Decode error:\", err)\n    return\n}\n\nfor _, repo := range repos {\n    fmt.Printf(\"%s (%d stars)\\n\", repo.Name, repo.Stars)\n}",
            "annotations": [
              { "type": "idiom", "label": "Decode into Slice", "text": "If the JSON response is an array, decode into a Go slice. The decoder handles the <code>[...]</code> wrapping automatically." },
              { "type": "idiom", "label": "Field Mapping", "text": "JSON tags let you map any JSON key to any Go field name. <code>stargazers_count</code> → <code>Stars</code> keeps your Go code idiomatic." }
            ]
          },
          {
            "id": "v3",
            "title": "Handle JSON Error Response",
            "description": "When an API returns an error status, the body often contains JSON like <code>{\"error\": \"not found\", \"code\": 404}</code>. Decode this into an <code>APIError</code> struct when the status is not 200.",
            "hints": [
              "Define <code>APIError</code> with <code>Error string</code> and <code>Code int</code> fields.",
              "Check status first. If not OK, decode into <code>APIError</code> instead.",
              "Return the structured error for the caller to handle."
            ],
            "solution": "type APIError struct {\n    Error string `json:\"error\"`\n    Code  int    `json:\"code\"`\n}\n\nif resp.StatusCode != http.StatusOK {\n    var apiErr APIError\n    json.NewDecoder(resp.Body).Decode(&apiErr)\n    fmt.Printf(\"API error %d: %s\\n\", apiErr.Code, apiErr.Error)\n    return\n}",
            "annotations": [
              { "type": "pattern", "label": "Error Response Parsing", "text": "Many APIs return structured JSON errors. Parsing them gives callers actionable information instead of a generic status code." }
            ]
          }
        ]
      },
      {
        "id": "warmup_3",
        "concept": "Custom Requests",
        "variants": [
          {
            "id": "v1",
            "title": "GET with Authorization Header",
            "description": "Create a custom HTTP request with an <code>Authorization: Bearer &lt;token&gt;</code> header. Execute it with a custom client.",
            "hints": [
              "Use <code>http.NewRequest(\"GET\", url, nil)</code>.",
              "Set header: <code>req.Header.Set(\"Authorization\", \"Bearer \"+token)</code>.",
              "Execute: <code>client.Do(req)</code>."
            ],
            "solution": "req, err := http.NewRequest(\"GET\", \"https://api.example.com/user\", nil)\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\nreq.Header.Set(\"Authorization\", \"Bearer \"+token)\nreq.Header.Set(\"Accept\", \"application/json\")\n\nclient := &http.Client{Timeout: 10 * time.Second}\nresp, err := client.Do(req)\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\ndefer resp.Body.Close()",
            "annotations": [
              { "type": "idiom", "label": "NewRequest", "text": "<code>http.NewRequest</code> gives you a request object you can customize (headers, body, context) before sending." },
              { "type": "idiom", "label": "Bearer Token", "text": "The <code>Authorization: Bearer &lt;token&gt;</code> header is the standard way to authenticate API requests." }
            ]
          },
          {
            "id": "v2",
            "title": "POST with JSON Body",
            "description": "Create a POST request with a JSON body. Marshal a struct to JSON, wrap it in a <code>bytes.NewReader</code>, and set the <code>Content-Type</code> header.",
            "hints": [
              "Marshal: <code>data, _ := json.Marshal(payload)</code>.",
              "Body: <code>bytes.NewReader(data)</code>.",
              "Set header: <code>req.Header.Set(\"Content-Type\", \"application/json\")</code>."
            ],
            "solution": "type CreateRepoRequest struct {\n    Name        string `json:\"name\"`\n    Description string `json:\"description\"`\n    Private     bool   `json:\"private\"`\n}\n\npayload := CreateRepoRequest{\n    Name:        \"my-repo\",\n    Description: \"A new repo\",\n    Private:     false,\n}\n\ndata, _ := json.Marshal(payload)\nreq, _ := http.NewRequest(\"POST\", \"https://api.example.com/repos\", bytes.NewReader(data))\nreq.Header.Set(\"Content-Type\", \"application/json\")\nreq.Header.Set(\"Authorization\", \"Bearer \"+token)\n\nclient := &http.Client{Timeout: 10 * time.Second}\nresp, err := client.Do(req)\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\ndefer resp.Body.Close()",
            "annotations": [
              { "type": "idiom", "label": "JSON Body", "text": "For POST/PUT requests: marshal to JSON, wrap in <code>bytes.NewReader</code>, and set <code>Content-Type: application/json</code>." },
              { "type": "gotcha", "label": "Content-Type Required", "text": "Without <code>Content-Type: application/json</code>, many APIs will reject the request or misinterpret the body." }
            ]
          },
          {
            "id": "v3",
            "title": "DELETE Request",
            "description": "Create and send an HTTP DELETE request to <code>/api/items/42</code>. Check that the response status is <code>204 No Content</code>.",
            "hints": [
              "Use <code>http.NewRequest(\"DELETE\", url, nil)</code> — no body needed.",
              "Check <code>resp.StatusCode == http.StatusNoContent</code>.",
              "<code>204 No Content</code> means the delete was successful with no response body."
            ],
            "solution": "req, _ := http.NewRequest(\"DELETE\", \"https://api.example.com/items/42\", nil)\nreq.Header.Set(\"Authorization\", \"Bearer \"+token)\n\nclient := &http.Client{Timeout: 10 * time.Second}\nresp, err := client.Do(req)\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\ndefer resp.Body.Close()\n\nif resp.StatusCode == http.StatusNoContent {\n    fmt.Println(\"Deleted successfully\")\n} else {\n    fmt.Printf(\"Unexpected status: %s\\n\", resp.Status)\n}",
            "annotations": [
              { "type": "idiom", "label": "DELETE Pattern", "text": "DELETE requests typically have no body and return 204 (No Content) on success." }
            ]
          }
        ]
      },
      {
        "id": "warmup_4",
        "concept": "HTTP Server",
        "variants": [
          {
            "id": "v1",
            "title": "Health Check Endpoint",
            "description": "Register an HTTP handler at <code>/health</code> that returns <code>200 OK</code> with body <code>\"OK\"</code>.",
            "hints": [
              "Use <code>http.HandleFunc(\"/health\", handler)</code>.",
              "The handler signature is <code>func(w http.ResponseWriter, r *http.Request)</code>.",
              "Write response: <code>w.Write([]byte(\"OK\"))</code>."
            ],
            "solution": "http.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n    w.WriteHeader(http.StatusOK)\n    w.Write([]byte(\"OK\"))\n})\n\nfmt.Println(\"Listening on :8080\")\nhttp.ListenAndServe(\":8080\", nil)",
            "annotations": [
              { "type": "idiom", "label": "Health Endpoint", "text": "A <code>/health</code> endpoint is standard in production services. Load balancers and monitoring tools use it to check if the service is running." },
              { "type": "gotcha", "label": "WriteHeader Order", "text": "Call <code>w.WriteHeader()</code> before <code>w.Write()</code>. Writing the body implicitly sends a 200 status if you haven't set one yet." }
            ]
          },
          {
            "id": "v2",
            "title": "JSON API Endpoint",
            "description": "Create an endpoint at <code>/api/greet</code> that reads a <code>name</code> query parameter and returns JSON like <code>{\"message\": \"Hello, Alice\"}</code>.",
            "hints": [
              "Read query param: <code>r.URL.Query().Get(\"name\")</code>.",
              "Set content type: <code>w.Header().Set(\"Content-Type\", \"application/json\")</code>.",
              "Encode response: <code>json.NewEncoder(w).Encode(resp)</code>."
            ],
            "solution": "type Response struct {\n    Message string `json:\"message\"`\n}\n\nhttp.HandleFunc(\"/api/greet\", func(w http.ResponseWriter, r *http.Request) {\n    name := r.URL.Query().Get(\"name\")\n    if name == \"\" {\n        name = \"World\"\n    }\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(Response{Message: \"Hello, \" + name})\n})",
            "annotations": [
              { "type": "idiom", "label": "Stream Encode", "text": "<code>json.NewEncoder(w).Encode()</code> writes JSON directly to the ResponseWriter — no intermediate buffer needed." },
              { "type": "idiom", "label": "Content-Type", "text": "Always set <code>Content-Type: application/json</code> for JSON responses. Clients rely on this header to parse the response correctly." }
            ]
          },
          {
            "id": "v3",
            "title": "Method-Aware Handler",
            "description": "Create a handler at <code>/api/items</code> that returns items for GET requests and returns <code>405 Method Not Allowed</code> for anything else.",
            "hints": [
              "Check <code>r.Method</code> against <code>http.MethodGet</code>.",
              "Use <code>http.Error(w, message, http.StatusMethodNotAllowed)</code> for 405.",
              "Go's <code>http.HandleFunc</code> matches all methods — you must filter in the handler."
            ],
            "solution": "http.HandleFunc(\"/api/items\", func(w http.ResponseWriter, r *http.Request) {\n    if r.Method != http.MethodGet {\n        http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n        return\n    }\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode([]string{\"item1\", \"item2\", \"item3\"})\n})",
            "annotations": [
              { "type": "gotcha", "label": "No Method Routing", "text": "The standard library's <code>HandleFunc</code> matches ALL HTTP methods. You must check <code>r.Method</code> yourself." },
              { "type": "idiom", "label": "http.Error", "text": "<code>http.Error(w, msg, code)</code> sets the status code and writes a plain text error body. It also sets Content-Type to text/plain." }
            ]
          }
        ]
      }
    ],
    "challenges": [
      {
        "id": "challenge_1",
        "concept": "API Client",
        "variants": [
          {
            "id": "v1",
            "title": "Reusable API Client Struct",
            "description": "Build a reusable API client struct with <code>baseURL</code>, <code>token</code>, and <code>httpClient</code> fields. Write a <code>NewClient</code> constructor and a private <code>request</code> method that adds auth headers to every request.",
            "hints": [
              "Store <code>*http.Client</code> in the struct with a timeout.",
              "The <code>request</code> method should create a <code>http.NewRequest</code>, set headers, and call <code>c.httpClient.Do(req)</code>.",
              "Make it lowercase (<code>request</code>) since it's an internal helper."
            ],
            "solution": "type APIClient struct {\n    baseURL    string\n    token      string\n    httpClient *http.Client\n}\n\nfunc NewClient(baseURL, token string) *APIClient {\n    return &APIClient{\n        baseURL:    baseURL,\n        token:      token,\n        httpClient: &http.Client{Timeout: 30 * time.Second},\n    }\n}\n\nfunc (c *APIClient) request(method, path string, body io.Reader) (*http.Response, error) {\n    req, err := http.NewRequest(method, c.baseURL+path, body)\n    if err != nil {\n        return nil, err\n    }\n    req.Header.Set(\"Authorization\", \"Bearer \"+c.token)\n    req.Header.Set(\"Accept\", \"application/json\")\n    if body != nil {\n        req.Header.Set(\"Content-Type\", \"application/json\")\n    }\n    return c.httpClient.Do(req)\n}",
            "annotations": [
              { "type": "pattern", "label": "API Client Pattern", "text": "A client struct encapsulates base URL, auth, timeout, and common headers. Public methods like <code>GetUser()</code> call the private <code>request()</code> helper." },
              { "type": "idiom", "label": "Constructor", "text": "<code>NewClient()</code> is Go's convention for constructors. It returns a pointer to the initialized struct." }
            ]
          },
          {
            "id": "v2",
            "title": "Client GET Method",
            "description": "Add a public <code>Get(path string, result any) error</code> method to the API client that makes a GET request, checks the status, and decodes the JSON response into <code>result</code>.",
            "hints": [
              "Call the private <code>c.request(\"GET\", path, nil)</code>.",
              "Check <code>resp.StatusCode != http.StatusOK</code>.",
              "Use <code>json.NewDecoder(resp.Body).Decode(result)</code>."
            ],
            "solution": "func (c *APIClient) Get(path string, result any) error {\n    resp, err := c.request(\"GET\", path, nil)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return fmt.Errorf(\"API error: %s\", resp.Status)\n    }\n\n    return json.NewDecoder(resp.Body).Decode(result)\n}\n\n// Usage:\nvar user User\nerr := client.Get(\"/users/octocat\", &user)",
            "annotations": [
              { "type": "pattern", "label": "Generic Decode", "text": "Using <code>any</code> (or <code>interface{}</code>) for the result parameter lets one method decode into any struct type." }
            ]
          },
          {
            "id": "v3",
            "title": "Client POST Method",
            "description": "Add a public <code>Post(path string, payload any, result any) error</code> method that marshals the payload to JSON, sends a POST, and decodes the response.",
            "hints": [
              "Marshal with <code>json.Marshal(payload)</code>, wrap in <code>bytes.NewReader</code>.",
              "Call <code>c.request(\"POST\", path, bodyReader)</code>.",
              "Check for <code>StatusCreated</code> (201) — the typical POST success code."
            ],
            "solution": "func (c *APIClient) Post(path string, payload any, result any) error {\n    data, err := json.Marshal(payload)\n    if err != nil {\n        return err\n    }\n\n    resp, err := c.request(\"POST\", path, bytes.NewReader(data))\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusCreated && resp.StatusCode != http.StatusOK {\n        body, _ := io.ReadAll(resp.Body)\n        return fmt.Errorf(\"API error %s: %s\", resp.Status, string(body))\n    }\n\n    if result != nil {\n        return json.NewDecoder(resp.Body).Decode(result)\n    }\n    return nil\n}",
            "annotations": [
              { "type": "pattern", "label": "POST Response", "text": "POST endpoints typically return 201 (Created) with the created resource in the body, or 200 with a result." },
              { "type": "idiom", "label": "Optional Result", "text": "Checking <code>result != nil</code> lets callers skip decoding when they don't need the response body." }
            ]
          }
        ]
      },
      {
        "id": "challenge_2",
        "concept": "Middleware",
        "variants": [
          {
            "id": "v1",
            "title": "Logging Middleware",
            "description": "Write a logging middleware that prints the HTTP method, path, and duration for every request. It should wrap an <code>http.Handler</code> and return a new <code>http.Handler</code>.",
            "hints": [
              "Capture <code>start := time.Now()</code> before calling <code>next.ServeHTTP(w, r)</code>.",
              "After the call, compute duration with <code>time.Since(start)</code>.",
              "Use <code>http.HandlerFunc</code> to convert a function into an <code>http.Handler</code>."
            ],
            "solution": "func LoggingMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n        next.ServeHTTP(w, r)\n        fmt.Printf(\"%s %s %v\\n\", r.Method, r.URL.Path, time.Since(start))\n    })\n}",
            "annotations": [
              { "type": "pattern", "label": "Middleware Signature", "text": "Go middleware is <code>func(http.Handler) http.Handler</code>. It wraps the next handler, does work before/after, and calls <code>next.ServeHTTP</code>." },
              { "type": "idiom", "label": "HandlerFunc Adapter", "text": "<code>http.HandlerFunc</code> converts a function with the right signature into an <code>http.Handler</code> interface value." }
            ]
          },
          {
            "id": "v2",
            "title": "Auth Middleware",
            "description": "Write an auth middleware that checks for an <code>Authorization</code> header. If missing, return <code>401 Unauthorized</code>. If present, call the next handler.",
            "hints": [
              "Read header: <code>r.Header.Get(\"Authorization\")</code>.",
              "If empty, use <code>http.Error(w, \"Unauthorized\", http.StatusUnauthorized)</code> and return.",
              "If present, call <code>next.ServeHTTP(w, r)</code> to continue."
            ],
            "solution": "func AuthMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        token := r.Header.Get(\"Authorization\")\n        if token == \"\" {\n            http.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n            return\n        }\n        next.ServeHTTP(w, r)\n    })\n}",
            "annotations": [
              { "type": "pattern", "label": "Guard Middleware", "text": "Auth middleware acts as a guard: it short-circuits the request if the check fails, preventing the handler from running." },
              { "type": "gotcha", "label": "Return After Error", "text": "After calling <code>http.Error()</code>, you MUST return. Otherwise the next handler will still run and may write conflicting headers." }
            ]
          },
          {
            "id": "v3",
            "title": "Middleware Chain",
            "description": "Write a <code>Chain</code> function that applies multiple middleware to a handler. The first middleware in the list should be the outermost wrapper.",
            "hints": [
              "Type: <code>func Chain(h http.Handler, mw ...func(http.Handler) http.Handler) http.Handler</code>.",
              "Loop through middleware and wrap: <code>h = mw(h)</code>.",
              "The last middleware applied runs first (outermost)."
            ],
            "solution": "func Chain(h http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler {\n    for _, mw := range middlewares {\n        h = mw(h)\n    }\n    return h\n}\n\n// Usage:\nhandler := Chain(\n    myHandler,\n    LoggingMiddleware,\n    AuthMiddleware,\n)\nhttp.ListenAndServe(\":8080\", handler)",
            "annotations": [
              { "type": "pattern", "label": "Middleware Chain", "text": "Chaining middleware creates a pipeline. Each layer wraps the previous one, like layers of an onion." },
              { "type": "gotcha", "label": "Order Matters", "text": "The last middleware applied wraps the outermost layer. If you want logging first, list it first — it gets applied last and wraps everything." }
            ]
          }
        ]
      }
    ]
  }
}
