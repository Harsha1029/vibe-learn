{
  "conceptLinks": {
    "os.ReadFile": "#lesson-reading-files",
    "os.WriteFile": "#lesson-writing-files",
    "YAML Parsing": "#lesson-yaml",
    "exec.Command": "#lesson-shell-commands",
    "Environment Variables": "#lesson-env-vars"
  },
  "sharedContent": {},
  "variants": {
    "warmups": [
      {
        "id": "warmup_1",
        "concept": "os.ReadFile",
        "variants": [
          {
            "id": "v1",
            "title": "Read and Print File",
            "description": "Use <code>os.ReadFile</code> to read a file called <code>\"message.txt\"</code> and print its contents. Handle the error by printing it and returning early.",
            "hints": [
              "<code>os.ReadFile</code> returns <code>([]byte, error)</code>.",
              "Convert the byte slice to a string with <code>string(data)</code>.",
              "Check <code>err != nil</code> before using the data."
            ],
            "solution": "data, err := os.ReadFile(\"message.txt\")\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\nfmt.Println(string(data))",
            "annotations": [
              { "type": "idiom", "label": "ReadFile", "text": "<code>os.ReadFile</code> reads the entire file into memory. For small config files this is the simplest approach." },
              { "type": "gotcha", "label": "Byte Slice", "text": "<code>os.ReadFile</code> returns <code>[]byte</code>, not <code>string</code>. You must convert with <code>string(data)</code> to print it as text." }
            ]
          },
          {
            "id": "v2",
            "title": "Count Lines in File",
            "description": "Read a file with <code>os.ReadFile</code> and count the number of lines. Print the count. (Hint: split on newline.)",
            "hints": [
              "Use <code>strings.Split(string(data), \"\\n\")</code> to split into lines.",
              "The last element may be empty if the file ends with a newline — consider trimming.",
              "Use <code>len(lines)</code> to get the count."
            ],
            "solution": "data, err := os.ReadFile(\"input.txt\")\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\nlines := strings.Split(strings.TrimRight(string(data), \"\\n\"), \"\\n\")\nfmt.Println(\"Lines:\", len(lines))",
            "annotations": [
              { "type": "idiom", "label": "TrimRight", "text": "Files often end with a trailing newline. <code>strings.TrimRight</code> removes it before splitting to avoid an extra empty element." }
            ]
          },
          {
            "id": "v3",
            "title": "Check File Exists",
            "description": "Write a function <code>fileExists(path string) bool</code> that returns true if the file exists, false otherwise. Use <code>os.Stat</code>.",
            "hints": [
              "<code>os.Stat</code> returns <code>(os.FileInfo, error)</code>.",
              "Use <code>os.IsNotExist(err)</code> to check if the error means the file doesn't exist.",
              "If <code>err == nil</code>, the file exists."
            ],
            "solution": "func fileExists(path string) bool {\n    _, err := os.Stat(path)\n    return !os.IsNotExist(err)\n}",
            "annotations": [
              { "type": "idiom", "label": "os.Stat", "text": "<code>os.Stat</code> is Go's way to check file existence and metadata. It returns an error if the file can't be accessed." },
              { "type": "gotcha", "label": "Other Errors", "text": "<code>os.IsNotExist</code> only checks for \"file not found\" errors. Permission errors will also make <code>Stat</code> fail but <code>IsNotExist</code> returns false." }
            ]
          }
        ]
      },
      {
        "id": "warmup_2",
        "concept": "os.WriteFile",
        "variants": [
          {
            "id": "v1",
            "title": "Write String to File",
            "description": "Use <code>os.WriteFile</code> to write the string <code>\"Hello, Go!\"</code> to a file called <code>\"output.txt\"</code> with permission <code>0644</code>.",
            "hints": [
              "<code>os.WriteFile</code> takes <code>(name string, data []byte, perm os.FileMode)</code>.",
              "Convert the string with <code>[]byte(\"Hello, Go!\")</code>.",
              "<code>0644</code> means owner read/write, others read-only."
            ],
            "solution": "err := os.WriteFile(\"output.txt\", []byte(\"Hello, Go!\"), 0644)\nif err != nil {\n    fmt.Println(\"Error:\", err)\n}",
            "annotations": [
              { "type": "idiom", "label": "File Permissions", "text": "<code>0644</code> is the standard permission for config/data files: owner can read and write, everyone else can only read." }
            ]
          },
          {
            "id": "v2",
            "title": "Copy File Contents",
            "description": "Read the contents of <code>\"source.txt\"</code> and write them to <code>\"dest.txt\"</code>. Use <code>os.ReadFile</code> and <code>os.WriteFile</code>.",
            "hints": [
              "Read first with <code>os.ReadFile(\"source.txt\")</code>.",
              "Pass the same <code>[]byte</code> data directly to <code>os.WriteFile</code>.",
              "No need to convert between string and bytes — it's already <code>[]byte</code>."
            ],
            "solution": "data, err := os.ReadFile(\"source.txt\")\nif err != nil {\n    fmt.Println(\"Error reading:\", err)\n    return\n}\nerr = os.WriteFile(\"dest.txt\", data, 0644)\nif err != nil {\n    fmt.Println(\"Error writing:\", err)\n}",
            "annotations": [
              { "type": "idiom", "label": "Simple Copy", "text": "For small files, ReadFile + WriteFile is the simplest copy pattern. For large files, use <code>io.Copy</code> with open file handles." }
            ]
          },
          {
            "id": "v3",
            "title": "Write Lines to File",
            "description": "Write a function <code>writeLines(path string, lines []string) error</code> that joins the lines with newlines and writes them to the file.",
            "hints": [
              "Use <code>strings.Join(lines, \"\\n\")</code> to combine the lines.",
              "Add a trailing newline: <code>content + \"\\n\"</code>.",
              "Return the error from <code>os.WriteFile</code> directly."
            ],
            "solution": "func writeLines(path string, lines []string) error {\n    content := strings.Join(lines, \"\\n\") + \"\\n\"\n    return os.WriteFile(path, []byte(content), 0644)\n}",
            "annotations": [
              { "type": "idiom", "label": "Trailing Newline", "text": "Text files should end with a trailing newline. It's a POSIX convention and many tools expect it." }
            ]
          }
        ]
      },
      {
        "id": "warmup_3",
        "concept": "YAML Parsing",
        "variants": [
          {
            "id": "v1",
            "title": "Parse Simple YAML Config",
            "description": "Define a <code>Config</code> struct with <code>Name string</code> and <code>Port int</code> fields. Read <code>\"config.yaml\"</code> and unmarshal it into the struct. Print the values.",
            "hints": [
              "Use YAML struct tags: <code>`yaml:\"name\"`</code>.",
              "Call <code>yaml.Unmarshal(data, &config)</code> to parse.",
              "Import <code>gopkg.in/yaml.v3</code>."
            ],
            "solution": "type Config struct {\n    Name string `yaml:\"name\"`\n    Port int    `yaml:\"port\"`\n}\n\ndata, err := os.ReadFile(\"config.yaml\")\nif err != nil {\n    panic(err)\n}\n\nvar config Config\nif err := yaml.Unmarshal(data, &config); err != nil {\n    panic(err)\n}\nfmt.Printf(\"Name: %s, Port: %d\\n\", config.Name, config.Port)",
            "annotations": [
              { "type": "idiom", "label": "Struct Tags", "text": "YAML struct tags map Go field names to YAML keys. By convention, YAML keys are lowercase/snake_case while Go fields are uppercase CamelCase." },
              { "type": "gotcha", "label": "Exported Fields", "text": "Only exported (uppercase) struct fields are visible to <code>yaml.Unmarshal</code>. Lowercase fields will be silently ignored." }
            ]
          },
          {
            "id": "v2",
            "title": "Parse YAML with Nested Map",
            "description": "Define a <code>Config</code> struct with a <code>Tasks map[string]string</code> field. Parse YAML like <code>tasks:\\n  build: \"go build\"\\n  test: \"go test\"</code>. Iterate and print each task.",
            "hints": [
              "Maps in YAML become <code>map[string]string</code> in Go.",
              "Use the struct tag <code>`yaml:\"tasks\"`</code>.",
              "Iterate with <code>for name, cmd := range config.Tasks</code>."
            ],
            "solution": "type Config struct {\n    Tasks map[string]string `yaml:\"tasks\"`\n}\n\ndata, err := os.ReadFile(\"tasks.yaml\")\nif err != nil {\n    panic(err)\n}\n\nvar config Config\nif err := yaml.Unmarshal(data, &config); err != nil {\n    panic(err)\n}\n\nfor name, cmd := range config.Tasks {\n    fmt.Printf(\"%s: %s\\n\", name, cmd)\n}",
            "annotations": [
              { "type": "idiom", "label": "Map Fields", "text": "YAML mappings naturally map to Go's <code>map[string]T</code>. Use this when keys are dynamic rather than a fixed set of fields." }
            ]
          },
          {
            "id": "v3",
            "title": "Parse YAML with Slice Field",
            "description": "Define a struct with a <code>Tags []string</code> field. Parse YAML like <code>tags:\\n  - go\\n  - cli\\n  - tools</code>. Print each tag.",
            "hints": [
              "YAML lists become Go slices.",
              "Use <code>`yaml:\"tags\"`</code> as the struct tag.",
              "Iterate with <code>for _, tag := range config.Tags</code>."
            ],
            "solution": "type Config struct {\n    Tags []string `yaml:\"tags\"`\n}\n\ndata, _ := os.ReadFile(\"config.yaml\")\nvar config Config\nyaml.Unmarshal(data, &config)\n\nfor _, tag := range config.Tags {\n    fmt.Println(tag)\n}",
            "annotations": [
              { "type": "idiom", "label": "YAML Lists", "text": "YAML sequences (lines starting with <code>-</code>) deserialize into Go slices. The element type must match the YAML values." }
            ]
          }
        ]
      },
      {
        "id": "warmup_4",
        "concept": "exec.Command",
        "variants": [
          {
            "id": "v1",
            "title": "Run a Command and Capture Output",
            "description": "Use <code>exec.Command</code> to run <code>echo \"hello\"</code> and print the output. Handle the error.",
            "hints": [
              "Use <code>exec.Command(\"echo\", \"hello\")</code> — the args are separate strings.",
              "Call <code>.Output()</code> to get the stdout as <code>[]byte</code>.",
              "Convert to string and print: <code>string(out)</code>."
            ],
            "solution": "out, err := exec.Command(\"echo\", \"hello\").Output()\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\nfmt.Print(string(out))",
            "annotations": [
              { "type": "idiom", "label": "Separate Args", "text": "<code>exec.Command</code> takes the program and arguments as separate strings. Do NOT pass <code>\"echo hello\"</code> as one string." },
              { "type": "gotcha", "label": "No Shell", "text": "<code>exec.Command</code> runs the program directly — no shell features like pipes or globbing. Use <code>bash -c</code> for shell features." }
            ]
          },
          {
            "id": "v2",
            "title": "Run Shell Command with Pipe",
            "description": "Run <code>echo hello world | wc -w</code> through a shell using <code>exec.Command(\"bash\", \"-c\", ...)</code>. Print the word count.",
            "hints": [
              "Wrap the full command in <code>exec.Command(\"bash\", \"-c\", \"echo hello world | wc -w\")</code>.",
              "The pipe <code>|</code> is a shell feature, so you must use <code>bash -c</code>.",
              "Trim whitespace from the output with <code>strings.TrimSpace</code>."
            ],
            "solution": "out, err := exec.Command(\"bash\", \"-c\", \"echo hello world | wc -w\").Output()\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\nfmt.Println(strings.TrimSpace(string(out)))",
            "annotations": [
              { "type": "idiom", "label": "bash -c", "text": "When you need shell features (pipes, redirects, globs), wrap the command in <code>bash -c \"...\"</code>." }
            ]
          },
          {
            "id": "v3",
            "title": "Stream Command Output",
            "description": "Run <code>go version</code> and stream its output directly to stdout. Use <code>cmd.Stdout = os.Stdout</code>.",
            "hints": [
              "Create the command: <code>cmd := exec.Command(\"go\", \"version\")</code>.",
              "Set <code>cmd.Stdout = os.Stdout</code> and <code>cmd.Stderr = os.Stderr</code>.",
              "Call <code>cmd.Run()</code> instead of <code>.Output()</code>."
            ],
            "solution": "cmd := exec.Command(\"go\", \"version\")\ncmd.Stdout = os.Stdout\ncmd.Stderr = os.Stderr\nif err := cmd.Run(); err != nil {\n    fmt.Println(\"Error:\", err)\n}",
            "annotations": [
              { "type": "idiom", "label": "Stream Output", "text": "Setting <code>cmd.Stdout = os.Stdout</code> connects the subprocess output directly to the terminal. No buffering, no conversion needed." },
              { "type": "pattern", "label": "Run vs Output", "text": "<code>cmd.Run()</code> streams to connected writers. <code>cmd.Output()</code> captures stdout into a byte slice. Use <code>Run</code> when you want real-time output." }
            ]
          }
        ]
      }
    ],
    "challenges": [
      {
        "id": "challenge_1",
        "concept": "YAML Config Runner",
        "variants": [
          {
            "id": "v1",
            "title": "YAML Task Executor",
            "description": "Read a YAML file with tasks (each has a <code>command</code> string). Execute each task's command using <code>exec.Command</code> through <code>bash -c</code>. Print the task name before running it.",
            "hints": [
              "Define a struct: <code>type Config struct { Tasks map[string]Task }</code> where Task has a Command field.",
              "Iterate tasks with <code>for name, task := range config.Tasks</code>.",
              "Run each with <code>exec.Command(\"bash\", \"-c\", task.Command)</code>."
            ],
            "solution": "type Task struct {\n    Command string `yaml:\"command\"`\n}\n\ntype Config struct {\n    Tasks map[string]Task `yaml:\"tasks\"`\n}\n\ndata, err := os.ReadFile(\"tasks.yaml\")\nif err != nil {\n    panic(err)\n}\n\nvar config Config\nif err := yaml.Unmarshal(data, &config); err != nil {\n    panic(err)\n}\n\nfor name, task := range config.Tasks {\n    fmt.Printf(\"Running: %s\\n\", name)\n    cmd := exec.Command(\"bash\", \"-c\", task.Command)\n    cmd.Stdout = os.Stdout\n    cmd.Stderr = os.Stderr\n    if err := cmd.Run(); err != nil {\n        fmt.Printf(\"  Error: %v\\n\", err)\n    }\n}",
            "annotations": [
              { "type": "pattern", "label": "Config-Driven Execution", "text": "Reading commands from config files and executing them is a common pattern in task runners, CI systems, and deployment tools." },
              { "type": "gotcha", "label": "Map Iteration Order", "text": "Go maps iterate in random order. If task execution order matters, use a slice instead of a map." }
            ]
          },
          {
            "id": "v2",
            "title": "Config File Loader with Defaults",
            "description": "Write a function <code>loadConfig(path string) (*Config, error)</code> that reads a YAML config file. If the file doesn't exist, return a default config with <code>Port: 8080</code> and <code>Name: \"app\"</code>.",
            "hints": [
              "Check for file existence: if <code>os.ReadFile</code> returns an error, check with <code>os.IsNotExist</code>.",
              "Return the default config when the file is missing.",
              "Return the actual error for other failures (e.g., permission denied)."
            ],
            "solution": "type Config struct {\n    Name string `yaml:\"name\"`\n    Port int    `yaml:\"port\"`\n}\n\nfunc loadConfig(path string) (*Config, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return &Config{Name: \"app\", Port: 8080}, nil\n        }\n        return nil, err\n    }\n\n    var config Config\n    if err := yaml.Unmarshal(data, &config); err != nil {\n        return nil, err\n    }\n    return &config, nil\n}",
            "annotations": [
              { "type": "pattern", "label": "Defaults Pattern", "text": "Loading config with fallback defaults is a common production pattern. Check for \"not found\" specifically and return defaults; propagate all other errors." }
            ]
          },
          {
            "id": "v3",
            "title": "Directory Lister",
            "description": "Write a function <code>listGoFiles(dir string) ([]string, error)</code> that reads a directory and returns only the <code>.go</code> file names (not directories).",
            "hints": [
              "Use <code>os.ReadDir(dir)</code> to list entries.",
              "Check <code>!entry.IsDir()</code> and <code>strings.HasSuffix(entry.Name(), \".go\")</code>.",
              "Collect matching names into a <code>[]string</code> slice."
            ],
            "solution": "func listGoFiles(dir string) ([]string, error) {\n    entries, err := os.ReadDir(dir)\n    if err != nil {\n        return nil, err\n    }\n\n    var files []string\n    for _, entry := range entries {\n        if !entry.IsDir() && strings.HasSuffix(entry.Name(), \".go\") {\n            files = append(files, entry.Name())\n        }\n    }\n    return files, nil\n}",
            "annotations": [
              { "type": "idiom", "label": "ReadDir", "text": "<code>os.ReadDir</code> returns entries sorted by name. Each entry has <code>Name()</code>, <code>IsDir()</code>, and <code>Type()</code> methods." }
            ]
          }
        ]
      },
      {
        "id": "challenge_2",
        "concept": "Environment Variables",
        "variants": [
          {
            "id": "v1",
            "title": "Required Env Vars",
            "description": "Write a function <code>requireEnv(key string) (string, error)</code> that returns the value of an environment variable, or an error if it's not set.",
            "hints": [
              "Use <code>os.LookupEnv(key)</code> which returns <code>(value, exists)</code>.",
              "If <code>!exists</code>, return an error with <code>fmt.Errorf</code>.",
              "Return the value and nil on success."
            ],
            "solution": "func requireEnv(key string) (string, error) {\n    val, exists := os.LookupEnv(key)\n    if !exists {\n        return \"\", fmt.Errorf(\"required env var %s is not set\", key)\n    }\n    return val, nil\n}",
            "annotations": [
              { "type": "idiom", "label": "LookupEnv", "text": "<code>os.LookupEnv</code> distinguishes between \"not set\" and \"set to empty string\". <code>os.Getenv</code> returns empty string for both." },
              { "type": "pattern", "label": "Required Config", "text": "Failing fast on missing required configuration prevents confusing runtime errors later." }
            ]
          },
          {
            "id": "v2",
            "title": "Env with Default",
            "description": "Write a function <code>envOrDefault(key, fallback string) string</code> that returns the environment variable value, or the fallback if not set.",
            "hints": [
              "Use <code>os.Getenv(key)</code> — it returns empty string if not set.",
              "Check if the result is empty, return fallback if so.",
              "Or use <code>os.LookupEnv</code> for a more precise check."
            ],
            "solution": "func envOrDefault(key, fallback string) string {\n    val, exists := os.LookupEnv(key)\n    if !exists {\n        return fallback\n    }\n    return val\n}",
            "annotations": [
              { "type": "idiom", "label": "Default Pattern", "text": "Using <code>LookupEnv</code> + fallback preserves intentionally empty values. With <code>Getenv</code>, you can't tell if the var was set to empty or not set at all." }
            ]
          },
          {
            "id": "v3",
            "title": "Run Command with Custom Env",
            "description": "Write a function that runs a command with an extra environment variable <code>APP_MODE=production</code> added to the current environment. Return the command output.",
            "hints": [
              "Use <code>os.Environ()</code> to get the current environment as a <code>[]string</code>.",
              "Append your extra var: <code>append(os.Environ(), \"APP_MODE=production\")</code>.",
              "Set <code>cmd.Env</code> before calling <code>cmd.Output()</code>."
            ],
            "solution": "func runWithEnv(program string, args ...string) (string, error) {\n    cmd := exec.Command(program, args...)\n    cmd.Env = append(os.Environ(), \"APP_MODE=production\")\n    out, err := cmd.Output()\n    if err != nil {\n        return \"\", err\n    }\n    return string(out), nil\n}",
            "annotations": [
              { "type": "idiom", "label": "Custom Env", "text": "Setting <code>cmd.Env</code> replaces the entire environment. Always start with <code>os.Environ()</code> and append to preserve the existing environment." },
              { "type": "gotcha", "label": "Env Replacement", "text": "If you set <code>cmd.Env</code> to just your custom vars without <code>os.Environ()</code>, the subprocess won't have PATH, HOME, or any other standard variables." }
            ]
          }
        ]
      }
    ]
  }
}
