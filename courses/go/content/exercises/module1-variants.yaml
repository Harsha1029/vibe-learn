conceptLinks:
  Variable Declaration: "#lesson-variables"
  Type Conversion: "#lesson-variables"
  String Formatting: "#lesson-functions"
  Function Basics: "#lesson-functions"
  Multiple Returns: "#lesson-functions"
  Error Handling: "#lesson-functions"
  Building Slices: "#lesson-slices"
  Slice Operations: "#lesson-slices"
  For Loops: "#lesson-loops"
  Range Loops: "#lesson-loops"
  Map Basics: "#lesson-maps"
  Comma-Ok Pattern: "#lesson-comma-ok"
  Strings & Runes: "#lesson-variables"
  Go Fundamentals Combined: "#lesson-variables"
  If/Else: "#lesson-if"
  Slices & Range: "#lesson-slices"
  Maps: "#lesson-maps"
  make() Function: "#lesson-slices"
  Range with Index: "#lesson-loops"
variants:
  warmups:
    - id: warmup_1
      concept: For Loops
      variants:
        - id: v1
          title: Print 1 to 10
          description: Write a program that prints the numbers 1 to 10, one per line.
          hints:
            - Use <code>for i := 1; i <= 10; i++</code>
          solution: |-
            for i := 1; i <= 10; i++ {
                fmt.Println(i)
            }
        - id: v2
          title: Countdown from 5
          description: Write a program that counts down from 5 to 1, then prints "Go!"
          hints:
            - Use <code>for i := 5; i >= 1; i--</code>
            - Print "Go!" after the loop
          solution: |-
            for i := 5; i >= 1; i-- {
                fmt.Println(i)
            }
            fmt.Println("Go!")
        - id: v3
          title: Print Even Numbers
          description: Write a program that prints even numbers from 2 to 10.
          hints:
            - Use <code>for i := 2; i <= 10; i += 2</code>
          solution: |-
            for i := 2; i <= 10; i += 2 {
                fmt.Println(i)
            }
        - id: v4
          title: Count by Twos
          description: Write a program that prints odd numbers from 1 to 9.
          hints:
            - Use <code>for i := 1; i <= 9; i += 2</code>
          solution: |-
            for i := 1; i <= 9; i += 2 {
                fmt.Println(i)
            }
        - id: v5
          title: Sum First N Numbers
          description: Write a program that calculates and prints the sum of numbers from 1 to 5.
          hints:
            - Create a <code>sum</code> variable
            - "Add each number: <code>sum += i</code>"
          solution: |-
            sum := 0
            for i := 1; i <= 5; i++ {
                sum += i
            }
            fmt.Println(sum)  // 15
        - id: v6
          title: Multiplication Table Row
          description: Write a program that prints the 3 times table from 3x1 to 3x5.
          hints:
            - Loop from 1 to 5
            - Print <code>3 * i</code> each time
          solution: |-
            for i := 1; i <= 5; i++ {
                fmt.Printf("3 x %d = %d\n", i, 3*i)
            }
        - id: v7
          title: Print Squares
          description: Write a program that prints the square of numbers from 1 to 4.
          hints:
            - Square is <code>i * i</code>
          solution: |-
            for i := 1; i <= 4; i++ {
                fmt.Println(i * i)
            }
        - id: v8
          title: Count Down by Threes
          description: Write a program that counts down from 15 to 0 by threes (15, 12, 9, 6, 3, 0).
          hints:
            - Start at 15, use <code>i -= 3</code>
          solution: |-
            for i := 15; i >= 0; i -= 3 {
                fmt.Println(i)
            }
        - id: v9
          title: Fibonacci First N
          description: Write a program that prints the first 7 Fibonacci numbers (1, 1, 2, 3, 5, 8, 13).
          hints:
            - Start with <code>a, b := 1, 1</code>
            - Each new number is the sum of the previous two
          solution: |-
            a, b := 1, 1
            for i := 0; i < 7; i++ {
                fmt.Println(a)
                a, b = b, a+b
            }
        - id: v10
          title: Factorial
          description: Write a program that calculates and prints 5! (5 factorial = 5 × 4 × 3 × 2 × 1 = 120).
          hints:
            - Start with <code>result := 1</code>
            - "Multiply by each number: <code>result *= i</code>"
          solution: |-
            result := 1
            for i := 1; i <= 5; i++ {
                result *= i
            }
            fmt.Println(result)  // 120
        - id: v11
          title: Skip Count by Fives
          description: Write a program that counts from 0 to 25 by fives (0, 5, 10, 15, 20, 25).
          hints:
            - Use <code>for i := 0; i <= 25; i += 5</code>
          solution: |-
            for i := 0; i <= 25; i += 5 {
                fmt.Println(i)
            }
        - id: v12
          title: Print Star Pattern
          description: Write a program that prints a triangle pattern of stars (1 star, then 2 stars, then 3 stars).
          hints:
            - Outer loop controls rows
            - "Inner loop prints stars: <code>for j := 0; j < i; j++</code>"
          solution: |-
            for i := 1; i <= 3; i++ {
                for j := 0; j < i; j++ {
                    fmt.Print("*")
                }
                fmt.Println()
            }
        - id: v13
          title: Power of Two
          description: Write a program that prints powers of 2 from 2^0 to 2^5 (1, 2, 4, 8, 16, 32).
          hints:
            - Start with <code>power := 1</code>
            - "Double each time: <code>power *= 2</code>"
          solution: |-
            power := 1
            for i := 0; i <= 5; i++ {
                fmt.Println(power)
                power *= 2
            }
    - id: warmup_2
      concept: If/Else
      variants:
        - id: v1
          title: Odd or Even
          description: Write <code>func oddOrEven(n int) string</code> that returns "even" if n is divisible by 2, else "odd".
          hints:
            - "Use modulo: <code>if n % 2 == 0</code> means even"
          solution: |-
            func oddOrEven(n int) string {
                if n % 2 == 0 {
                    return "even"
                }
                return "odd"
            }
        - id: v2
          title: Pass or Fail
          description: Write <code>func passOrFail(score int) string</code> that returns "pass" if score >= 60, else "fail".
          hints:
            - "Simple if/else: <code>if score >= 60 { return \"pass\" }</code>"
          solution: |-
            func passOrFail(score int) string {
                if score >= 60 {
                    return "pass"
                }
                return "fail"
            }
        - id: v3
          title: Temperature Feel
          description: >-
            Write <code>func tempFeel(celsius int) string</code> that returns "freezing" (< 0), "cold" (0-15), "warm"
            (16-25), or "hot" (> 25).
          hints:
            - Chain if/else if based on temperature thresholds
          solution: |-
            func tempFeel(celsius int) string {
                if celsius < 0 {
                    return "freezing"
                } else if celsius <= 15 {
                    return "cold"
                } else if celsius <= 25 {
                    return "warm"
                }
                return "hot"
            }
        - id: v4
          title: Grade Letter
          description: >-
            Write <code>func gradeLetter(score int) string</code> that returns "A" (>=90), "B" (>=80), "C" (>=70), "D"
            (>=60), or "F" (<60).
          hints:
            - Use chained if/else if statements
            - Check highest grade first
          solution: |-
            func gradeLetter(score int) string {
                if score >= 90 {
                    return "A"
                } else if score >= 80 {
                    return "B"
                } else if score >= 70 {
                    return "C"
                } else if score >= 60 {
                    return "D"
                }
                return "F"
            }
        - id: v5
          title: Voting Eligibility
          description: Write <code>func canVote(age int) string</code> that returns "can vote" if age >= 18, else "too young".
          hints:
            - Simple comparison with 18
          solution: |-
            func canVote(age int) string {
                if age >= 18 {
                    return "can vote"
                }
                return "too young"
            }
        - id: v6
          title: Discount Eligibility
          description: >-
            Write <code>func getDiscount(age int) string</code> that returns "senior discount" (>=65), "student
            discount" (<=25), or "no discount".
          hints:
            - Check senior first, then student, then default
          solution: |-
            func getDiscount(age int) string {
                if age >= 65 {
                    return "senior discount"
                } else if age <= 25 {
                    return "student discount"
                }
                return "no discount"
            }
        - id: v7
          title: Positive or Negative
          description: Write <code>func posNegZero(n int) string</code> that returns "positive", "negative", or "zero".
          hints:
            - Check if n > 0, n < 0, or else it's zero
          solution: |-
            func posNegZero(n int) string {
                if n > 0 {
                    return "positive"
                } else if n < 0 {
                    return "negative"
                }
                return "zero"
            }
        - id: v8
          title: Speed Limit
          description: >-
            Write <code>func speedCheck(speed int) string</code> that returns "safe" (<=60), "warning" (61-80), or
            "ticket" (>80).
          hints:
            - Use ranges for different categories
          solution: |-
            func speedCheck(speed int) string {
                if speed <= 60 {
                    return "safe"
                } else if speed <= 80 {
                    return "warning"
                }
                return "ticket"
            }
        - id: v9
          title: Age Category
          description: >-
            Write <code>func ageCategory(age int) string</code> that returns "child" if age < 13, "teen" if age < 20,
            else "adult".
          hints:
            - Use multiple if/else if statements
            - Check conditions from smallest to largest
          solution: |-
            func ageCategory(age int) string {
                if age < 13 {
                    return "child"
                } else if age < 20 {
                    return "teen"
                }
                return "adult"
            }
        - id: v10
          title: BMI Category
          description: >-
            Write <code>func bmiCategory(bmi float64) string</code> that returns "underweight" if bmi < 18.5, "normal"
            if bmi < 25, else "overweight".
          hints:
            - Use <code>else if</code> for the middle condition
          solution: |-
            func bmiCategory(bmi float64) string {
                if bmi < 18.5 {
                    return "underweight"
                } else if bmi < 25 {
                    return "normal"
                }
                return "overweight"
            }
        - id: v11
          title: Season from Month
          description: >-
            Write <code>func season(month int) string</code> that returns "winter" for 12-2, "spring" for 3-5, "summer"
            for 6-8, "fall" for 9-11.
          hints:
            - Use multiple if/else if conditions
            - Check ranges like <code>month >= 3 && month <= 5</code>
          solution: |-
            func season(month int) string {
                if month == 12 || month <= 2 {
                    return "winter"
                } else if month <= 5 {
                    return "spring"
                } else if month <= 8 {
                    return "summer"
                }
                return "fall"
            }
        - id: v12
          title: Weekend or Weekday
          description: >-
            Write <code>func dayType(day string) string</code> that returns "weekend" if day is "Saturday" or "Sunday",
            else "weekday".
          hints:
            - Use <code>||</code> (OR) operator
            - "Check: <code>if day == \"Saturday\" || day == \"Sunday\"</code>"
          solution: |-
            func dayType(day string) string {
                if day == "Saturday" || day == "Sunday" {
                    return "weekend"
                }
                return "weekday"
            }
        - id: v13
          title: Password Strength
          description: >-
            Write <code>func passwordStrength(length int) string</code> that returns "weak" if length < 8, "medium" if
            length < 12, else "strong".
          hints:
            - Simple if/else if chain based on length thresholds
          solution: |-
            func passwordStrength(length int) string {
                if length < 8 {
                    return "weak"
                } else if length < 12 {
                    return "medium"
                }
                return "strong"
            }
    - id: warmup_3
      concept: Slices & Range
      variants:
        - id: v1
          title: Iterate Numbers
          description: Create a slice with three numbers, then print each using <code>for range</code>.
          hints:
            - "Create: <code>nums := []int{7, 42, 99}</code>"
            - "Loop: <code>for _, num := range nums</code>"
          solution: |-
            nums := []int{7, 42, 99}
            for _, num := range nums {
                fmt.Println(num)
            }
        - id: v2
          title: Iterate with Index
          description: "Create a slice of colors, then print each with its index: \"0: red\", \"1: blue\", etc."
          hints:
            - "Loop with index: <code>for i, color := range colors</code>"
            - "Use <code>fmt.Printf(\"%d: %s\\n\", i, color)</code>"
          solution: |-
            colors := []string{"red", "blue", "green"}
            for i, color := range colors {
                fmt.Printf("%d: %s\n", i, color)
            }
        - id: v3
          title: Iterate Strings
          description: Create a slice of your favorite foods, print each on its own line.
          hints:
            - "Create: <code>foods := []string{\"pizza\", \"sushi\", \"tacos\"}</code>"
          solution: |-
            foods := []string{"pizza", "sushi", "tacos"}
            for _, food := range foods {
                fmt.Println(food)
            }
        - id: v4
          title: Sum Slice
          description: Create a slice of numbers, then calculate and print their sum.
          hints:
            - Create a sum variable before the loop
            - "Add each number: <code>sum += num</code>"
          solution: |-
            nums := []int{10, 20, 30}
            sum := 0
            for _, num := range nums {
                sum += num
            }
            fmt.Println(sum)  // 60
        - id: v5
          title: Count Items
          description: Create a slice of fruits and print how many items are in it.
          hints:
            - Use <code>len(fruits)</code> to get the count
          solution: |-
            fruits := []string{"apple", "banana", "orange", "grape"}
            fmt.Println(len(fruits))  // 4
        - id: v6
          title: Names List
          description: "Create a slice of names and print each with a greeting: \"Hello, Alice!\""
          hints:
            - Use <code>fmt.Printf("Hello, %s!\n", name)</code>
          solution: |-
            names := []string{"Alice", "Bob", "Charlie"}
            for _, name := range names {
                fmt.Printf("Hello, %s!\n", name)
            }
        - id: v7
          title: Test Scores
          description: "Create a slice of test scores and print each one with its position: \"Test 1: 85\""
          hints:
            - Use the index in the range loop
            - Add 1 to the index for human-readable numbering
          solution: |-
            scores := []int{85, 92, 78, 95}
            for i, score := range scores {
                fmt.Printf("Test %d: %d\n", i+1, score)
            }
        - id: v8
          title: Reverse Print
          description: Create a slice of 3 animals and print them in reverse order using a regular for loop.
          hints:
            - Start from <code>len(animals)-1</code>
            - "Count down: <code>i--</code>"
          solution: |-
            animals := []string{"cat", "dog", "bird"}
            for i := len(animals) - 1; i >= 0; i-- {
                fmt.Println(animals[i])
            }
        - id: v9
          title: Find Maximum
          description: Write <code>func findMax(nums []int) int</code> that returns the largest number in the slice.
          hints:
            - Start with <code>max := nums[0]</code>
            - Use range to compare each number
          solution: |-
            func findMax(nums []int) int {
                max := nums[0]
                for _, n := range nums {
                    if n > max {
                        max = n
                    }
                }
                return max
            }
        - id: v10
          title: Find Minimum
          description: Write <code>func findMin(nums []int) int</code> that returns the smallest number in the slice.
          hints:
            - Start with <code>min := nums[0]</code>
            - "Compare each number: <code>if n < min</code>"
          solution: |-
            func findMin(nums []int) int {
                min := nums[0]
                for _, n := range nums {
                    if n < min {
                        min = n
                    }
                }
                return min
            }
        - id: v11
          title: Calculate Average
          description: Write <code>func average(nums []float64) float64</code> that returns the average of all numbers.
          hints:
            - Sum all numbers first
            - "Divide by length: <code>sum / float64(len(nums))</code>"
          solution: |-
            func average(nums []float64) float64 {
                sum := 0.0
                for _, n := range nums {
                    sum += n
                }
                return sum / float64(len(nums))
            }
        - id: v12
          title: Contains Check
          description: >-
            Write <code>func contains(items []string, target string) bool</code> that returns true if target is in
            items.
          hints:
            - Use range to check each item
            - Return true immediately when found
          solution: |-
            func contains(items []string, target string) bool {
                for _, item := range items {
                    if item == target {
                        return true
                    }
                }
                return false
            }
        - id: v13
          title: First N Elements
          description: >-
            Write <code>func firstN(items []string, n int) []string</code> that returns the first n elements of the
            slice.
          hints:
            - "Use slice syntax: <code>items[:n]</code>"
          solution: |-
            func firstN(items []string, n int) []string {
                return items[:n]
            }
    - id: warmup_4
      concept: Maps
      variants:
        - id: v1
          title: Ages Map
          description: Create a map of names to ages, then print each person's name and age.
          hints:
            - "Map syntax: <code>map[string]int{\"alice\": 30}</code>"
            - "Loop: <code>for name, age := range ages</code>"
          solution: |-
            ages := map[string]int{
                "alice": 30,
                "bob":   25,
            }
            for name, age := range ages {
                fmt.Printf("%s is %d\n", name, age)
            }
        - id: v2
          title: Prices Map
          description: Create a map of items to prices (float64), then print each item and price.
          hints:
            - "Map syntax: <code>map[string]float64{\"apple\": 1.50}</code>"
          solution: |-
            prices := map[string]float64{
                "apple":  1.50,
                "banana": 0.75,
            }
            for item, price := range prices {
                fmt.Printf("%s: $%.2f\n", item, price)
            }
        - id: v3
          title: Capitals Map
          description: Create a map of countries to their capitals, then print each pair.
          hints:
            - "Map syntax: <code>map[string]string{\"France\": \"Paris\"}</code>"
          solution: |-
            capitals := map[string]string{
                "France": "Paris",
                "Japan":  "Tokyo",
            }
            for country, capital := range capitals {
                fmt.Printf("%s: %s\n", country, capital)
            }
        - id: v4
          title: Inventory Count
          description: Create a map of product names to quantities in stock, then print each item and count.
          hints:
            - "Map syntax: <code>map[string]int{\"shirt\": 15}</code>"
          solution: |-
            inventory := map[string]int{
                "shirt": 15,
                "pants": 8,
                "hat":   20,
            }
            for item, count := range inventory {
                fmt.Printf("%s: %d in stock\n", item, count)
            }
        - id: v5
          title: Student Grades
          description: Create a map of student names to their letter grades, then print each student and grade.
          hints:
            - "Map syntax: <code>map[string]string{\"Alice\": \"A\"}</code>"
          solution: |-
            grades := map[string]string{
                "Alice": "A",
                "Bob":   "B",
                "Carol": "A",
            }
            for student, grade := range grades {
                fmt.Printf("%s: %s\n", student, grade)
            }
        - id: v6
          title: Phone Book
          description: Create a map of names to phone numbers, then print each entry.
          hints:
            - "Phone numbers can be strings: <code>\"555-1234\"</code>"
          solution: |-
            phonebook := map[string]string{
                "Alice": "555-1234",
                "Bob":   "555-5678",
            }
            for name, phone := range phonebook {
                fmt.Printf("%s: %s\n", name, phone)
            }
        - id: v7
          title: Menu Prices
          description: Create a map of menu items to their prices (use integers for cents), then print the menu.
          hints:
            - "Store cents as int: 250 for $2.50"
            - Divide by 100.0 when printing
          solution: |-
            menu := map[string]int{
                "burger": 850,
                "fries":  350,
                "soda":   200,
            }
            for item, cents := range menu {
                fmt.Printf("%s: $%.2f\n", item, float64(cents)/100.0)
            }
        - id: v8
          title: Room Numbers
          description: Create a map of employee names to their office room numbers, then print the directory.
          hints:
            - "Map syntax: <code>map[string]int{\"Alice\": 101}</code>"
          solution: |-
            offices := map[string]int{
                "Alice": 101,
                "Bob":   102,
                "Carol": 105,
            }
            for name, room := range offices {
                fmt.Printf("%s - Room %d\n", name, room)
            }
        - id: v9
          title: Most Common Value
          description: >-
            Write <code>func mostCommon(counts map[string]int) string</code> that returns the key with the highest
            value.
          hints:
            - Track max value and corresponding key
            - Loop through map with range
          solution: |-
            func mostCommon(counts map[string]int) string {
                maxKey := ""
                maxVal := 0
                for k, v := range counts {
                    if v > maxVal {
                        maxVal = v
                        maxKey = k
                    }
                }
                return maxKey
            }
        - id: v10
          title: Merge Maps
          description: >-
            Write <code>func mergeMaps(m1, m2 map[string]int) map[string]int</code> that combines both maps (m2
            overwrites m1 on conflicts).
          hints:
            - Create new result map
            - Copy all from m1, then all from m2
          solution: |-
            func mergeMaps(m1, m2 map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range m1 {
                    result[k] = v
                }
                for k, v := range m2 {
                    result[k] = v
                }
                return result
            }
        - id: v11
          title: Filter by Value
          description: >-
            Write <code>func filterByValue(m map[string]int, threshold int) map[string]int</code> that returns only
            entries where value >= threshold.
          hints:
            - Create new map for results
            - Only add entries that meet the condition
          solution: |-
            func filterByValue(m map[string]int, threshold int) map[string]int {
                result := make(map[string]int)
                for k, v := range m {
                    if v >= threshold {
                        result[k] = v
                    }
                }
                return result
            }
        - id: v12
          title: Key Exists Multiple
          description: >-
            Write <code>func hasAllKeys(m map[string]int, keys []string) bool</code> that returns true if all keys exist
            in the map.
          hints:
            - Loop through keys slice
            - "Use comma-ok idiom: <code>_, ok := m[key]</code>"
          solution: |-
            func hasAllKeys(m map[string]int, keys []string) bool {
                for _, key := range keys {
                    if _, ok := m[key]; !ok {
                        return false
                    }
                }
                return true
            }
        - id: v13
          title: Invert Map
          description: Write <code>func invertMap(m map[string]string) map[string]string</code> that swaps keys and values.
          hints:
            - Create new map where values become keys
            - "Loop: <code>result[v] = k</code>"
          solution: |-
            func invertMap(m map[string]string) map[string]string {
                result := make(map[string]string)
                for k, v := range m {
                    result[v] = k
                }
                return result
            }
    - id: warmup_5
      concept: Variables & Assignment
      variants:
        - id: v1
          title: Declare and Print
          description: >-
            Declare a variable <code>name</code> with value "Go", and an integer <code>year</code> with value 2009.
            Print both.
          hints:
            - "Use short declaration: <code>name := \"Go\"</code>"
            - Use <code>fmt.Println(name, year)</code>
          solution: |-
            name := "Go"
            year := 2009
            fmt.Println(name, year)
        - id: v2
          title: Swap Two Variables
          description: Create two variables <code>a := 10</code> and <code>b := 20</code>. Swap their values, then print them.
          hints:
            - "Go allows simultaneous assignment: <code>a, b = b, a</code>"
          solution: |-
            a := 10
            b := 20
            a, b = b, a
            fmt.Println(a, b)  // 20 10
        - id: v3
          title: Type Inference
          description: >-
            Create variables for your age (int), height (float64), and name (string) using short declaration. Print
            their values and types.
          hints:
            - "Go infers types: <code>age := 25</code> is int"
            - Use <code>fmt.Printf("%T", age)</code> to print type
          solution: |-
            age := 25
            height := 5.9
            name := "Alice"
            fmt.Printf("age: %d (%T)\n", age, age)
            fmt.Printf("height: %.1f (%T)\n", height, height)
            fmt.Printf("name: %s (%T)\n", name, name)
        - id: v4
          title: Calculate Area
          description: Create variables for width (5.0) and height (3.0), calculate the area, and print it.
          hints:
            - Area is width * height
            - Use <code>:=</code> for short declaration
          solution: |-
            width := 5.0
            height := 3.0
            area := width * height
            fmt.Println(area)  // 15
        - id: v5
          title: String Concatenation
          description: Create variables for first name and last name, then create and print a full name.
          hints:
            - Concatenate with <code>+</code>
            - Don't forget the space between names
          solution: |-
            firstName := "John"
            lastName := "Doe"
            fullName := firstName + " " + lastName
            fmt.Println(fullName)  // John Doe
        - id: v6
          title: Boolean Logic
          description: Create two boolean variables, then print their AND and OR results.
          hints:
            - "AND: <code>a && b</code>"
            - "OR: <code>a || b</code>"
          solution: |-
            a := true
            b := false
            fmt.Println(a && b)  // false
            fmt.Println(a || b)  // true
        - id: v7
          title: Temperature Conversion
          description: Create a celsius variable (25), convert it to Fahrenheit (F = C * 9/5 + 32), and print both.
          hints:
            - "Formula: <code>fahrenheit := celsius * 9 / 5 + 32</code>"
            - Use float64 for decimal precision
          solution: |-
            celsius := 25.0
            fahrenheit := celsius * 9 / 5 + 32
            fmt.Printf("%.1fC = %.1fF\n", celsius, fahrenheit)  // 25.0C = 77.0F
        - id: v8
          title: Shopping Total
          description: >-
            Create variables for three item prices, calculate the total, then apply a 10% discount and print the final
            price.
          hints:
            - "Total: <code>price1 + price2 + price3</code>"
            - "Discount: <code>total * 0.9</code>"
          solution: |-
            item1 := 10.0
            item2 := 25.5
            item3 := 8.75
            total := item1 + item2 + item3
            final := total * 0.9
            fmt.Printf("Total: $%.2f, After discount: $%.2f\n", total, final)
        - id: v9
          title: Pythagorean Theorem
          description: >-
            Write a program that calculates the hypotenuse c given sides a=3 and b=4 using c = sqrt(a² + b²). Print the
            result.
          hints:
            - Use <code>math.Sqrt()</code> function
            - "Formula: <code>c := math.Sqrt(a*a + b*b)</code>"
          solution: |-
            import "math"

            a := 3.0
            b := 4.0
            c := math.Sqrt(a*a + b*b)
            fmt.Println(c)  // 5
        - id: v10
          title: Compound Interest
          description: >-
            Write a program that calculates compound interest. Given principal=1000, rate=0.05, time=2, calculate amount
            = principal * (1 + rate)^time. Print result.
          hints:
            - Use <code>math.Pow()</code> for exponentiation
            - "Formula: <code>amount := principal * math.Pow(1+rate, time)</code>"
          solution: |-
            import "math"

            principal := 1000.0
            rate := 0.05
            time := 2.0
            amount := principal * math.Pow(1+rate, time)
            fmt.Println(amount)  // 1102.5
        - id: v11
          title: Temperature Conversion
          description: Write a program that converts 100°F to Celsius using the formula C = (F - 32) * 5/9. Print the result.
          hints:
            - Use parentheses for correct order of operations
            - "Formula: <code>celsius := (fahrenheit - 32) * 5 / 9</code>"
          solution: |-
            fahrenheit := 100.0
            celsius := (fahrenheit - 32) * 5 / 9
            fmt.Println(celsius)  // 37.777...
        - id: v12
          title: Circle Circumference
          description: Write a program that calculates the circumference of a circle with radius 7 using C = 2πr. Print the result.
          hints:
            - Use <code>math.Pi</code> constant
            - "Formula: <code>circumference := 2 * math.Pi * radius</code>"
          solution: |-
            import "math"

            radius := 7.0
            circumference := 2 * math.Pi * radius
            fmt.Println(circumference)  // 43.98...
        - id: v13
          title: Distance Formula
          description: >-
            Write a program that calculates distance between points (1,2) and (4,6) using d = sqrt((x2-x1)² + (y2-y1)²).
            Print result.
          hints:
            - "Calculate differences first: <code>dx := x2 - x1</code>"
            - Use <code>math.Sqrt(dx*dx + dy*dy)</code>
          solution: |-
            import "math"

            x1, y1 := 1.0, 2.0
            x2, y2 := 4.0, 6.0
            dx := x2 - x1
            dy := y2 - y1
            dist := math.Sqrt(dx*dx + dy*dy)
            fmt.Println(dist)  // 5
    - id: warmup_6
      concept: Multiple Returns
      variants:
        - id: v1
          title: Divide with Remainder
          description: Write <code>func divMod(a, b int) (int, int)</code> that returns both quotient and remainder.
          hints:
            - "Return two values: <code>return a / b, a % b</code>"
            - "Call with: <code>q, r := divMod(10, 3)</code>"
          solution: |-
            func divMod(a, b int) (int, int) {
                return a / b, a % b
            }

            // Usage:
            q, r := divMod(10, 3)
            fmt.Println(q, r)  // 3 1
        - id: v2
          title: Min and Max
          description: Write <code>func minMax(a, b int) (int, int)</code> that returns the smaller value first, then the larger.
          hints:
            - Use if to compare, then return in order
          solution: |-
            func minMax(a, b int) (int, int) {
                if a < b {
                    return a, b
                }
                return b, a
            }

            // Usage:
            small, big := minMax(5, 3)
            fmt.Println(small, big)  // 3 5
        - id: v3
          title: First and Last
          description: >-
            Write <code>func firstLast(s string) (string, string)</code> that returns the first and last character of a
            string.
          hints:
            - "First char: <code>string(s[0])</code>"
            - "Last char: <code>string(s[len(s)-1])</code>"
          solution: |-
            func firstLast(s string) (string, string) {
                return string(s[0]), string(s[len(s)-1])
            }

            // Usage:
            f, l := firstLast("hello")
            fmt.Println(f, l)  // h o
        - id: v4
          title: Split Name
          description: >-
            Write <code>func splitName(fullName string) (string, string)</code> that splits "John Doe" into first and
            last name (assume one space).
          hints:
            - Find the space with a simple loop or assume fixed position
            - For warmup, you can hardcode the split at index 4 for "John Doe"
          solution: |-
            func splitName(fullName string) (string, string) {
                // Simple version: find space
                for i, ch := range fullName {
                    if ch == ' ' {
                        return fullName[:i], fullName[i+1:]
                    }
                }
                return fullName, ""
            }

            // Usage:
            first, last := splitName("John Doe")
            fmt.Println(first, last)  // John Doe
        - id: v5
          title: Circle Properties
          description: >-
            Write <code>func circleProps(radius float64) (float64, float64)</code> that returns circumference and area
            (use 3.14 for pi).
          hints:
            - "Circumference: <code>2 * pi * radius</code>"
            - "Area: <code>pi * radius * radius</code>"
          solution: |-
            func circleProps(radius float64) (float64, float64) {
                pi := 3.14
                circumference := 2 * pi * radius
                area := pi * radius * radius
                return circumference, area
            }

            // Usage:
            c, a := circleProps(5.0)
            fmt.Printf("Circumference: %.2f, Area: %.2f\n", c, a)
        - id: v6
          title: Bounds Check
          description: >-
            Write <code>func inRange(n, min, max int) (bool, string)</code> that returns true/"in range" if n is between
            min and max, else false/"out of range".
          hints:
            - Check if <code>n >= min && n <= max</code>
            - Return both the boolean and a message
          solution: |-
            func inRange(n, min, max int) (bool, string) {
                if n >= min && n <= max {
                    return true, "in range"
                }
                return false, "out of range"
            }

            // Usage:
            ok, msg := inRange(15, 10, 20)
            fmt.Println(ok, msg)  // true in range
        - id: v7
          title: Quotient and Remainder
          description: Write <code>func divide(dividend, divisor int) (int, int)</code> that returns quotient and remainder.
          hints:
            - "Quotient: <code>dividend / divisor</code>"
            - "Remainder: <code>dividend % divisor</code>"
          solution: |-
            func divide(dividend, divisor int) (int, int) {
                quotient := dividend / divisor
                remainder := dividend % divisor
                return quotient, remainder
            }

            // Usage:
            q, r := divide(17, 5)
            fmt.Println(q, r)  // 3 2
        - id: v8
          title: String Info
          description: >-
            Write <code>func stringInfo(s string) (int, string)</code> that returns the length and the first character
            as a string.
          hints:
            - "Length: <code>len(s)</code>"
            - "First char: <code>string(s[0])</code>"
          solution: |-
            func stringInfo(s string) (int, string) {
                length := len(s)
                firstChar := string(s[0])
                return length, firstChar
            }

            // Usage:
            len, first := stringInfo("hello")
            fmt.Println(len, first)  // 5 h
        - id: v9
          title: Parse Int with Error
          description: >-
            Write <code>func parsePositive(s string) (int, error)</code> that converts string to int. Return error if
            conversion fails or number is negative.
          hints:
            - Use <code>strconv.Atoi(s)</code> to convert
            - Check if result < 0 and return custom error
          solution: |-
            import (
                "errors"
                "strconv"
            )

            func parsePositive(s string) (int, error) {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return 0, err
                }
                if n < 0 {
                    return 0, errors.New("negative number")
                }
                return n, nil
            }
        - id: v10
          title: Validate Range
          description: >-
            Write <code>func validateRange(n, min, max int) (int, bool)</code> that returns (n, true) if n is in
            [min,max], else (0, false).
          hints:
            - "Check condition: <code>n >= min && n <= max</code>"
            - Return the value with a boolean flag
          solution: |-
            func validateRange(n, min, max int) (int, bool) {
                if n >= min && n <= max {
                    return n, true
                }
                return 0, false
            }
        - id: v11
          title: String Split at Position
          description: >-
            Write <code>func splitAt(s string, pos int) (string, string, bool)</code> that splits string at position.
            Return false if pos is out of bounds.
          hints:
            - Check if <code>pos >= 0 && pos <= len(s)</code>
            - "Use slice notation: <code>s[:pos]</code> and <code>s[pos:]</code>"
          solution: |-
            func splitAt(s string, pos int) (string, string, bool) {
                if pos < 0 || pos > len(s) {
                    return "", "", false
                }
                return s[:pos], s[pos:], true
            }
        - id: v12
          title: Find First Occurrence
          description: >-
            Write <code>func findFirst(items []string, target string) (int, bool)</code> that returns (index, true) if
            found, else (-1, false).
          hints:
            - Use range to get both index and value
            - Return immediately when target is found
          solution: |-
            func findFirst(items []string, target string) (int, bool) {
                for i, item := range items {
                    if item == target {
                        return i, true
                    }
                }
                return -1, false
            }
        - id: v13
          title: Min and Max
          description: >-
            Write <code>func minMax(nums []int) (int, int)</code> that returns both the minimum and maximum values in
            one call.
          hints:
            - Initialize both to first element
            - Update both in one loop using range
          solution: |-
            func minMax(nums []int) (int, int) {
                min, max := nums[0], nums[0]
                for _, n := range nums {
                    if n < min {
                        min = n
                    }
                    if n > max {
                        max = n
                    }
                }
                return min, max
            }
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 1
      concept: Variable Declaration
      docLinks:
        - url: https://go.dev/tour/basics/9
          title: "Go Tour: Short variable declarations"
          note: := syntax
        - url: https://go.dev/ref/spec#Short_variable_declarations
          title: "Go Spec: Short variable declarations"
          note: specification details
      patternPrimer:
        bruteForce: Use explicit var declarations with types for every variable.
        bestApproach: Use := for concise declaration inside functions; use var when zero values or package-level scope needed.
        typical: Variable declaration is O(1) — focus on choosing the right declaration style.
      variants:
        - id: v1
          title: Declare and Return Integer
          description: Write <code>func declareInt() int</code> that uses := to declare x as 42 and return it.
          functionSignature: func declareInt() int
          testCases:
            - input: ""
              output: "42"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The := operator declares a new variable and infers its type from the value on the right side. What
                value do you need to assign?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use x := 42 to declare and initialize x, then return it. The compiler infers x is an int from the
                literal 42.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare variable with :=
                2. Return the variable</pre>
          solution: |-
            func declareInt() int {
                x := 42
                return x
            }
          difficulty: 1
        - id: v2
          title: Declare and Return String
          description: >-
            Write <code>func declareString() string</code> that uses := to declare greeting as "hello" and return it.
          functionSignature: func declareString() string
          testCases:
            - input: ""
              output: "\"hello\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Short declarations work with any type. How do you declare a string variable with an initial value
                using :=?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use greeting := "hello" to declare and initialize a string variable. The compiler infers the type
                from the string literal.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare string variable with :=
                2. Return the variable</pre>
          solution: |-
            func declareString() string {
                greeting := "hello"
                return greeting
            }
          difficulty: 1
        - id: v3
          title: Sum Two Variables
          description: >-
            Write <code>func sumTwo() int</code> that declares a := 10 and b := 20 using short declarations, then
            returns their sum.
          functionSignature: func sumTwo() int
          testCases:
            - input: ""
              output: "30"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You can use := multiple times in the same function to declare different variables. How do you
                combine two int values?
            - title: "\U0001F4A1 Hint"
              content: >-
                Declare a := 10 and b := 20 on separate lines, then return a + b. Each := creates a new variable.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare first variable with :=
                2. Declare second variable with :=
                3. Return their sum</pre>
          solution: |-
            func sumTwo() int {
                a := 10
                b := 20
                return a + b
            }
          difficulty: 1
        - id: v4
          title: Boolean Declaration
          description: Write <code>func isGoFun() bool</code> that declares and returns true using :=.
          functionSignature: func isGoFun() bool
          testCases:
            - input: ""
              output: "true"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The := operator works with booleans too. What are the two possible boolean literal values in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use result := true to declare a boolean variable. The compiler infers the bool type from the
                literal true.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare bool variable with :=
                2. Return the variable</pre>
          solution: |-
            func isGoFun() bool {
                result := true
                return result
            }
          difficulty: 1
        - id: v5
          title: Multi-Variable Declaration
          description: >-
            Write <code>func multiDeclare() (string, int, bool)</code> that uses a single := to declare name, age,
            and active simultaneously. Set name="Go", age=15, active=true. Return all three.
          functionSignature: func multiDeclare() (string, int, bool)
          testCases:
            - input: ""
              output: "\"Go\", 15, true"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go lets you declare multiple variables in a single := statement by listing them on the left and
                their values on the right. How would you write this?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use name, age, active := "Go", 15, true to declare all three at once. Each variable gets the type
                inferred from its corresponding value.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare multiple variables: a, b, c := val1, val2, val3
                2. Return all variables</pre>
          solution: |-
            func multiDeclare() (string, int, bool) {
                name, age, active := "Go", 15, true
                return name, age, active
            }
          difficulty: 2
        - id: v6
          title: Zero Value Int
          description: >-
            Write <code>func zeroInt() int</code> that uses <code>var x int</code> (no assignment) and returns x.
            Should return 0 (the zero value for int).
          functionSignature: func zeroInt() int
          testCases:
            - input: ""
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                In Go, every type has a zero value. What is the zero value for int? What happens when you declare a
                variable with var but don't assign it?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use var x int without any assignment. Go automatically initializes it to 0, the zero value for
                integers.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare with var (no initial value)
                2. Return — variable has its zero value</pre>
          solution: |-
            func zeroInt() int {
                var x int
                return x
            }
          difficulty: 2
        - id: v7
          title: Zero Value String
          description: >-
            Write <code>func zeroString() string</code> that uses <code>var s string</code> and returns s. Should
            return "" (the zero value for string).
          functionSignature: func zeroString() string
          testCases:
            - input: ""
              output: "\"\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Every Go type has a zero value. For int it's 0, for bool it's false. What is the zero value for
                string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use var s string without assignment. Go initializes strings to "" (empty string) by default.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare with var (no initial value)
                2. Return — string zero value is ""</pre>
          solution: |-
            func zeroString() string {
                var s string
                return s
            }
          difficulty: 2
        - id: v8
          title: Swap Values
          description: >-
            Write <code>func swap(a, b int) (int, int)</code> that returns b, a (swapped). Use Go's simultaneous
            assignment.
          functionSignature: func swap(a, b int) (int, int)
          testCases:
            - input: "3, 7"
              output: "7, 3"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go functions can return multiple values. How do you return two values in a different order than
                they were received?
            - title: "\U0001F4A1 Hint"
              content: >-
                Simply return b, a. Go evaluates the right side fully before assigning, so no temporary variable is
                needed.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Accept two parameters
                2. Return them in reverse order</pre>
          solution: |-
            func swap(a, b int) (int, int) {
                return b, a
            }
          difficulty: 2
        - id: v9
          title: Reassignment
          description: >-
            Write <code>func reassign() int</code> that declares x := 5, then reassigns x = 10 (note: = not :=),
            and returns x.
          functionSignature: func reassign() int
          testCases:
            - input: ""
              output: "10"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                There's a difference between := (declare and assign) and = (assign only). When do you use each
                one?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use := for the first declaration, then = for reassignment. Using := again on the same variable in
                the same scope would cause an error.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare with :=  (first use)
                2. Reassign with =  (already exists)
                3. Return the variable</pre>
          solution: |-
            func reassign() int {
                x := 5
                x = 10
                return x
            }
          difficulty: 2
        - id: v10
          title: Calculate Expression
          description: >-
            Write <code>func calculate(a, b, c int) int</code> that declares result using := with expression a*b + c
            and returns result.
          functionSignature: func calculate(a, b, c int) int
          testCases:
            - input: "3, 4, 5"
              output: "17"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You can use any expression on the right side of :=. The type of the variable is inferred from the
                result of the expression.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use result := a*b + c. Go follows standard arithmetic precedence, so multiplication happens before
                addition.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare variable with := using an expression
                2. Return the computed result</pre>
          solution: |-
            func calculate(a, b, c int) int {
                result := a*b + c
                return result
            }
          difficulty: 3
        - id: v11
          title: Multiple Assignment Math
          description: >-
            Write <code>func splitSeconds(totalSeconds int) (int, int, int)</code> that converts total seconds to
            hours, minutes, and seconds using := and returns all three.
          functionSignature: func splitSeconds(totalSeconds int) (int, int, int)
          testCases:
            - input: "3661"
              output: "1, 1, 1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To break down seconds, think about integer division and the modulo operator. How many seconds are
                in an hour? In a minute?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use hours := totalSeconds / 3600 for hours. For minutes, take the remainder after removing hours
                and divide by 60. Seconds are the final remainder.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. hours := total / 3600
                2. minutes := (total % 3600) / 60
                3. seconds := total % 60
                4. Return all three</pre>
          solution: |-
            func splitSeconds(totalSeconds int) (int, int, int) {
                hours := totalSeconds / 3600
                minutes := (totalSeconds % 3600) / 60
                seconds := totalSeconds % 60
                return hours, minutes, seconds
            }
          difficulty: 3
        - id: v12
          title: Temperature Conversion
          description: >-
            Write <code>func celsiusToFahrenheit(c float64) float64</code> that declares f := c*9/5 + 32 and
            returns f.
          functionSignature: func celsiusToFahrenheit(c float64) float64
          testCases:
            - input: "100.0"
              output: "212"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The formula to convert Celsius to Fahrenheit is F = C * 9/5 + 32. Since c is already float64, the
                arithmetic will use floating-point division.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use f := c*9.0/5.0 + 32.0. Using float64 literals ensures floating-point arithmetic throughout
                the expression.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare result with := using the formula
                2. Return the result</pre>
          solution: |-
            func celsiusToFahrenheit(c float64) float64 {
                f := c*9.0/5.0 + 32.0
                return f
            }
          difficulty: 3
        - id: v13
          title: Var vs Short Declaration
          description: >-
            Write <code>func initializeAll() (int, string, bool, float64)</code> that uses <code>var</code> for the
            first two (int, string — they'll be zero values 0, "") and := for the last two (bool=true,
            float64=3.14). Return all four.
          functionSignature: func initializeAll() (int, string, bool, float64)
          testCases:
            - input: ""
              output: "0, \"\", true, 3.14"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Sometimes you want a zero value (use var), and sometimes you want a specific initial value (use
                :=). When would you choose one over the other?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use var n int and var s string for zero values. Use b := true and f := 3.14 for explicit values.
                Mix both styles in the same function.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. var for zero-value variables
                2. := for initialized variables
                3. Return all variables</pre>
          solution: |-
            func initializeAll() (int, string, bool, float64) {
                var n int
                var s string
                b := true
                f := 3.14
                return n, s, b, f
            }
          difficulty: 3
    - id: challenge_2
      block: 1
      difficulty: 1
      concept: Type Conversion
      docLinks:
        - url: https://go.dev/tour/basics/13
          title: "Go Tour: Type conversions"
          note: explicit conversion required
        - url: https://pkg.go.dev/strconv
          title: "strconv package"
          note: string/number conversions
      patternPrimer:
        bruteForce: Use separate variables for each type and convert explicitly at every step.
        bestApproach: Convert types at the point of use with Go's T(value) syntax; use strconv for string-number conversions.
        typical: Type conversions are O(1) — the key is knowing which conversion function to use.
      variants:
        - id: v1
          title: Int to Float
          description: Write <code>func intToFloat(n int) float64</code> that converts an int to float64 and returns it.
          functionSignature: func intToFloat(n int) float64
          testCases:
            - input: "42"
              output: "42"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go requires explicit type conversions — no implicit casting. How do you convert one numeric type to
                another?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the target type as a function: float64(n). This explicitly converts the int value to float64.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use T(value) syntax: float64(n)
                2. Return the converted value</pre>
          solution: |-
            func intToFloat(n int) float64 {
                return float64(n)
            }
          difficulty: 1
        - id: v2
          title: Float to Int
          description: >-
            Write <code>func floatToInt(f float64) int</code> that converts a float64 to int (truncates the decimal
            portion).
          functionSignature: func floatToInt(f float64) int
          testCases:
            - input: "3.7"
              output: "3"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Converting float to int truncates (drops) the decimal part — it does not round. What will int(3.9)
                give you?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use int(f) to truncate the float. Remember: 3.7 becomes 3 and 3.2 also becomes 3 — always toward
                zero.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use int(floatValue) to truncate
                2. Return the converted value</pre>
          solution: |-
            func floatToInt(f float64) int {
                return int(f)
            }
          difficulty: 1
        - id: v3
          title: Precise Division
          description: >-
            Write <code>func preciseDivide(a, b int) float64</code> that converts a and b to float64 before dividing
            and returns the result.
          functionSignature: func preciseDivide(a, b int) float64
          testCases:
            - input: "7, 2"
              output: "3.5"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Integer division in Go truncates: 7/2 gives 3, not 3.5. How can you get the precise result?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert both operands to float64 before dividing: float64(a) / float64(b). This ensures
                floating-point division.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Convert both ints to float64
                2. Divide the float64 values
                3. Return the result</pre>
          solution: |-
            func preciseDivide(a, b int) float64 {
                return float64(a) / float64(b)
            }
          difficulty: 1
        - id: v4
          title: Rune to String
          description: Write <code>func runeToString(r rune) string</code> that converts a rune to a string using string().
          functionSignature: func runeToString(r rune) string
          testCases:
            - input: "'A'"
              output: "\"A\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A rune in Go represents a Unicode code point. The string() conversion on a rune produces the
                UTF-8 string for that character.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use string(r) to convert a rune to its string representation. For example, string('A') gives "A".
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use string(rune) to convert
                2. Return the string</pre>
          solution: |-
            func runeToString(r rune) string {
                return string(r)
            }
          difficulty: 1
        - id: v5
          title: Int to String
          description: >-
            Write <code>func intToString(n int) string</code> that uses strconv.Itoa to convert an int to its string
            representation.
          functionSignature: func intToString(n int) string
          testCases:
            - input: "42"
              output: "\"42\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                string(42) gives you "*" (the character with code point 42), not "42". You need a different
                function for numeric-to-string conversion.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strconv.Itoa(n) (Integer to ASCII) from the strconv package. It converts an int to its decimal
                string representation.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Import "strconv"
                2. Use strconv.Itoa(n)
                3. Return the string</pre>
          solution: |-
            func intToString(n int) string {
                return strconv.Itoa(n)
            }
          difficulty: 2
        - id: v6
          title: String to Int
          description: >-
            Write <code>func stringToInt(s string) (int, error)</code> that uses strconv.Atoi to parse a string as
            an int. Return the value and any error.
          functionSignature: func stringToInt(s string) (int, error)
          testCases:
            - input: "\"42\""
              output: "42, nil"
            - input: "\"abc\""
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Parsing a string to a number can fail if the string isn't a valid number. How does Go communicate
                this potential failure?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strconv.Atoi(s) which returns (int, error). If the string can't be parsed, it returns 0 and a
                non-nil error.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Call strconv.Atoi(s)
                2. Return both the value and the error</pre>
          solution: |-
            func stringToInt(s string) (int, error) {
                return strconv.Atoi(s)
            }
          difficulty: 2
        - id: v7
          title: Mixed Arithmetic
          description: >-
            Write <code>func mixedAdd(a int, b float64) float64</code> that adds int a to float64 b by converting a
            first.
          functionSignature: func mixedAdd(a int, b float64) float64
          testCases:
            - input: "3, 4.5"
              output: "7.5"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go doesn't allow arithmetic between different numeric types. You must convert one operand to match
                the other.
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert the int to float64 first: float64(a) + b. Both operands must be the same type for the +
                operator.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Convert int to float64
                2. Add the two float64 values
                3. Return the result</pre>
          solution: |-
            func mixedAdd(a int, b float64) float64 {
                return float64(a) + b
            }
          difficulty: 2
        - id: v8
          title: Byte to Int
          description: Write <code>func byteToInt(b byte) int</code> that converts a byte to an int.
          functionSignature: func byteToInt(b byte) int
          testCases:
            - input: "byte(65)"
              output: "65"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A byte in Go is an alias for uint8. Converting to int widens the value — no data is lost.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use int(b) to convert from byte to int. Since byte is a smaller integer type, this conversion is
                always safe.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use int(byteValue) to widen
                2. Return the int</pre>
          solution: |-
            func byteToInt(b byte) int {
                return int(b)
            }
          difficulty: 2
        - id: v9
          title: Average as Float
          description: >-
            Write <code>func average(nums []int) float64</code> that computes the average of an int slice, returning
            a float64 result.
          functionSignature: func average(nums []int) float64
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "2.5"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                If you sum ints and divide by an int, you get integer division. How do you get a precise float
                result?
            - title: "\U0001F4A1 Hint"
              content: >-
                Sum the slice as an int, then convert both the sum and length to float64 before dividing:
                float64(sum) / float64(len(nums)).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Sum all elements (int)
                2. Convert sum to float64
                3. Convert len to float64
                4. Divide and return</pre>
          solution: |-
            func average(nums []int) float64 {
                sum := 0
                for _, n := range nums {
                    sum += n
                }
                return float64(sum) / float64(len(nums))
            }
          difficulty: 2
        - id: v10
          title: Safe Parse Int
          description: >-
            Write <code>func safeParse(s string, fallback int) int</code> that parses s as int with strconv.Atoi. If
            there is an error, return the fallback value instead.
          functionSignature: func safeParse(s string, fallback int) int
          testCases:
            - input: "\"10\", 0"
              output: "10"
            - input: "\"abc\", -1"
              output: "-1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                strconv.Atoi returns an error when the string can't be parsed. How do you check for and handle
                this error?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use n, err := strconv.Atoi(s). If err != nil, return the fallback. Otherwise return n. This is a
                common Go error handling pattern.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. n, err := strconv.Atoi(s)
                2. if err != nil { return fallback }
                3. return n</pre>
          solution: |-
            func safeParse(s string, fallback int) int {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return fallback
                }
                return n
            }
          difficulty: 3
        - id: v11
          title: Percentage
          description: >-
            Write <code>func percentage(part, total int) float64</code> that calculates what percentage part is of
            total (e.g., 3 of 4 = 75.0). Convert to float64 for precision.
          functionSignature: func percentage(part, total int) float64
          testCases:
            - input: "3, 4"
              output: "75"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To get an accurate percentage, you need floating-point division. What happens if you divide two ints
                in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert both part and total to float64 before dividing, then multiply by 100:
                float64(part) / float64(total) * 100.0.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Convert part and total to float64
                2. Divide part by total
                3. Multiply by 100
                4. Return the percentage</pre>
          solution: |-
            func percentage(part, total int) float64 {
                return float64(part) / float64(total) * 100.0
            }
          difficulty: 3
        - id: v12
          title: Round to Int
          description: >-
            Write <code>func roundToInt(f float64) int</code> that rounds a float64 to the nearest integer. Use
            int(f + 0.5) for positive numbers.
          functionSignature: func roundToInt(f float64) int
          testCases:
            - input: "3.7"
              output: "4"
            - input: "3.2"
              output: "3"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                int() truncates toward zero. How can you add a bias before truncating to achieve rounding behavior?
            - title: "\U0001F4A1 Hint"
              content: >-
                Add 0.5 before converting: int(f + 0.5). For 3.7: int(4.2) = 4. For 3.2: int(3.7) = 3. This
                works correctly for positive numbers.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Add 0.5 to the float
                2. Convert to int (truncates)
                3. Return the rounded value</pre>
          solution: |-
            func roundToInt(f float64) int {
                return int(f + 0.5)
            }
          difficulty: 3
        - id: v13
          title: Parse and Sum
          description: >-
            Write <code>func parseAndSum(a, b string) (int, error)</code> that parses both strings to ints and
            returns their sum. If either parse fails, return 0 and the error.
          functionSignature: func parseAndSum(a, b string) (int, error)
          testCases:
            - input: "\"3\", \"4\""
              output: "7, nil"
            - input: "\"3\", \"abc\""
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to parse two strings, and either one could fail. How do you handle multiple potential
                errors in sequence?
            - title: "\U0001F4A1 Hint"
              content: >-
                Parse each string separately with strconv.Atoi. Check the error after each parse — if either fails,
                return 0 and the error immediately.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. x, err := strconv.Atoi(a)
                2. if err != nil { return 0, err }
                3. y, err := strconv.Atoi(b)
                4. if err != nil { return 0, err }
                5. return x + y, nil</pre>
          solution: |-
            func parseAndSum(a, b string) (int, error) {
                x, err := strconv.Atoi(a)
                if err != nil {
                    return 0, err
                }
                y, err := strconv.Atoi(b)
                if err != nil {
                    return 0, err
                }
                return x + y, nil
            }
          difficulty: 3
    - id: challenge_3
      block: 1
      difficulty: 1
      concept: String Formatting
      docLinks:
        - url: https://pkg.go.dev/fmt
          title: "fmt package"
          note: format verbs reference
        - url: https://go.dev/doc/effective_go#printing
          title: "Effective Go: Printing"
          note: formatting best practices
      patternPrimer:
        bruteForce: Concatenate strings manually with + and strconv conversions.
        bestApproach: Use fmt.Sprintf with format verbs for clean, readable string construction.
        typical: String formatting is O(n) in output length — Sprintf handles type formatting automatically.
      variants:
        - id: v1
          title: Greet by Name
          description: >-
            Write <code>func greet(name string) string</code> that returns "Hello, {name}!" using fmt.Sprintf.
          functionSignature: func greet(name string) string
          testCases:
            - input: "\"Alice\""
              output: "\"Hello, Alice!\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                fmt.Sprintf works like Printf but returns the string instead of printing it. What format verb do
                you use for strings?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("Hello, %s!", name). The %s verb inserts a string value into the format template.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use fmt.Sprintf with %s for strings
                2. Return the formatted string</pre>
          solution: |-
            func greet(name string) string {
                return fmt.Sprintf("Hello, %s!", name)
            }
          difficulty: 1
        - id: v2
          title: Format Age
          description: >-
            Write <code>func formatAge(name string, age int) string</code> that returns "{name} is {age} years old"
            using Sprintf.
          functionSignature: func formatAge(name string, age int) string
          testCases:
            - input: "\"Bob\", 25"
              output: "\"Bob is 25 years old\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Sprintf can take multiple arguments with different types. What format verb do you use for integers?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("%s is %d years old", name, age). The %s verb is for strings and %d is for
                integers.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use %s for string arguments
                2. Use %d for integer arguments
                3. Return fmt.Sprintf result</pre>
          solution: |-
            func formatAge(name string, age int) string {
                return fmt.Sprintf("%s is %d years old", name, age)
            }
          difficulty: 1
        - id: v3
          title: Format Price
          description: >-
            Write <code>func formatPrice(cents int) string</code> that converts cents to a dollar string like
            "$1.50". Use cents/100 for dollars and cents%100 for remaining cents.
          functionSignature: func formatPrice(cents int) string
          testCases:
            - input: "150"
              output: "\"$1.50\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to split cents into dollars and remaining cents. Integer division and modulo can do this.
                How do you ensure two-digit cents like "50" instead of "5"?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("$%d.%02d", cents/100, cents%100). The %02d format pads with zeros to ensure
                two digits for cents.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. dollars := cents / 100
                2. remaining := cents % 100
                3. Format with %02d for zero-padded cents</pre>
          solution: |-
            func formatPrice(cents int) string {
                return fmt.Sprintf("$%d.%02d", cents/100, cents%100)
            }
          difficulty: 1
        - id: v4
          title: Repeat Word
          description: >-
            Write <code>func repeatWord(word string, n int) string</code> that returns the word repeated n times,
            separated by spaces.
          functionSignature: func repeatWord(word string, n int) string
          testCases:
            - input: "\"go\", 3"
              output: "\"go go go\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build a string by repeating a word with spaces between them. How do you avoid a
                trailing space?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop n times, appending the word each iteration. Add a space before each word except the first one
                (check if i > 0).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Initialize result := ""
                2. Loop n times:
                   - If not first, add " "
                   - Add word
                3. Return result</pre>
          solution: |-
            func repeatWord(word string, n int) string {
                result := ""
                for i := 0; i < n; i++ {
                    if i > 0 {
                        result += " "
                    }
                    result += word
                }
                return result
            }
          difficulty: 1
        - id: v5
          title: Format Coordinates
          description: >-
            Write <code>func formatCoord(x, y float64) string</code> that returns "(x, y)" with 2 decimal places.
          functionSignature: func formatCoord(x, y float64) string
          testCases:
            - input: "3.14159, 2.71828"
              output: "\"(3.14, 2.72)\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The %.Nf format verb controls how many decimal places a float is displayed with. What value of N
                gives two decimal places?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("(%.2f, %.2f)", x, y). The %.2f verb formats a float with exactly 2 decimal
                places, rounding as needed.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use %.2f for 2-decimal-place floats
                2. Format both x and y in the template
                3. Return the formatted string</pre>
          solution: |-
            func formatCoord(x, y float64) string {
                return fmt.Sprintf("(%.2f, %.2f)", x, y)
            }
          difficulty: 2
        - id: v6
          title: Zero-Padded Time
          description: >-
            Write <code>func formatTime(h, m, s int) string</code> that returns "HH:MM:SS" with zero-padding.
          functionSignature: func formatTime(h, m, s int) string
          testCases:
            - input: "9, 5, 3"
              output: "\"09:05:03\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Single-digit numbers need a leading zero (9 becomes 09). Which format verb width specifier adds
                leading zeros?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("%02d:%02d:%02d", h, m, s). The %02d format pads integers with zeros to a minimum
                width of 2.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use %02d for zero-padded integers
                2. Separate hours, minutes, seconds with ":"
                3. Return the formatted string</pre>
          solution: |-
            func formatTime(h, m, s int) string {
                return fmt.Sprintf("%02d:%02d:%02d", h, m, s)
            }
          difficulty: 2
        - id: v7
          title: Quote String
          description: >-
            Write <code>func quoteString(s string) string</code> that returns the string with %q formatting (adds
            Go-syntax double quotes).
          functionSignature: func quoteString(s string) string
          testCases:
            - input: "\"hello world\""
              output: "\"\\\"hello world\\\"\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The %q verb produces a Go-syntax quoted string literal, including the surrounding double quotes and
                any necessary escape sequences.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("%q", s). The %q verb adds double quotes around the string and escapes special
                characters inside it.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use %q for Go-quoted strings
                2. Return the formatted result</pre>
          solution: |-
            func quoteString(s string) string {
                return fmt.Sprintf("%q", s)
            }
          difficulty: 2
        - id: v8
          title: Format Percentage
          description: >-
            Write <code>func formatPercent(value float64) string</code> that returns the value formatted as "XX.X%"
            with one decimal place.
          functionSignature: func formatPercent(value float64) string
          testCases:
            - input: "85.678"
              output: "\"85.7%\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To include a literal % character in a Sprintf format string, you need to escape it. How do you
                escape % in a format string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("%.1f%%", value). The %.1f gives one decimal place, and %% produces a literal
                percent sign.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use %.1f for one decimal place
                2. Use %% for a literal % character
                3. Return the formatted string</pre>
          solution: |-
            func formatPercent(value float64) string {
                return fmt.Sprintf("%.1f%%", value)
            }
          difficulty: 2
        - id: v9
          title: Format List
          description: >-
            Write <code>func formatList(items []string) string</code> that formats items as a numbered list:
            "1. item\n2. item\n..."
          functionSignature: func formatList(items []string) string
          testCases:
            - input: "[]string{\"go\", \"rust\", \"python\"}"
              output: "\"1. go\\n2. rust\\n3. python\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build a multi-line string with numbered items. How do you get both the index and value
                from a range loop?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a range loop with index. Add a newline before each item except the first. Use
                fmt.Sprintf("%d. %s", i+1, item) for each line.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Loop with index: for i, item := range items
                2. Add "\n" before each item (except first)
                3. Format each as "%d. %s" (i+1 for 1-based)
                4. Return accumulated result</pre>
          solution: |-
            func formatList(items []string) string {
                result := ""
                for i, item := range items {
                    if i > 0 {
                        result += "\n"
                    }
                    result += fmt.Sprintf("%d. %s", i+1, item)
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Table Row
          description: >-
            Write <code>func tableRow(name string, score int, grade string) string</code> that returns a fixed-width
            formatted row: name left-aligned in 15 chars, score right-aligned in 5 chars, grade right-aligned in 3
            chars. Use %-15s, %5d, %3s.
          functionSignature: func tableRow(name string, score int, grade string) string
          testCases:
            - input: "\"Alice\", 95, \"A\""
              output: "\"Alice           95   A\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Format verbs can include width specifiers. A positive width right-aligns, and a negative width
                (with -) left-aligns. How do you combine these?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("%-15s%5d%3s", name, score, grade). The - flag left-aligns the name, while score
                and grade are right-aligned by default.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. %-15s for left-aligned string (15 wide)
                2. %5d for right-aligned int (5 wide)
                3. %3s for right-aligned string (3 wide)
                4. Return the formatted row</pre>
          solution: |-
            func tableRow(name string, score int, grade string) string {
                return fmt.Sprintf("%-15s%5d%3s", name, score, grade)
            }
          difficulty: 3
        - id: v11
          title: Format Bytes
          description: >-
            Write <code>func formatBytes(bytes int) string</code> that formats a byte count as human-readable:
            less than 1024 returns "X B", less than 1048576 returns "X.XX KB", otherwise returns "X.XX MB".
          functionSignature: func formatBytes(bytes int) string
          testCases:
            - input: "500"
              output: "\"500 B\""
            - input: "1536"
              output: "\"1.50 KB\""
            - input: "2621440"
              output: "\"2.50 MB\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to choose the right unit based on the size. What thresholds separate bytes, kilobytes, and
                megabytes?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use if/else to check thresholds: < 1024 for bytes, < 1048576 for KB, else MB. Divide by the
                appropriate power of 1024 and format with %.2f.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if bytes < 1024: format as "%d B"
                2. else if bytes < 1048576: format as "%.2f KB"
                3. else: format as "%.2f MB"</pre>
          solution: |-
            func formatBytes(bytes int) string {
                if bytes < 1024 {
                    return fmt.Sprintf("%d B", bytes)
                }
                if bytes < 1048576 {
                    return fmt.Sprintf("%.2f KB", float64(bytes)/1024.0)
                }
                return fmt.Sprintf("%.2f MB", float64(bytes)/1048576.0)
            }
          difficulty: 3
        - id: v12
          title: Format Duration
          description: >-
            Write <code>func formatDuration(seconds int) string</code> that formats as "Xh Ym Zs", omitting the
            hours component when zero. E.g., 3661 returns "1h 1m 1s", 120 returns "2m 0s", 45 returns "45s".
          functionSignature: func formatDuration(seconds int) string
          testCases:
            - input: "3661"
              output: "\"1h 1m 1s\""
            - input: "120"
              output: "\"2m 0s\""
            - input: "45"
              output: "\"45s\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Break seconds into hours, minutes, and remaining seconds using division and modulo. Then decide
                which components to include in the output.
            - title: "\U0001F4A1 Hint"
              content: >-
                Calculate h, m, s from the total. If h > 0, include all three. If only m > 0, include minutes and
                seconds. Otherwise just seconds.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. h := seconds / 3600
                2. m := (seconds % 3600) / 60
                3. s := seconds % 60
                4. Build string based on which components > 0</pre>
          solution: |-
            func formatDuration(seconds int) string {
                h := seconds / 3600
                m := (seconds % 3600) / 60
                s := seconds % 60
                if h > 0 {
                    return fmt.Sprintf("%dh %dm %ds", h, m, s)
                }
                if m > 0 {
                    return fmt.Sprintf("%dm %ds", m, s)
                }
                return fmt.Sprintf("%ds", s)
            }
          difficulty: 3
        - id: v13
          title: Format Plural
          description: >-
            Write <code>func formatPlural(count int, singular string) string</code> that returns "1 item" or
            "N items". If count is 1, use the singular form. Otherwise append "s".
          functionSignature: func formatPlural(count int, singular string) string
          testCases:
            - input: "1, \"cat\""
              output: "\"1 cat\""
            - input: "5, \"cat\""
              output: "\"5 cats\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to conditionally add an "s" suffix based on the count. What is the simplest way to check
                for singular vs plural?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if count == 1. If so, use the singular form. Otherwise, append "s" to the singular word.
                Use fmt.Sprintf to combine the count and word.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if count == 1: return "%d %s" (singular)
                2. else: return "%d %ss" (plural with s)</pre>
          solution: |-
            func formatPlural(count int, singular string) string {
                if count == 1 {
                    return fmt.Sprintf("%d %s", count, singular)
                }
                return fmt.Sprintf("%d %ss", count, singular)
            }
          difficulty: 3
    - id: challenge_4
      block: 1
      difficulty: 1
      concept: Function Basics
      docLinks:
        - url: https://go.dev/tour/basics/4
          title: "Go Tour: Functions"
          note: function syntax
        - url: https://go.dev/ref/spec#Function_declarations
          title: "Go Spec: Function declarations"
          note: full specification
      patternPrimer:
        bruteForce: Write separate functions for every operation, even trivial ones.
        bestApproach: Design functions with clear input/output contracts; use same-type parameter shorthand for cleaner signatures.
        typical: Focus on correct signatures, parameter types, and return types.
      variants:
        - id: v1
          title: Double
          description: Write <code>func double(n int) int</code> that returns n * 2.
          functionSignature: func double(n int) int
          testCases:
            - input: "5"
              output: "10"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A function takes input parameters and returns a result. What operation do you need to perform on n?
            - title: "\U0001F4A1 Hint"
              content: >-
                Simply return n * 2. The function signature already specifies it takes an int and returns an int.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Define function with parameter and return type
                2. Return the computed result</pre>
          solution: |-
            func double(n int) int {
                return n * 2
            }
          difficulty: 1
        - id: v2
          title: Is Positive
          description: Write <code>func isPositive(n int) bool</code> that returns true if n is greater than 0.
          functionSignature: func isPositive(n int) bool
          testCases:
            - input: "5"
              output: "true"
            - input: "-3"
              output: "false"
            - input: "0"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A comparison expression like n > 0 already evaluates to a bool. Do you need an if statement?
            - title: "\U0001F4A1 Hint"
              content: >-
                Return the comparison directly: return n > 0. No if/else needed — the comparison itself is a bool
                value.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return a boolean expression directly
                2. No if/else needed for simple conditions</pre>
          solution: |-
            func isPositive(n int) bool {
                return n > 0
            }
          difficulty: 1
        - id: v3
          title: Full Name
          description: >-
            Write <code>func fullName(first, last string) string</code> that returns "{first} {last}". Note the
            same-type parameter shorthand.
          functionSignature: func fullName(first, last string) string
          testCases:
            - input: "\"John\", \"Doe\""
              output: "\"John Doe\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When consecutive parameters share the same type, Go lets you write the type only once. How do you
                concatenate two strings with a space?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use string concatenation: return first + " " + last. The (first, last string) shorthand means both
                parameters are strings.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use same-type shorthand: (a, b type)
                2. Concatenate with + operator
                3. Return the combined string</pre>
          solution: |-
            func fullName(first, last string) string {
                return first + " " + last
            }
          difficulty: 1
        - id: v4
          title: Max of Two
          description: Write <code>func maxOf(a, b int) int</code> that returns the larger of a and b.
          functionSignature: func maxOf(a, b int) int
          testCases:
            - input: "3, 7"
              output: "7"
            - input: "10, 5"
              output: "10"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to compare two values and return the larger one. What control structure lets you choose
                between two options?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use an if statement: if a > b, return a; otherwise return b. Go doesn't have a ternary operator,
                so use if/else.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if a > b { return a }
                2. return b</pre>
          solution: |-
            func maxOf(a, b int) int {
                if a > b {
                    return a
                }
                return b
            }
          difficulty: 1
        - id: v5
          title: Clamp
          description: >-
            Write <code>func clamp(value, min, max int) int</code> that returns the value clamped between min and
            max (returns min if value is below min, max if above max, otherwise value).
          functionSignature: func clamp(value, min, max int) int
          testCases:
            - input: "5, 1, 10"
              output: "5"
            - input: "-3, 0, 100"
              output: "0"
            - input: "150, 0, 100"
              output: "100"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Clamping means restricting a value to a range. You need to check two boundaries — what happens if
                value is below min? Above max?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if value < min (return min), then if value > max (return max), otherwise return value as-is.
                Two if statements cover all cases.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if value < min { return min }
                2. if value > max { return max }
                3. return value</pre>
          solution: |-
            func clamp(value, min, max int) int {
                if value < min {
                    return min
                }
                if value > max {
                    return max
                }
                return value
            }
          difficulty: 2
        - id: v6
          title: Absolute Value
          description: Write <code>func abs(n int) int</code> that returns the absolute value of n.
          functionSignature: func abs(n int) int
          testCases:
            - input: "5"
              output: "5"
            - input: "-7"
              output: "7"
            - input: "0"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The absolute value removes the sign. Positive numbers stay the same, negative numbers become
                positive. How do you negate a number in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                If n is negative, return -n to make it positive. Otherwise return n unchanged. Use the unary minus
                operator.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if n < 0 { return -n }
                2. return n</pre>
          solution: |-
            func abs(n int) int {
                if n < 0 {
                    return -n
                }
                return n
            }
          difficulty: 2
        - id: v7
          title: Is Between
          description: >-
            Write <code>func isBetween(n, low, high int) bool</code> that returns true if low <= n <= high.
          functionSignature: func isBetween(n, low, high int) bool
          testCases:
            - input: "5, 1, 10"
              output: "true"
            - input: "0, 1, 10"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check that n satisfies two conditions simultaneously. What logical operator combines
                two boolean conditions?
            - title: "\U0001F4A1 Hint"
              content: >-
                Return n >= low && n <= high. The && operator ensures both conditions must be true. Return the
                boolean expression directly.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Check n >= low AND n <= high
                2. Return the boolean expression directly</pre>
          solution: |-
            func isBetween(n, low, high int) bool {
                return n >= low && n <= high
            }
          difficulty: 2
        - id: v8
          title: Circle Area
          description: >-
            Write <code>func circleArea(radius float64) float64</code> that returns the area of a circle (pi * r
            squared) using math.Pi.
          functionSignature: func circleArea(radius float64) float64
          testCases:
            - input: "5.0"
              output: "78.53981633974483"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The formula for circle area is pi * r^2. Go's math package provides Pi as a constant. How do you
                square a number in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use math.Pi * radius * radius. Go doesn't have a power operator, so multiply radius by itself.
                Import the "math" package.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Import "math"
                2. Return math.Pi * radius * radius</pre>
          solution: |-
            func circleArea(radius float64) float64 {
                return math.Pi * radius * radius
            }
          difficulty: 2
        - id: v9
          title: Initial
          description: >-
            Write <code>func initial(name string) string</code> that returns the first character of name as a
            string. Use string(name[0]).
          functionSignature: func initial(name string) string
          testCases:
            - input: "\"Alice\""
              output: "\"A\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Indexing a string with [0] gives you a byte, not a string. How do you convert a byte back to a
                string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use string(name[0]) to get the first byte and convert it to a single-character string. This works
                for ASCII characters.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Access first byte: name[0]
                2. Convert to string: string(name[0])
                3. Return the result</pre>
          solution: |-
            func initial(name string) string {
                return string(name[0])
            }
          difficulty: 2
        - id: v10
          title: Apply Discount
          description: >-
            Write <code>func applyDiscount(price float64, discountPercent float64) float64</code> that applies a
            discount percentage to price and returns the discounted price.
          functionSignature: func applyDiscount(price, discountPercent float64) float64
          testCases:
            - input: "100.0, 20.0"
              output: "80"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A 20% discount means you pay 80% of the original price. How do you express "100% minus the
                discount" as a multiplier?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use price * (1 - discountPercent/100). Dividing the percent by 100 converts it to a decimal
                fraction, then subtract from 1 to get the remaining price ratio.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Convert percent to decimal: discountPercent / 100
                2. Calculate multiplier: 1 - decimal
                3. Return price * multiplier</pre>
          solution: |-
            func applyDiscount(price, discountPercent float64) float64 {
                return price * (1 - discountPercent/100)
            }
          difficulty: 3
        - id: v11
          title: Midpoint
          description: >-
            Write <code>func midpoint(x1, y1, x2, y2 float64) (float64, float64)</code> that returns the midpoint
            of two 2D points.
          functionSignature: func midpoint(x1, y1, x2, y2 float64) (float64, float64)
          testCases:
            - input: "0.0, 0.0, 10.0, 10.0"
              output: "5, 5"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The midpoint formula averages the x-coordinates and y-coordinates separately. How do you return two
                values from a Go function?
            - title: "\U0001F4A1 Hint"
              content: >-
                Return (x1+x2)/2, (y1+y2)/2. Go functions can return multiple values — list both return types in
                parentheses in the signature.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. midX := (x1 + x2) / 2
                2. midY := (y1 + y2) / 2
                3. Return both values</pre>
          solution: |-
            func midpoint(x1, y1, x2, y2 float64) (float64, float64) {
                return (x1 + x2) / 2, (y1 + y2) / 2
            }
          difficulty: 3
        - id: v12
          title: Fizz Buzz Single
          description: >-
            Write <code>func fizzBuzz(n int) string</code> that returns "FizzBuzz" if divisible by 15, "Fizz" if
            divisible by 3, "Buzz" if divisible by 5, else the number as a string.
          functionSignature: func fizzBuzz(n int) string
          testCases:
            - input: "15"
              output: "\"FizzBuzz\""
            - input: "3"
              output: "\"Fizz\""
            - input: "5"
              output: "\"Buzz\""
            - input: "7"
              output: "\"7\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The order of checks matters. Why should you check divisible-by-15 before checking divisible-by-3 or
                divisible-by-5?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check n%15 == 0 first (both 3 and 5), then n%3 == 0, then n%5 == 0. For the default case, convert
                n to string with strconv.Itoa(n).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if n%15 == 0: return "FizzBuzz"
                2. if n%3 == 0: return "Fizz"
                3. if n%5 == 0: return "Buzz"
                4. return strconv.Itoa(n)</pre>
          solution: |-
            func fizzBuzz(n int) string {
                if n%15 == 0 {
                    return "FizzBuzz"
                }
                if n%3 == 0 {
                    return "Fizz"
                }
                if n%5 == 0 {
                    return "Buzz"
                }
                return strconv.Itoa(n)
            }
          difficulty: 3
        - id: v13
          title: Leap Year
          description: >-
            Write <code>func isLeapYear(year int) bool</code> that returns true if year is a leap year (divisible by
            4, but not by 100 unless also divisible by 400).
          functionSignature: func isLeapYear(year int) bool
          testCases:
            - input: "2000"
              output: "true"
            - input: "1900"
              output: "false"
            - input: "2024"
              output: "true"
            - input: "2023"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The leap year rule has three conditions combined with AND and OR. How do you express "divisible by 4
                AND (not divisible by 100 OR divisible by 400)"?
            - title: "\U0001F4A1 Hint"
              content: >-
                Return year%4 == 0 && (year%100 != 0 || year%400 == 0). Use parentheses to group the OR condition
                correctly.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Check divisible by 4: year%4 == 0
                2. AND not divisible by 100: year%100 != 0
                3. OR divisible by 400: year%400 == 0
                4. Return the combined boolean expression</pre>
          solution: |-
            func isLeapYear(year int) bool {
                return year%4 == 0 && (year%100 != 0 || year%400 == 0)
            }
          difficulty: 3
    - id: challenge_5
      block: 1
      difficulty: 1
      concept: "Multiple Returns"
      docLinks:
        - url: https://go.dev/tour/basics/6
          title: "Go Tour: Multiple results"
          note: returning multiple values
        - url: https://go.dev/doc/effective_go#multiple-returns
          title: "Effective Go: Multiple return values"
          note: idiomatic usage
      patternPrimer:
        bruteForce: Use structs or global variables to return multiple pieces of data.
        bestApproach: Use Go's native multiple return values for clean, expressive function signatures.
        typical: Multiple returns add no overhead — they are a core Go idiom.
      variants:
        - id: v1
          title: Min and Max
          description: >-
            Write <code>func minMax(a, b int) (int, int)</code> that returns the smaller value first, then the larger.
          functionSignature: func minMax(a, b int) (int, int)
          testCases:
            - input: "3, 7"
              output: "3, 7"
            - input: "10, 2"
              output: "2, 10"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to return two values. Which one should come first? Think about how to compare
                two numbers and decide the order.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use an if statement to check which is smaller. Return in the correct order for each case.
                Go lets you return two values separated by a comma.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Compare a and b
                2. If a < b: return a, b
                3. Otherwise: return b, a</pre>
          solution: |-
            func minMax(a, b int) (int, int) {
                if a < b {
                    return a, b
                }
                return b, a
            }
          difficulty: 1
        - id: v2
          title: Name Parts
          description: >-
            Write <code>func nameParts(full string) (string, string)</code> that splits "First Last" at the space
            and returns the first name and last name. Assume exactly one space.
          functionSignature: func nameParts(full string) (string, string)
          testCases:
            - input: "\"John Doe\""
              output: "\"John\", \"Doe\""
            - input: "\"Jane Smith\""
              output: "\"Jane\", \"Smith\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to find where the space is in the string. Once you know the position, how can you
                extract the part before and after it?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strings.Index(full, " ") to find the space position, then slice the string. Or use
                strings.Cut(full, " ") which returns both parts and a boolean.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Find the space position with strings.Cut or strings.Index
                2. Extract substring before the space (first name)
                3. Extract substring after the space (last name)
                4. Return both</pre>
          solution: |-
            func nameParts(full string) (string, string) {
                first, last, _ := strings.Cut(full, " ")
                return first, last
            }
          difficulty: 1
        - id: v3
          title: Divide with Remainder
          description: >-
            Write <code>func divmod(a, b int) (int, int)</code> that returns the quotient and remainder of
            dividing a by b.
          functionSignature: func divmod(a, b int) (int, int)
          testCases:
            - input: "7, 3"
              output: "2, 1"
            - input: "10, 4"
              output: "2, 2"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go has two operators for division: one gives the whole number result, the other gives what's
                left over. What are they?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use / for integer division (quotient) and % for the modulo (remainder). Return both values
                in a single return statement.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Compute quotient: a / b
                2. Compute remainder: a % b
                3. Return quotient, remainder</pre>
          solution: |-
            func divmod(a, b int) (int, int) {
                return a / b, a % b
            }
          difficulty: 1
        - id: v4
          title: Sum and Count
          description: >-
            Write <code>func sumAndCount(nums []int) (int, int)</code> that returns the sum and the count of
            elements in the slice.
          functionSignature: func sumAndCount(nums []int) (int, int)
          testCases:
            - input: "[]int{1, 2, 3}"
              output: "6, 3"
            - input: "[]int{10, 20}"
              output: "30, 2"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                One of these values requires a loop to compute, the other is built into Go slices. Which is
                which?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a loop to sum the elements. Use len(nums) for the count. Return both together.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Initialize sum := 0
                2. Loop through nums, adding each to sum
                3. Return sum, len(nums)</pre>
          solution: |-
            func sumAndCount(nums []int) (int, int) {
                sum := 0
                for _, n := range nums {
                    sum += n
                }
                return sum, len(nums)
            }
          difficulty: 1
        - id: v5
          title: First and Last
          description: >-
            Write <code>func firstLast(s string) (byte, byte)</code> that returns the first and last byte of a
            string.
          functionSignature: func firstLast(s string) (byte, byte)
          testCases:
            - input: "\"hello\""
              output: "'h', 'o'"
            - input: "\"Go\""
              output: "'G', 'o'"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Strings in Go can be indexed like arrays to get individual bytes. How do you access the first
                element? How about the last?
            - title: "\U0001F4A1 Hint"
              content: >-
                The first byte is s[0]. The last byte is s[len(s)-1]. Return both values together.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Get first byte: s[0]
                2. Get last byte: s[len(s)-1]
                3. Return both</pre>
          solution: |-
            func firstLast(s string) (byte, byte) {
                return s[0], s[len(s)-1]
            }
          difficulty: 2
        - id: v6
          title: Safe Divide
          description: >-
            Write <code>func safeDivide(a, b float64) (float64, error)</code> that divides a by b. Return an
            error if b is zero.
          functionSignature: func safeDivide(a, b float64) (float64, error)
          testCases:
            - input: "10.0, 3.0"
              output: "3.3333333333333335, nil"
            - input: "10.0, 0.0"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Division by zero is undefined. You need to check for this case before dividing. What should
                you return when b is zero?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if b == 0 first. If so, return 0 and an error created with errors.New(). Otherwise,
                return the result and nil for the error.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If b == 0: return 0, errors.New("division by zero")
                2. Otherwise: return a / b, nil</pre>
          solution: |-
            func safeDivide(a, b float64) (float64, error) {
                if b == 0 {
                    return 0, errors.New("division by zero")
                }
                return a / b, nil
            }
          difficulty: 2
        - id: v7
          title: Sum and Average
          description: >-
            Write <code>func sumAndAvg(nums []int) (int, float64)</code> that returns the sum as an int and the
            average as a float64.
          functionSignature: func sumAndAvg(nums []int) (int, float64)
          testCases:
            - input: "[]int{10, 20, 30}"
              output: "60, 20.0"
            - input: "[]int{1, 2, 3, 4}"
              output: "10, 2.5"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The average is the sum divided by the count. But you need a float64 result from two ints.
                How do you handle that in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                Calculate the sum first by looping. Then compute the average by converting both sum and
                length to float64 before dividing.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Calculate sum with a loop
                2. Average = float64(sum) / float64(len(nums))
                3. Return sum, average</pre>
          solution: |-
            func sumAndAvg(nums []int) (int, float64) {
                sum := 0
                for _, n := range nums {
                    sum += n
                }
                return sum, float64(sum) / float64(len(nums))
            }
          difficulty: 2
        - id: v8
          title: Head and Tail
          description: >-
            Write <code>func headTail(nums []int) (int, []int)</code> that returns the first element and the
            remaining slice.
          functionSignature: func headTail(nums []int) (int, []int)
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "1, []int{2, 3, 4}"
            - input: "[]int{10, 20}"
              output: "10, []int{20}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The head is a single element and the tail is a slice. How do you get everything except the
                first element from a slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                The first element is nums[0]. The tail is nums[1:] which gives everything from index 1
                onward. Return both.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Head = nums[0]
                2. Tail = nums[1:]
                3. Return head, tail</pre>
          solution: |-
            func headTail(nums []int) (int, []int) {
                return nums[0], nums[1:]
            }
          difficulty: 2
        - id: v9
          title: Bounds
          description: >-
            Write <code>func bounds(nums []int) (int, int)</code> that finds and returns the minimum and maximum
            values of a slice.
          functionSignature: func bounds(nums []int) (int, int)
          testCases:
            - input: "[]int{3, 1, 4, 1, 5}"
              output: "1, 5"
            - input: "[]int{7, 2, 9, 4}"
              output: "2, 9"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to track two values as you scan through the slice. What should you initialize them
                to?
            - title: "\U0001F4A1 Hint"
              content: >-
                Initialize both min and max to the first element. Loop through the rest and update min when
                you find something smaller, max when you find something larger.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. min, max := nums[0], nums[0]
                2. For each element in nums:
                   - If element < min: min = element
                   - If element > max: max = element
                3. Return min, max</pre>
          solution: |-
            func bounds(nums []int) (int, int) {
                min, max := nums[0], nums[0]
                for _, n := range nums[1:] {
                    if n < min {
                        min = n
                    }
                    if n > max {
                        max = n
                    }
                }
                return min, max
            }
          difficulty: 2
        - id: v10
          title: Lookup with Found
          description: >-
            Write <code>func lookup(names []string, target string) (int, bool)</code> that finds target in names.
            Return (index, true) if found, or (-1, false) if not.
          functionSignature: func lookup(names []string, target string) (int, bool)
          testCases:
            - input: "[]string{\"a\", \"b\", \"c\"}, \"b\""
              output: "1, true"
            - input: "[]string{\"a\", \"b\", \"c\"}, \"z\""
              output: "-1, false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a linear search that returns two things: where the item is and whether it was found.
                What should you return if you finish the loop without finding it?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a for loop with range to get both index and value. Compare each value to target. If
                found, return immediately with the index and true.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. For i, name := range names:
                   - If name == target: return i, true
                2. After loop: return -1, false</pre>
          solution: |-
            func lookup(names []string, target string) (int, bool) {
                for i, name := range names {
                    if name == target {
                        return i, true
                    }
                }
                return -1, false
            }
          difficulty: 3
        - id: v11
          title: Parse Score
          description: >-
            Write <code>func parseScore(s string) (int, string, error)</code> that parses a string in "85/A"
            format. Return the number, the letter grade, and an error if the format is invalid.
          functionSignature: func parseScore(s string) (int, string, error)
          testCases:
            - input: "\"85/A\""
              output: "85, \"A\", nil"
            - input: "\"bad\""
              output: "0, \"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to split the string at "/" and then convert the first part to a number. What
                happens if there is no "/" or the number part is not valid?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strings.Cut(s, "/") to split at the slash. It returns (before, after, found). Then use
                strconv.Atoi on the number part. Check errors at each step.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Split string at "/" using strings.Cut
                2. If no "/" found: return 0, "", error
                3. Parse number part with strconv.Atoi
                4. If parse fails: return 0, "", error
                5. Return number, grade, nil</pre>
          solution: |-
            func parseScore(s string) (int, string, error) {
                numStr, grade, ok := strings.Cut(s, "/")
                if !ok {
                    return 0, "", errors.New("invalid format: missing /")
                }
                num, err := strconv.Atoi(numStr)
                if err != nil {
                    return 0, "", fmt.Errorf("invalid number: %w", err)
                }
                return num, grade, nil
            }
          difficulty: 3
        - id: v12
          title: Statistics
          description: >-
            Write <code>func stats(nums []int) (int, int, float64)</code> that returns the minimum, maximum,
            and average of the slice.
          functionSignature: func stats(nums []int) (int, int, float64)
          testCases:
            - input: "[]int{2, 4, 6, 8}"
              output: "2, 8, 5.0"
            - input: "[]int{1, 3, 5}"
              output: "1, 5, 3.0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need three pieces of information from one pass through the slice. Can you track min,
                max, and sum all in the same loop?
            - title: "\U0001F4A1 Hint"
              content: >-
                Initialize min and max to nums[0] and sum to 0. In one loop, update min and max as needed,
                and add to sum. Compute the average after the loop.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. min, max := nums[0], nums[0]; sum := 0
                2. For each n in nums:
                   - If n < min: min = n
                   - If n > max: max = n
                   - sum += n
                3. avg := float64(sum) / float64(len(nums))
                4. Return min, max, avg</pre>
          solution: |-
            func stats(nums []int) (int, int, float64) {
                min, max := nums[0], nums[0]
                sum := 0
                for _, n := range nums {
                    if n < min {
                        min = n
                    }
                    if n > max {
                        max = n
                    }
                    sum += n
                }
                return min, max, float64(sum) / float64(len(nums))
            }
          difficulty: 3
        - id: v13
          title: Longest and Shortest
          description: >-
            Write <code>func longestShortest(words []string) (string, string)</code> that returns the longest
            and shortest strings from a slice.
          functionSignature: func longestShortest(words []string) (string, string)
          testCases:
            - input: "[]string{\"go\", \"python\", \"c\"}"
              output: "\"python\", \"c\""
            - input: "[]string{\"hello\", \"hi\", \"hey\"}"
              output: "\"hello\", \"hi\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is like finding min and max, but instead of comparing numbers, you are comparing string
                lengths. What do you initialize your tracking variables to?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with longest and shortest both set to the first word. Loop through and compare
                len(word) to update each tracker.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. longest, shortest := words[0], words[0]
                2. For each word in words:
                   - If len(word) > len(longest): longest = word
                   - If len(word) < len(shortest): shortest = word
                3. Return longest, shortest</pre>
          solution: |-
            func longestShortest(words []string) (string, string) {
                longest, shortest := words[0], words[0]
                for _, word := range words[1:] {
                    if len(word) > len(longest) {
                        longest = word
                    }
                    if len(word) < len(shortest) {
                        shortest = word
                    }
                }
                return longest, shortest
            }
          difficulty: 3
    - id: challenge_6
      block: 1
      difficulty: 2
      concept: "Error Handling"
      docLinks:
        - url: https://go.dev/blog/error-handling-and-go
          title: "Go Blog: Error handling and Go"
          note: idiomatic error patterns
        - url: https://go.dev/tour/methods/19
          title: "Go Tour: Errors"
          note: error interface
      patternPrimer:
        bruteForce: Use panics or ignore errors entirely.
        bestApproach: Return errors as values; check err != nil immediately after each call that can fail.
        typical: Error handling adds minimal overhead — the pattern is if err != nil { return ..., err }.
      variants:
        - id: v1
          title: Validate Age
          description: >-
            Write <code>func validateAge(age int) error</code> that returns an error if age is less than 0 or
            greater than 150, and nil otherwise.
          functionSignature: func validateAge(age int) error
          testCases:
            - input: "25"
              output: "nil"
            - input: "-1"
              output: "error"
            - input: "200"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check if a value falls outside an acceptable range. What are the two boundary
                conditions?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use errors.New() to create an error value. Check if age < 0 or age > 150. If either is
                true, return the error. Otherwise return nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If age < 0 or age > 150:
                   - return errors.New("invalid age")
                2. Return nil</pre>
          solution: |-
            func validateAge(age int) error {
                if age < 0 || age > 150 {
                    return errors.New("invalid age")
                }
                return nil
            }
          difficulty: 1
        - id: v2
          title: Safe Square Root
          description: >-
            Write <code>func safeSqrt(n float64) (float64, error)</code> that returns an error if n is negative,
            otherwise returns math.Sqrt(n).
          functionSignature: func safeSqrt(n float64) (float64, error)
          testCases:
            - input: "4.0"
              output: "2.0, nil"
            - input: "-1.0"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Square roots of negative numbers are not real numbers. You need to guard against this case
                before calling math.Sqrt.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if n < 0 first. If so, return 0 and an error. Otherwise, return math.Sqrt(n) and nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If n < 0: return 0, errors.New("negative number")
                2. Return math.Sqrt(n), nil</pre>
          solution: |-
            func safeSqrt(n float64) (float64, error) {
                if n < 0 {
                    return 0, errors.New("negative number")
                }
                return math.Sqrt(n), nil
            }
          difficulty: 1
        - id: v3
          title: Non-Empty String
          description: >-
            Write <code>func requireNonEmpty(s string) (string, error)</code> that returns an error if s is
            empty, otherwise returns s.
          functionSignature: func requireNonEmpty(s string) (string, error)
          testCases:
            - input: "\"hello\""
              output: "\"hello\", nil"
            - input: "\"\""
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you check if a string is empty in Go? What is the zero value for a string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Compare s to "" or check len(s) == 0. If empty, return the empty string and an error.
                Otherwise return s and nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If s == "": return "", errors.New("empty string")
                2. Return s, nil</pre>
          solution: |-
            func requireNonEmpty(s string) (string, error) {
                if s == "" {
                    return "", errors.New("empty string")
                }
                return s, nil
            }
          difficulty: 1
        - id: v4
          title: Positive Only
          description: >-
            Write <code>func positiveOnly(n int) (int, error)</code> that returns an error if n is less than or
            equal to 0.
          functionSignature: func positiveOnly(n int) (int, error)
          testCases:
            - input: "5"
              output: "5, nil"
            - input: "0"
              output: "0, error"
            - input: "-3"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Positive means strictly greater than zero. Both zero and negative numbers should be
                rejected.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if n <= 0. If so, return 0 and an error. Otherwise return n and nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If n <= 0: return 0, errors.New("must be positive")
                2. Return n, nil</pre>
          solution: |-
            func positiveOnly(n int) (int, error) {
                if n <= 0 {
                    return 0, errors.New("must be positive")
                }
                return n, nil
            }
          difficulty: 1
        - id: v5
          title: Validate Range
          description: >-
            Write <code>func validateRange(n, min, max int) error</code> that returns an error with a
            descriptive message if n is outside the [min, max] range.
          functionSignature: func validateRange(n, min, max int) error
          testCases:
            - input: "5, 1, 10"
              output: "nil"
            - input: "15, 1, 10"
              output: "error"
            - input: "0, 1, 10"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A value is in range if it's greater than or equal to min AND less than or equal to max.
                When is it out of range?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Errorf to include the actual values in the error message. Check n < min or n > max.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If n < min or n > max:
                   - return fmt.Errorf("value %d out of range [%d, %d]", n, min, max)
                2. Return nil</pre>
          solution: |-
            func validateRange(n, min, max int) error {
                if n < min || n > max {
                    return fmt.Errorf("value %d out of range [%d, %d]", n, min, max)
                }
                return nil
            }
          difficulty: 2
        - id: v6
          title: Divide or Error
          description: >-
            Write <code>func divideOrError(a, b int) (int, error)</code> that performs integer division of a by
            b. Return an error if b is zero.
          functionSignature: func divideOrError(a, b int) (int, error)
          testCases:
            - input: "10, 3"
              output: "3, nil"
            - input: "10, 0"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Division by zero will cause a runtime panic in Go. You need to prevent this by checking
                before dividing.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if b == 0 before dividing. If so, return 0 and an error. Otherwise return the result
                of a / b and nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If b == 0: return 0, errors.New("division by zero")
                2. Return a / b, nil</pre>
          solution: |-
            func divideOrError(a, b int) (int, error) {
                if b == 0 {
                    return 0, errors.New("division by zero")
                }
                return a / b, nil
            }
          difficulty: 2
        - id: v7
          title: Parse Positive Int
          description: >-
            Write <code>func parsePositive(s string) (int, error)</code> that parses a string to an int and
            verifies it is positive. Return an error for invalid input or non-positive numbers.
          functionSignature: func parsePositive(s string) (int, error)
          testCases:
            - input: "\"42\""
              output: "42, nil"
            - input: "\"-5\""
              output: "0, error"
            - input: "\"abc\""
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                There are two things that can go wrong: the string might not be a valid number, or the
                number might not be positive. You need to check both.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strconv.Atoi to parse. If err != nil, return it. Then check if the result is positive.
                This is the "check error, then continue" pattern.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. n, err := strconv.Atoi(s)
                2. If err != nil: return 0, err
                3. If n <= 0: return 0, errors.New("not positive")
                4. Return n, nil</pre>
          solution: |-
            func parsePositive(s string) (int, error) {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return 0, err
                }
                if n <= 0 {
                    return 0, errors.New("not positive")
                }
                return n, nil
            }
          difficulty: 2
        - id: v8
          title: Lookup or Error
          description: >-
            Write <code>func lookupName(names map[string]int, key string) (int, error)</code> that looks up a
            key in the map. Return an error if the key is not found.
          functionSignature: func lookupName(names map[string]int, key string) (int, error)
          testCases:
            - input: "map[string]int{\"alice\": 30, \"bob\": 25}, \"alice\""
              output: "30, nil"
            - input: "map[string]int{\"alice\": 30, \"bob\": 25}, \"dave\""
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go maps return a second value that tells you if the key existed. How do you use this
                comma-ok idiom to detect missing keys?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use v, ok := names[key]. If !ok, the key was not found — return an error. Otherwise return v
                and nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. v, ok := names[key]
                2. If !ok: return 0, fmt.Errorf("key %q not found", key)
                3. Return v, nil</pre>
          solution: |-
            func lookupName(names map[string]int, key string) (int, error) {
                v, ok := names[key]
                if !ok {
                    return 0, fmt.Errorf("key %q not found", key)
                }
                return v, nil
            }
          difficulty: 2
        - id: v9
          title: Validate Email
          description: >-
            Write <code>func validateEmail(email string) error</code> that returns an error if the email is
            empty or does not contain an "@" symbol.
          functionSignature: func validateEmail(email string) error
          testCases:
            - input: "\"user@example.com\""
              output: "nil"
            - input: "\"invalid\""
              output: "error"
            - input: "\"\""
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                There are two validation checks: the string must not be empty, and it must contain "@".
                Order matters — check the simplest condition first.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if email == "" first, then use strings.Contains(email, "@") to verify the @ symbol is
                present. Return different error messages for each case.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If email == "": return errors.New("empty email")
                2. If !strings.Contains(email, "@"):
                   - return errors.New("missing @")
                3. Return nil</pre>
          solution: |-
            func validateEmail(email string) error {
                if email == "" {
                    return errors.New("empty email")
                }
                if !strings.Contains(email, "@") {
                    return errors.New("missing @")
                }
                return nil
            }
          difficulty: 2
        - id: v10
          title: Chain Validation
          description: >-
            Write <code>func validateUser(name string, age int) error</code> that validates the name is
            non-empty AND the age is between 0 and 150. Return the first error found.
          functionSignature: func validateUser(name string, age int) error
          testCases:
            - input: "\"Alice\", 25"
              output: "nil"
            - input: "\"\", 25"
              output: "error"
            - input: "\"Alice\", -1"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you have multiple things to validate, check them one at a time and return early on the
                first failure. This is the "guard clause" pattern.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check name first: if empty, return error. Then check age: if out of range, return error.
                If both pass, return nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If name == "": return errors.New("name required")
                2. If age < 0 or age > 150: return errors.New("invalid age")
                3. Return nil</pre>
          solution: |-
            func validateUser(name string, age int) error {
                if name == "" {
                    return errors.New("name required")
                }
                if age < 0 || age > 150 {
                    return errors.New("invalid age")
                }
                return nil
            }
          difficulty: 3
        - id: v11
          title: Safe Get Element
          description: >-
            Write <code>func safeGet(nums []int, index int) (int, error)</code> that returns the element at the
            given index, or an error if the index is out of bounds.
          functionSignature: func safeGet(nums []int, index int) (int, error)
          testCases:
            - input: "[]int{10, 20, 30}, 1"
              output: "20, nil"
            - input: "[]int{10, 20, 30}, 5"
              output: "0, error"
            - input: "[]int{10, 20, 30}, -1"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Accessing a slice out of bounds causes a panic in Go. You need to check the bounds yourself
                before accessing the element. What are the valid index values?
            - title: "\U0001F4A1 Hint"
              content: >-
                Valid indices are 0 to len(nums)-1. Check if index < 0 or index >= len(nums). If out of
                bounds, return an error. Otherwise return the element.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If index < 0 or index >= len(nums):
                   - return 0, fmt.Errorf("index %d out of bounds", index)
                2. Return nums[index], nil</pre>
          solution: |-
            func safeGet(nums []int, index int) (int, error) {
                if index < 0 || index >= len(nums) {
                    return 0, fmt.Errorf("index %d out of bounds", index)
                }
                return nums[index], nil
            }
          difficulty: 3
        - id: v12
          title: Process Pipeline
          description: >-
            Write <code>func processValue(s string) (float64, error)</code> that parses a string to an int,
            verifies it is non-negative, then converts to float64 and divides by 100. Return an error at any
            step that fails.
          functionSignature: func processValue(s string) (float64, error)
          testCases:
            - input: "\"250\""
              output: "2.5, nil"
            - input: "\"-5\""
              output: "0, error"
            - input: "\"abc\""
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a multi-step pipeline where each step can fail. You need to check for errors after
                each operation before proceeding to the next.
            - title: "\U0001F4A1 Hint"
              content: >-
                First parse with strconv.Atoi (check error). Then check if negative (return error). Finally
                convert and divide. Each step has an if err != nil check.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. n, err := strconv.Atoi(s)
                2. If err != nil: return 0, err
                3. If n < 0: return 0, errors.New("negative")
                4. Return float64(n) / 100.0, nil</pre>
          solution: |-
            func processValue(s string) (float64, error) {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return 0, err
                }
                if n < 0 {
                    return 0, errors.New("negative value")
                }
                return float64(n) / 100.0, nil
            }
          difficulty: 3
        - id: v13
          title: Format Error
          description: >-
            Write <code>func safeDivideFormat(a, b int) (string, error)</code> that divides a by b and returns
            a formatted result string "X / Y = Z", or an error if b is zero.
          functionSignature: func safeDivideFormat(a, b int) (string, error)
          testCases:
            - input: "10, 3"
              output: "\"10 / 3 = 3\", nil"
            - input: "10, 0"
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to combine error checking with string formatting. Check for the error case first,
                then format the successful result.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check b == 0 first and return an error. Otherwise use fmt.Sprintf to build the result
                string with the division values.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If b == 0: return "", errors.New("division by zero")
                2. result := fmt.Sprintf("%d / %d = %d", a, b, a/b)
                3. Return result, nil</pre>
          solution: |-
            func safeDivideFormat(a, b int) (string, error) {
                if b == 0 {
                    return "", errors.New("division by zero")
                }
                return fmt.Sprintf("%d / %d = %d", a, b, a/b), nil
            }
          difficulty: 3
    - id: challenge_7
      block: 1
      difficulty: 1
      concept: "Building Slices"
      docLinks:
        - url: https://go.dev/blog/slices-intro
          title: "Go Blog: Go Slices intro"
          note: slice fundamentals
        - url: https://go.dev/tour/moretypes/7
          title: "Go Tour: Slices"
          note: slice basics
      patternPrimer:
        bruteForce: Pre-allocate a large array and track the size manually.
        bestApproach: Use append() to build slices dynamically; use make() when size is known ahead of time.
        typical: append() is amortized O(1) per element — slices grow automatically.
      variants:
        - id: v1
          title: Make Sequence
          description: >-
            Write <code>func makeSequence(n int) []int</code> that returns a slice containing the numbers 1
            to n.
          functionSignature: func makeSequence(n int) []int
          testCases:
            - input: "5"
              output: "[]int{1, 2, 3, 4, 5}"
            - input: "3"
              output: "[]int{1, 2, 3}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build up a slice one element at a time. Start with an empty slice and add
                numbers in a loop.
            - title: "\U0001F4A1 Hint"
              content: >-
                Create an empty slice with []int{}. Use a for loop from 1 to n and append each number.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. For i := 1 to n:
                   - result = append(result, i)
                3. Return result</pre>
          solution: |-
            func makeSequence(n int) []int {
                result := []int{}
                for i := 1; i <= n; i++ {
                    result = append(result, i)
                }
                return result
            }
          difficulty: 1
        - id: v2
          title: Zeros
          description: >-
            Write <code>func zeros(n int) []int</code> that returns a slice of n zeros using make().
          functionSignature: func zeros(n int) []int
          testCases:
            - input: "3"
              output: "[]int{0, 0, 0}"
            - input: "5"
              output: "[]int{0, 0, 0, 0, 0}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go has a built-in function that creates a slice of a given length with zero values. What is
                it called?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use make([]int, n) to create a slice of length n. All elements are automatically initialized
                to 0.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return make([]int, n)</pre>
          solution: |-
            func zeros(n int) []int {
                return make([]int, n)
            }
          difficulty: 1
        - id: v3
          title: Repeat Value
          description: >-
            Write <code>func repeatValue(val string, n int) []string</code> that returns a slice with val
            repeated n times.
          functionSignature: func repeatValue(val string, n int) []string
          testCases:
            - input: "\"go\", 3"
              output: "[]string{\"go\", \"go\", \"go\"}"
            - input: "\"hi\", 2"
              output: "[]string{\"hi\", \"hi\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need a loop that runs n times, appending the same value each iteration. What does the
                starting slice look like?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with an empty string slice. Loop n times and append val each time.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. For i := 0 to n:
                   - result = append(result, val)
                3. Return result</pre>
          solution: |-
            func repeatValue(val string, n int) []string {
                result := []string{}
                for i := 0; i < n; i++ {
                    result = append(result, val)
                }
                return result
            }
          difficulty: 1
        - id: v4
          title: Doubles
          description: >-
            Write <code>func doubles(n int) []int</code> that returns a slice containing [2, 4, 6, ..., 2n].
          functionSignature: func doubles(n int) []int
          testCases:
            - input: "4"
              output: "[]int{2, 4, 6, 8}"
            - input: "3"
              output: "[]int{2, 4, 6}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each element is twice its position (starting from 1). How do you generate the sequence
                2, 4, 6, ...?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop from 1 to n. For each i, append i * 2 to the result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. For i := 1 to n:
                   - result = append(result, i*2)
                3. Return result</pre>
          solution: |-
            func doubles(n int) []int {
                result := []int{}
                for i := 1; i <= n; i++ {
                    result = append(result, i*2)
                }
                return result
            }
          difficulty: 1
        - id: v5
          title: Filter Positive
          description: >-
            Write <code>func filterPositive(nums []int) []int</code> that returns a new slice containing only
            the positive numbers.
          functionSignature: func filterPositive(nums []int) []int
          testCases:
            - input: "[]int{-1, 2, -3, 4, 0}"
              output: "[]int{2, 4}"
            - input: "[]int{1, -2, 3}"
              output: "[]int{1, 3}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to selectively include elements based on a condition. Start with an empty result
                and only add elements that pass the test.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through the input. For each number, check if n > 0. If so, append it to the result
                slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. For each n in nums:
                   - If n > 0: result = append(result, n)
                3. Return result</pre>
          solution: |-
            func filterPositive(nums []int) []int {
                result := []int{}
                for _, n := range nums {
                    if n > 0 {
                        result = append(result, n)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v6
          title: Squares
          description: >-
            Write <code>func squares(nums []int) []int</code> that returns a new slice with each element
            squared.
          functionSignature: func squares(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "[]int{1, 4, 9, 16}"
            - input: "[]int{5, 0, -2}"
              output: "[]int{25, 0, 4}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You are transforming each element and building a new slice of the same length. When the
                output size is known, you can pre-allocate with make().
            - title: "\U0001F4A1 Hint"
              content: >-
                Use make([]int, len(nums)) to create a result of the right size. Then loop with index and
                set result[i] = nums[i] * nums[i].
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, len(nums))
                2. For i, n := range nums:
                   - result[i] = n * n
                3. Return result</pre>
          solution: |-
            func squares(nums []int) []int {
                result := make([]int, len(nums))
                for i, n := range nums {
                    result[i] = n * n
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Unique
          description: >-
            Write <code>func unique(nums []int) []int</code> that returns a new slice with duplicate values
            removed, preserving the original order.
          functionSignature: func unique(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 2, 3, 1}"
              output: "[]int{1, 2, 3}"
            - input: "[]int{5, 5, 5}"
              output: "[]int{5}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to remember which values you have already seen. What Go data structure lets you
                quickly check if a value exists?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a map[int]bool to track seen values. For each number, check if it is in the map. If
                not, add it to both the map and the result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. seen := map[int]bool{}
                2. result := []int{}
                3. For each n in nums:
                   - If !seen[n]:
                     - seen[n] = true
                     - result = append(result, n)
                4. Return result</pre>
          solution: |-
            func unique(nums []int) []int {
                seen := map[int]bool{}
                result := []int{}
                for _, n := range nums {
                    if !seen[n] {
                        seen[n] = true
                        result = append(result, n)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Filter by Length
          description: >-
            Write <code>func filterByLength(words []string, minLen int) []string</code> that returns words
            with length greater than or equal to minLen.
          functionSignature: func filterByLength(words []string, minLen int) []string
          testCases:
            - input: "[]string{\"go\", \"rust\", \"c\", \"python\"}, 3"
              output: "[]string{\"rust\", \"python\"}"
            - input: "[]string{\"hi\", \"hello\", \"hey\"}, 3"
              output: "[]string{\"hello\", \"hey\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a filter operation: keep elements that satisfy a condition. The condition here is
                about the string's length.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through words. For each word, check if len(word) >= minLen. If so, append it to the
                result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. For each word in words:
                   - If len(word) >= minLen:
                     - result = append(result, word)
                3. Return result</pre>
          solution: |-
            func filterByLength(words []string, minLen int) []string {
                result := []string{}
                for _, word := range words {
                    if len(word) >= minLen {
                        result = append(result, word)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v9
          title: Range of Numbers
          description: >-
            Write <code>func rangeNums(start, end int) []int</code> that returns a slice of integers from
            start to end (inclusive).
          functionSignature: func rangeNums(start, end int) []int
          testCases:
            - input: "3, 7"
              output: "[]int{3, 4, 5, 6, 7}"
            - input: "1, 4"
              output: "[]int{1, 2, 3, 4}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is similar to makeSequence, but instead of always starting at 1, you start at an
                arbitrary value and go up to end.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop from start to end (inclusive). Append each value to the result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. For i := start to end:
                   - result = append(result, i)
                3. Return result</pre>
          solution: |-
            func rangeNums(start, end int) []int {
                result := []int{}
                for i := start; i <= end; i++ {
                    result = append(result, i)
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Fibonacci
          description: >-
            Write <code>func fibonacci(n int) []int</code> that returns the first n Fibonacci numbers starting
            with [0, 1, 1, 2, 3, 5, ...].
          functionSignature: func fibonacci(n int) []int
          testCases:
            - input: "6"
              output: "[]int{0, 1, 1, 2, 3, 5}"
            - input: "1"
              output: "[]int{0}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each Fibonacci number is the sum of the two before it. But you need to handle the edge
                cases for n = 0 and n = 1 where there aren't two previous numbers.
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with the base cases: if n == 0 return empty, if n == 1 return [0]. Then seed with
                [0, 1] and keep appending the sum of the last two elements.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Handle edge cases (n == 0, n == 1)
                2. result := []int{0, 1}
                3. While len(result) < n:
                   - next := result[len-1] + result[len-2]
                   - result = append(result, next)
                4. Return result</pre>
          solution: |-
            func fibonacci(n int) []int {
                if n == 0 {
                    return []int{}
                }
                if n == 1 {
                    return []int{0}
                }
                result := []int{0, 1}
                for len(result) < n {
                    l := len(result)
                    result = append(result, result[l-1]+result[l-2])
                }
                return result
            }
          difficulty: 3
        - id: v11
          title: Flatten
          description: >-
            Write <code>func flatten(nested [][]int) []int</code> that flattens a 2D slice into a 1D slice.
          functionSignature: func flatten(nested [][]int) []int
          testCases:
            - input: "[][]int{{1, 2}, {3, 4}, {5}}"
              output: "[]int{1, 2, 3, 4, 5}"
            - input: "[][]int{{10}, {20, 30}}"
              output: "[]int{10, 20, 30}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You have a slice of slices. You need to combine all inner slices into one flat slice. How do
                you iterate through a 2D structure?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through each inner slice. Use append with the ... operator to spread the inner slice
                into the result: result = append(result, inner...).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. For each inner slice in nested:
                   - result = append(result, inner...)
                3. Return result</pre>
          solution: |-
            func flatten(nested [][]int) []int {
                result := []int{}
                for _, inner := range nested {
                    result = append(result, inner...)
                }
                return result
            }
          difficulty: 3
        - id: v12
          title: Interleave
          description: >-
            Write <code>func interleave(a, b []int) []int</code> that interleaves two slices. If one is
            longer, append the remaining elements at the end.
          functionSignature: func interleave(a, b []int) []int
          testCases:
            - input: "[]int{1, 3, 5}, []int{2, 4, 6}"
              output: "[]int{1, 2, 3, 4, 5, 6}"
            - input: "[]int{1, 2}, []int{3, 4, 5, 6}"
              output: "[]int{1, 3, 2, 4, 5, 6}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to alternate taking one element from each slice. What happens when one slice runs
                out before the other?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use two indices. Loop while either index is valid. Append from a if its index is valid,
                then from b if its index is valid. Increment both indices.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. For i := 0; i < max(len(a), len(b)):
                   - If i < len(a): append a[i]
                   - If i < len(b): append b[i]
                3. Return result</pre>
          solution: |-
            func interleave(a, b []int) []int {
                result := []int{}
                maxLen := len(a)
                if len(b) > maxLen {
                    maxLen = len(b)
                }
                for i := 0; i < maxLen; i++ {
                    if i < len(a) {
                        result = append(result, a[i])
                    }
                    if i < len(b) {
                        result = append(result, b[i])
                    }
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Running Sum
          description: >-
            Write <code>func runningSum(nums []int) []int</code> that returns a slice where element i is the
            sum of nums[0] through nums[i].
          functionSignature: func runningSum(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "[]int{1, 3, 6, 10}"
            - input: "[]int{5, 10, 15}"
              output: "[]int{5, 15, 30}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each output element depends on all input elements up to that point. But you don't need to
                re-sum from the beginning each time — the previous result already has the partial sum.
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a result slice of the same length. Set result[0] = nums[0]. For each subsequent
                index, result[i] = result[i-1] + nums[i].
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, len(nums))
                2. result[0] = nums[0]
                3. For i := 1 to len(nums):
                   - result[i] = result[i-1] + nums[i]
                4. Return result</pre>
          solution: |-
            func runningSum(nums []int) []int {
                result := make([]int, len(nums))
                result[0] = nums[0]
                for i := 1; i < len(nums); i++ {
                    result[i] = result[i-1] + nums[i]
                }
                return result
            }
          difficulty: 3
    - id: challenge_8
      block: 1
      difficulty: 2
      concept: "Slice Operations"
      docLinks:
        - url: https://go.dev/blog/slices-intro
          title: "Go Blog: Go Slices usage"
          note: slicing syntax
        - url: https://go.dev/ref/spec#Slice_expressions
          title: "Go Spec: Slice expressions"
          note: s[low:high]
      patternPrimer:
        bruteForce: Manually copy elements one by one into new slices.
        bestApproach: Use Go's slice expressions s[a:b] for clean sub-slice extraction; use copy() for safe duplication.
        typical: Slice expressions are O(1) (shared backing array); copy is O(n).
      variants:
        - id: v1
          title: First N Elements
          description: >-
            Write <code>func firstN(nums []int, n int) []int</code> that returns the first n elements of the
            slice.
          functionSignature: func firstN(nums []int, n int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 3"
              output: "[]int{1, 2, 3}"
            - input: "[]int{10, 20, 30}, 2"
              output: "[]int{10, 20}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go's slice syntax lets you take a portion of a slice by specifying a range. How do you
                express "from the beginning up to n elements"?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the slice expression nums[:n] which takes elements from index 0 up to (but not
                including) index n.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return nums[:n]</pre>
          solution: |-
            func firstN(nums []int, n int) []int {
                return nums[:n]
            }
          difficulty: 1
        - id: v2
          title: Last N Elements
          description: >-
            Write <code>func lastN(nums []int, n int) []int</code> that returns the last n elements of the
            slice.
          functionSignature: func lastN(nums []int, n int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 2"
              output: "[]int{4, 5}"
            - input: "[]int{10, 20, 30}, 1"
              output: "[]int{30}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To get the last n elements, you need to figure out the starting index. If the slice has 5
                elements and you want the last 2, where do you start?
            - title: "\U0001F4A1 Hint"
              content: >-
                The starting index is len(nums) - n. Use nums[len(nums)-n:] to get from that point to the
                end.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return nums[len(nums)-n:]</pre>
          solution: |-
            func lastN(nums []int, n int) []int {
                return nums[len(nums)-n:]
            }
          difficulty: 1
        - id: v3
          title: Remove First
          description: >-
            Write <code>func removeFirst(nums []int) []int</code> that returns the slice without the first
            element.
          functionSignature: func removeFirst(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3}"
              output: "[]int{2, 3}"
            - input: "[]int{10, 20}"
              output: "[]int{20}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Removing the first element means keeping everything from index 1 onward. What slice
                expression does this?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use nums[1:] to get everything starting from index 1.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return nums[1:]</pre>
          solution: |-
            func removeFirst(nums []int) []int {
                return nums[1:]
            }
          difficulty: 1
        - id: v4
          title: Remove Last
          description: >-
            Write <code>func removeLast(nums []int) []int</code> that returns the slice without the last
            element.
          functionSignature: func removeLast(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3}"
              output: "[]int{1, 2}"
            - input: "[]int{10, 20, 30}"
              output: "[]int{10, 20}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Removing the last element means keeping everything up to but not including the last index.
                What slice expression does this?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use nums[:len(nums)-1] to get everything except the last element.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return nums[:len(nums)-1]</pre>
          solution: |-
            func removeLast(nums []int) []int {
                return nums[:len(nums)-1]
            }
          difficulty: 1
        - id: v5
          title: Middle Element
          description: >-
            Write <code>func middle(nums []int) int</code> that returns the middle element of a slice. Assume
            the slice has an odd number of elements.
          functionSignature: func middle(nums []int) int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}"
              output: "3"
            - input: "[]int{10, 20, 30}"
              output: "20"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For a slice of length 5, the middle element is at index 2. For length 3, it is at index 1.
                What is the formula?
            - title: "\U0001F4A1 Hint"
              content: >-
                The middle index is len(nums) / 2. Integer division automatically rounds down, which gives
                the correct middle for odd-length slices.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return nums[len(nums)/2]</pre>
          solution: |-
            func middle(nums []int) int {
                return nums[len(nums)/2]
            }
          difficulty: 2
        - id: v6
          title: Reverse
          description: >-
            Write <code>func reverse(nums []int) []int</code> that returns a new reversed slice without
            modifying the original.
          functionSignature: func reverse(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "[]int{4, 3, 2, 1}"
            - input: "[]int{5, 10}"
              output: "[]int{10, 5}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to create a new slice where the first element of the original becomes the last, and
                vice versa. How do you map from original index to reversed index?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a new slice with make(). For each element at index i, place it at position
                len(nums)-1-i in the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, len(nums))
                2. For i, v := range nums:
                   - result[len(nums)-1-i] = v
                3. Return result</pre>
          solution: |-
            func reverse(nums []int) []int {
                result := make([]int, len(nums))
                for i, v := range nums {
                    result[len(nums)-1-i] = v
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Rotate Left
          description: >-
            Write <code>func rotateLeft(nums []int, k int) []int</code> that rotates the slice left by k
            positions.
          functionSignature: func rotateLeft(nums []int, k int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 2"
              output: "[]int{3, 4, 5, 1, 2}"
            - input: "[]int{10, 20, 30}, 1"
              output: "[]int{20, 30, 10}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Rotating left by k means the first k elements move to the end. Can you split the slice into
                two parts and recombine?
            - title: "\U0001F4A1 Hint"
              content: >-
                Split at position k: take nums[k:] and nums[:k]. Combine them with append. Use k % len(nums)
                to handle k larger than the slice length.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. k = k % len(nums)
                2. Return append(nums[k:], nums[:k]...)</pre>
          solution: |-
            func rotateLeft(nums []int, k int) []int {
                k = k % len(nums)
                return append(nums[k:], nums[:k]...)
            }
          difficulty: 2
        - id: v8
          title: Split At
          description: >-
            Write <code>func splitAt(nums []int, index int) ([]int, []int)</code> that splits the slice into
            two parts at the given index.
          functionSignature: func splitAt(nums []int, index int) ([]int, []int)
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 3"
              output: "[]int{1, 2, 3}, []int{4, 5}"
            - input: "[]int{10, 20, 30}, 1"
              output: "[]int{10}, []int{20, 30}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Splitting at an index means everything before that index goes into the first part, and
                everything from that index onward goes into the second part.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use nums[:index] for the first part and nums[index:] for the second. Return both.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return nums[:index], nums[index:]</pre>
          solution: |-
            func splitAt(nums []int, index int) ([]int, []int) {
                return nums[:index], nums[index:]
            }
          difficulty: 2
        - id: v9
          title: Contains
          description: >-
            Write <code>func contains(nums []int, target int) bool</code> that checks if the target value
            exists in the slice.
          functionSignature: func contains(nums []int, target int) bool
          testCases:
            - input: "[]int{1, 2, 3}, 2"
              output: "true"
            - input: "[]int{1, 2, 3}, 5"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to scan through the slice looking for a match. What do you return if you find it?
                What if you reach the end without finding it?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through and compare each element to target. Return true immediately when found. After
                the loop, return false.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. For each n in nums:
                   - If n == target: return true
                2. Return false</pre>
          solution: |-
            func contains(nums []int, target int) bool {
                for _, n := range nums {
                    if n == target {
                        return true
                    }
                }
                return false
            }
          difficulty: 2
        - id: v10
          title: Remove At Index
          description: >-
            Write <code>func removeAt(nums []int, index int) []int</code> that returns a new slice with the
            element at the given index removed.
          functionSignature: func removeAt(nums []int, index int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4}, 2"
              output: "[]int{1, 2, 4}"
            - input: "[]int{10, 20, 30}, 0"
              output: "[]int{20, 30}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to combine the part before the index with the part after the index, skipping the
                element at that position. Be careful not to modify the original slice.
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a new slice. Append everything before the index, then append everything after the
                index. Use the ... spread operator with append.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, 0, len(nums)-1)
                2. result = append(result, nums[:index]...)
                3. result = append(result, nums[index+1:]...)
                4. Return result</pre>
          solution: |-
            func removeAt(nums []int, index int) []int {
                result := make([]int, 0, len(nums)-1)
                result = append(result, nums[:index]...)
                result = append(result, nums[index+1:]...)
                return result
            }
          difficulty: 3
        - id: v11
          title: Insert At
          description: >-
            Write <code>func insertAt(nums []int, index, value int) []int</code> that returns a new slice with
            the value inserted at the given index.
          functionSignature: func insertAt(nums []int, index, value int) []int
          testCases:
            - input: "[]int{1, 2, 4, 5}, 2, 3"
              output: "[]int{1, 2, 3, 4, 5}"
            - input: "[]int{10, 30}, 1, 20"
              output: "[]int{10, 20, 30}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Inserting means you take everything before the index, add the new value, then add everything
                from the index onward. The result is one element longer.
            - title: "\U0001F4A1 Hint"
              content: >-
                Build a new slice: append nums[:index], then the value, then nums[index:]. Use the ...
                spread operator for the slice parts.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, 0, len(nums)+1)
                2. result = append(result, nums[:index]...)
                3. result = append(result, value)
                4. result = append(result, nums[index:]...)
                5. Return result</pre>
          solution: |-
            func insertAt(nums []int, index, value int) []int {
                result := make([]int, 0, len(nums)+1)
                result = append(result, nums[:index]...)
                result = append(result, value)
                result = append(result, nums[index:]...)
                return result
            }
          difficulty: 3
        - id: v12
          title: Chunk
          description: >-
            Write <code>func chunk(nums []int, size int) [][]int</code> that splits the slice into chunks of
            the given size. The last chunk may be smaller.
          functionSignature: func chunk(nums []int, size int) [][]int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 2"
              output: "[][]int{{1, 2}, {3, 4}, {5}}"
            - input: "[]int{1, 2, 3, 4}, 2"
              output: "[][]int{{1, 2}, {3, 4}}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to walk through the slice in steps of the given size, taking a sub-slice each time.
                What happens when the remaining elements are fewer than the chunk size?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a for loop that increments by size. For each step, calculate the end index as i + size,
                but cap it at len(nums) to avoid going out of bounds.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := [][]int{}
                2. For i := 0; i < len(nums); i += size:
                   - end := i + size
                   - If end > len(nums): end = len(nums)
                   - result = append(result, nums[i:end])
                3. Return result</pre>
          solution: |-
            func chunk(nums []int, size int) [][]int {
                result := [][]int{}
                for i := 0; i < len(nums); i += size {
                    end := i + size
                    if end > len(nums) {
                        end = len(nums)
                    }
                    result = append(result, nums[i:end])
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Window Sums
          description: >-
            Write <code>func windowSums(nums []int, size int) []int</code> that returns the sums of each
            sliding window of the given size.
          functionSignature: func windowSums(nums []int, size int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 3"
              output: "[]int{6, 9, 12}"
            - input: "[]int{10, 20, 30, 40}, 2"
              output: "[]int{30, 50, 70}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A sliding window of size 3 over [1, 2, 3, 4, 5] gives windows [1,2,3], [2,3,4], [3,4,5].
                How many windows are there for a slice of length n with window size k?
            - title: "\U0001F4A1 Hint"
              content: >-
                There are len(nums) - size + 1 windows. For each starting position i from 0 to
                len(nums)-size, sum the elements from i to i+size-1.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. For i := 0; i <= len(nums)-size; i++:
                   - sum := 0
                   - For j := i; j < i+size; j++:
                     - sum += nums[j]
                   - result = append(result, sum)
                3. Return result</pre>
          solution: |-
            func windowSums(nums []int, size int) []int {
                result := []int{}
                for i := 0; i <= len(nums)-size; i++ {
                    sum := 0
                    for j := i; j < i+size; j++ {
                        sum += nums[j]
                    }
                    result = append(result, sum)
                }
                return result
            }
          difficulty: 3
    - id: challenge_9
      block: 1
      difficulty: 1
      concept: "For Loops"
      docLinks:
        - url: https://go.dev/tour/flowcontrol/1
          title: "Go Tour: For"
          note: the only loop in Go
        - url: https://go.dev/ref/spec#For_statements
          title: "Go Spec: For statements"
          note: three forms
      patternPrimer:
        bruteForce: Write separate loops for each variant of iteration.
        bestApproach: "Go has one loop keyword \u2014 for \u2014 with three forms: C-style, while-style, and infinite + break."
        typical: Most loops are O(n) \u2014 choose the right form for clarity.
      variants:
        - id: v1
          title: Sum to N
          description: >-
            Write <code>func sumToN(n int) int</code> that returns 1 + 2 + ... + n using a for loop.
          functionSignature: func sumToN(n int) int
          testCases:
            - input: "5"
              output: "15"
            - input: "10"
              output: "55"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to add every integer from 1 up to n. What kind of loop counts from one value to another?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a C-style for loop: for i := 1; i <= n; i++. Keep a running sum and add each i to it.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. sum := 0
                2. for i := 1; i <= n; i++:
                   - sum += i
                3. return sum</pre>
          solution: |-
            func sumToN(n int) int {
                sum := 0
                for i := 1; i <= n; i++ {
                    sum += i
                }
                return sum
            }
          difficulty: 1
        - id: v2
          title: Factorial
          description: >-
            Write <code>func factorial(n int) int</code> that returns n! (n factorial) using a for loop.
          functionSignature: func factorial(n int) int
          testCases:
            - input: "5"
              output: "120"
            - input: "0"
              output: "1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Factorial means multiplying all integers from 1 to n. What should the starting value be for a
                multiplication accumulator?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with result := 1 (the identity for multiplication). Loop from 2 to n and multiply each value
                into result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := 1
                2. for i := 2; i <= n; i++:
                   - result *= i
                3. return result</pre>
          solution: |-
            func factorial(n int) int {
                result := 1
                for i := 2; i <= n; i++ {
                    result *= i
                }
                return result
            }
          difficulty: 1
        - id: v3
          title: Power
          description: >-
            Write <code>func power(base, exp int) int</code> that returns base raised to the power of exp using a
            for loop.
          functionSignature: func power(base, exp int) int
          testCases:
            - input: "2, 10"
              output: "1024"
            - input: "3, 3"
              output: "27"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Exponentiation is repeated multiplication. How many times do you need to multiply base by itself?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with result := 1. Loop exp times, multiplying result by base each iteration.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := 1
                2. for i := 0; i < exp; i++:
                   - result *= base
                3. return result</pre>
          solution: |-
            func power(base, exp int) int {
                result := 1
                for i := 0; i < exp; i++ {
                    result *= base
                }
                return result
            }
          difficulty: 1
        - id: v4
          title: Count Down
          description: >-
            Write <code>func countDown(n int) []int</code> that returns a slice [n, n-1, ..., 1] using a for loop.
          functionSignature: func countDown(n int) []int
          testCases:
            - input: "5"
              output: "[]int{5, 4, 3, 2, 1}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to loop from n down to 1. How do you write a for loop that decrements?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for i := n; i >= 1; i-- and append each value to a result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. for i := n; i >= 1; i--:
                   - append i to result
                3. return result</pre>
          solution: |-
            func countDown(n int) []int {
                result := []int{}
                for i := n; i >= 1; i-- {
                    result = append(result, i)
                }
                return result
            }
          difficulty: 1
        - id: v5
          title: Count Digits
          description: >-
            Write <code>func countDigits(n int) int</code> that counts the number of digits in n. Use a while-style
            loop: <code>for n > 0 { n /= 10 }</code>.
          functionSignature: func countDigits(n int) int
          testCases:
            - input: "12345"
              output: "5"
            - input: "0"
              output: "1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each time you divide by 10, you remove one digit. How many times can you divide before reaching 0?
            - title: "\U0001F4A1 Hint"
              content: >-
                Handle the special case n == 0 first (it has 1 digit). Then use a while-style for loop: for n > 0,
                divide by 10 and increment a counter.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if n == 0: return 1
                2. count := 0
                3. for n > 0:
                   - n /= 10
                   - count++
                4. return count</pre>
          solution: |-
            func countDigits(n int) int {
                if n == 0 {
                    return 1
                }
                count := 0
                for n > 0 {
                    n /= 10
                    count++
                }
                return count
            }
          difficulty: 2
        - id: v6
          title: Sum of Digits
          description: >-
            Write <code>func sumDigits(n int) int</code> that returns the sum of the digits of n.
          functionSignature: func sumDigits(n int) int
          testCases:
            - input: "123"
              output: "6"
            - input: "9999"
              output: "36"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You can extract the last digit of a number with n % 10 and remove it with n / 10. How do you
                combine these to get all digits?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a while-style for loop. Each iteration: add n % 10 to the sum, then set n = n / 10. Continue
                while n > 0.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. sum := 0
                2. for n > 0:
                   - sum += n % 10
                   - n /= 10
                3. return sum</pre>
          solution: |-
            func sumDigits(n int) int {
                sum := 0
                for n > 0 {
                    sum += n % 10
                    n /= 10
                }
                return sum
            }
          difficulty: 2
        - id: v7
          title: Collatz Steps
          description: >-
            Write <code>func collatzSteps(n int) int</code> that counts the number of steps to reach 1 using the
            Collatz sequence: if even, divide by 2; if odd, multiply by 3 and add 1. Use a
            <code>for n != 1</code> style loop.
          functionSignature: func collatzSteps(n int) int
          testCases:
            - input: "6"
              output: "8"
            - input: "1"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The loop should run until n becomes 1. Inside, you apply one of two rules depending on whether n
                is even or odd. What condition keeps the loop going?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for n != 1. Check if n is even (n%2 == 0) to decide which operation to apply. Count each step.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. steps := 0
                2. for n != 1:
                   - if n % 2 == 0: n /= 2
                   - else: n = 3*n + 1
                   - steps++
                3. return steps</pre>
          solution: |-
            func collatzSteps(n int) int {
                steps := 0
                for n != 1 {
                    if n%2 == 0 {
                        n /= 2
                    } else {
                        n = 3*n + 1
                    }
                    steps++
                }
                return steps
            }
          difficulty: 2
        - id: v8
          title: Multiply Until
          description: >-
            Write <code>func multiplyUntil(start, multiplier, limit int) int</code> that starts from start and
            keeps multiplying by multiplier until the result is >= limit. Return the result.
          functionSignature: func multiplyUntil(start, multiplier, limit int) int
          testCases:
            - input: "1, 2, 100"
              output: "128"
            - input: "3, 3, 50"
              output: "81"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You keep applying an operation until a condition is met. This is a natural fit for a while-style
                for loop. What is the stopping condition?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for n < limit as the loop condition. Each iteration, multiply n by the multiplier.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. n := start
                2. for n < limit:
                   - n *= multiplier
                3. return n</pre>
          solution: |-
            func multiplyUntil(start, multiplier, limit int) int {
                n := start
                for n < limit {
                    n *= multiplier
                }
                return n
            }
          difficulty: 2
        - id: v9
          title: Find First Divisible
          description: >-
            Write <code>func firstDivisible(start, divisor int) int</code> that finds the first number >= start
            that is evenly divisible by divisor.
          functionSignature: func firstDivisible(start, divisor int) int
          testCases:
            - input: "10, 3"
              output: "12"
            - input: "9, 3"
              output: "9"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Start at the given number and keep incrementing until you find one that divides evenly. What
                operator checks divisibility?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for n % divisor != 0 as the condition. Increment n each time. The loop stops when n is
                divisible by divisor.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. n := start
                2. for n % divisor != 0:
                   - n++
                3. return n</pre>
          solution: |-
            func firstDivisible(start, divisor int) int {
                n := start
                for n%divisor != 0 {
                    n++
                }
                return n
            }
          difficulty: 2
        - id: v10
          title: GCD
          description: >-
            Write <code>func gcd(a, b int) int</code> that computes the greatest common divisor using the
            Euclidean algorithm. Use a <code>for b != 0</code> loop.
          functionSignature: func gcd(a, b int) int
          testCases:
            - input: "48, 18"
              output: "6"
            - input: "100, 75"
              output: "25"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The Euclidean algorithm repeatedly replaces the larger number with the remainder of dividing the
                two. When does this process stop?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for b != 0. Each step: set a, b = b, a%b. When b becomes 0, a holds the GCD.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. for b != 0:
                   - a, b = b, a % b
                2. return a</pre>
          solution: |-
            func gcd(a, b int) int {
                for b != 0 {
                    a, b = b, a%b
                }
                return a
            }
          difficulty: 3
        - id: v11
          title: Is Prime
          description: >-
            Write <code>func isPrime(n int) bool</code> that returns true if n is a prime number. Loop from 2 up
            to the square root of n to check for divisors.
          functionSignature: func isPrime(n int) bool
          testCases:
            - input: "7"
              output: "true"
            - input: "4"
              output: "false"
            - input: "1"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A prime number has no divisors other than 1 and itself. You only need to check up to the square
                root. Why is that sufficient?
            - title: "\U0001F4A1 Hint"
              content: >-
                Handle n < 2 as not prime. Then loop for i := 2; i*i <= n; i++. If any i divides n evenly, it is
                not prime.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if n < 2: return false
                2. for i := 2; i*i <= n; i++:
                   - if n % i == 0: return false
                3. return true</pre>
          solution: |-
            func isPrime(n int) bool {
                if n < 2 {
                    return false
                }
                for i := 2; i*i <= n; i++ {
                    if n%i == 0 {
                        return false
                    }
                }
                return true
            }
          difficulty: 3
        - id: v12
          title: Multiplication Table Row
          description: >-
            Write <code>func multiplicationRow(n, size int) []int</code> that returns row n of a multiplication
            table as a slice: [n*1, n*2, ..., n*size].
          functionSignature: func multiplicationRow(n, size int) []int
          testCases:
            - input: "3, 5"
              output: "[]int{3, 6, 9, 12, 15}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to generate size elements where each element is n multiplied by its position (starting at
                1). How can you pre-allocate the result slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use make([]int, size) to create a slice of the right length. Loop with index and set each element
                to n * (i + 1).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, size)
                2. for i := 0; i < size; i++:
                   - result[i] = n * (i + 1)
                3. return result</pre>
          solution: |-
            func multiplicationRow(n, size int) []int {
                result := make([]int, size)
                for i := 0; i < size; i++ {
                    result[i] = n * (i + 1)
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Binary Digits
          description: >-
            Write <code>func toBinary(n int) string</code> that converts an integer to its binary string
            representation using repeated division by 2.
          functionSignature: func toBinary(n int) string
          testCases:
            - input: "10"
              output: "\"1010\""
            - input: "0"
              output: "\"0\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To convert to binary, repeatedly divide by 2 and collect remainders. The remainders read in
                reverse order give the binary representation. How do you build a string in reverse?
            - title: "\U0001F4A1 Hint"
              content: >-
                Handle n == 0 as a special case. Then use for n > 0: prepend (n % 2) as "0" or "1" to the result
                string, and divide n by 2.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if n == 0: return "0"
                2. result := ""
                3. for n > 0:
                   - if n % 2 == 0: result = "0" + result
                   - else: result = "1" + result
                   - n /= 2
                4. return result</pre>
          solution: |-
            func toBinary(n int) string {
                if n == 0 {
                    return "0"
                }
                result := ""
                for n > 0 {
                    if n%2 == 0 {
                        result = "0" + result
                    } else {
                        result = "1" + result
                    }
                    n /= 2
                }
                return result
            }
          difficulty: 3
    - id: challenge_10
      block: 1
      difficulty: 1
      concept: "Range Loops"
      docLinks:
        - url: https://go.dev/tour/moretypes/16
          title: "Go Tour: Range"
          note: iterating slices and maps
        - url: https://go.dev/doc/effective_go#for
          title: "Effective Go: For"
          note: range patterns
      patternPrimer:
        bruteForce: Use C-style for with manual index tracking.
        bestApproach: "Use for i, v := range to iterate slices idiomatically; use _ to discard unused index or value."
        typical: Range is the idiomatic way to iterate in Go \u2014 same O(n) complexity, cleaner syntax.
      variants:
        - id: v1
          title: Sum All
          description: >-
            Write <code>func sumAll(nums []int) int</code> that returns the sum of all elements using range.
          functionSignature: func sumAll(nums []int) int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}"
              output: "15"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You want the value of each element but not the index. How do you discard the index in a range loop?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for _, n := range nums to iterate values. The underscore discards the index. Accumulate a sum.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. sum := 0
                2. for _, n := range nums:
                   - sum += n
                3. return sum</pre>
          solution: |-
            func sumAll(nums []int) int {
                sum := 0
                for _, n := range nums {
                    sum += n
                }
                return sum
            }
          difficulty: 1
        - id: v2
          title: Find Max
          description: >-
            Write <code>func findMax(nums []int) int</code> that returns the maximum element using range.
          functionSignature: func findMax(nums []int) int
          testCases:
            - input: "[]int{3, 7, 2, 9, 4}"
              output: "9"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to track the largest value seen so far. What should you initialize it to?
            - title: "\U0001F4A1 Hint"
              content: >-
                Initialize max to the first element (nums[0]). Then range over the slice and update max whenever
                you find a larger value.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. max := nums[0]
                2. for _, n := range nums:
                   - if n > max: max = n
                3. return max</pre>
          solution: |-
            func findMax(nums []int) int {
                max := nums[0]
                for _, n := range nums {
                    if n > max {
                        max = n
                    }
                }
                return max
            }
          difficulty: 1
        - id: v3
          title: Count Target
          description: >-
            Write <code>func countTarget(nums []int, target int) int</code> that counts how many times target
            appears in the slice.
          functionSignature: func countTarget(nums []int, target int) int
          testCases:
            - input: "[]int{1, 2, 2, 3, 2}, 2"
              output: "3"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Loop through and compare each element to the target. What do you do when they match?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start a counter at 0. Use for _, n := range nums. If n == target, increment the counter.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. count := 0
                2. for _, n := range nums:
                   - if n == target: count++
                3. return count</pre>
          solution: |-
            func countTarget(nums []int, target int) int {
                count := 0
                for _, n := range nums {
                    if n == target {
                        count++
                    }
                }
                return count
            }
          difficulty: 1
        - id: v4
          title: All Positive
          description: >-
            Write <code>func allPositive(nums []int) bool</code> that returns true if all elements are positive
            (greater than zero).
          functionSignature: func allPositive(nums []int) bool
          testCases:
            - input: "[]int{1, 2, 3}"
              output: "true"
            - input: "[]int{1, -2, 3}"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                If you find even one non-positive element, the answer is false. Can you exit early?
            - title: "\U0001F4A1 Hint"
              content: >-
                Range over the slice. If any element is <= 0, return false immediately. If the loop completes,
                return true.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. for _, n := range nums:
                   - if n <= 0: return false
                2. return true</pre>
          solution: |-
            func allPositive(nums []int) bool {
                for _, n := range nums {
                    if n <= 0 {
                        return false
                    }
                }
                return true
            }
          difficulty: 1
        - id: v5
          title: Index Of
          description: >-
            Write <code>func indexOf(nums []int, target int) int</code> that returns the index of the first
            occurrence of target, or -1 if not found.
          functionSignature: func indexOf(nums []int, target int) int
          testCases:
            - input: "[]int{10, 20, 30}, 20"
              output: "1"
            - input: "[]int{10, 20, 30}, 50"
              output: "-1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need the index this time, not just the value. How does range give you both?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for i, n := range nums. When n == target, return i immediately. If the loop finishes without
                finding it, return -1.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. for i, n := range nums:
                   - if n == target: return i
                2. return -1</pre>
          solution: |-
            func indexOf(nums []int, target int) int {
                for i, n := range nums {
                    if n == target {
                        return i
                    }
                }
                return -1
            }
          difficulty: 2
        - id: v6
          title: Double All
          description: >-
            Write <code>func doubleAll(nums []int) []int</code> that returns a new slice with each element
            doubled. Use range with index.
          functionSignature: func doubleAll(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3}"
              output: "[]int{2, 4, 6}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to create a new slice of the same length and fill it with transformed values. How do you
                pre-allocate a slice of a known size?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use make([]int, len(nums)) to create the result slice. Then for i, n := range nums, set
                result[i] = n * 2.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, len(nums))
                2. for i, n := range nums:
                   - result[i] = n * 2
                3. return result</pre>
          solution: |-
            func doubleAll(nums []int) []int {
                result := make([]int, len(nums))
                for i, n := range nums {
                    result[i] = n * 2
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Join Strings
          description: >-
            Write <code>func joinWith(words []string, sep string) string</code> that joins all words with the
            given separator using range.
          functionSignature: func joinWith(words []string, sep string) string
          testCases:
            - input: "[]string{\"go\", \"is\", \"fun\"}, \"-\""
              output: "\"go-is-fun\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You want to put the separator between words, but not before the first word. How can the index from
                range help?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for i, w := range words. If i > 0, append the separator before appending the word. This
                avoids a trailing or leading separator.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := ""
                2. for i, w := range words:
                   - if i > 0: result += sep
                   - result += w
                3. return result</pre>
          solution: |-
            func joinWith(words []string, sep string) string {
                result := ""
                for i, w := range words {
                    if i > 0 {
                        result += sep
                    }
                    result += w
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Any Above
          description: >-
            Write <code>func anyAbove(nums []int, threshold int) bool</code> that returns true if any element
            exceeds the threshold.
          functionSignature: func anyAbove(nums []int, threshold int) bool
          testCases:
            - input: "[]int{1, 5, 3}, 4"
              output: "true"
            - input: "[]int{1, 2, 3}, 4"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                As soon as you find one element above the threshold, you know the answer. Can you return early?
            - title: "\U0001F4A1 Hint"
              content: >-
                Range over the slice. If any n > threshold, return true immediately. If the loop finishes, return
                false.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. for _, n := range nums:
                   - if n > threshold: return true
                2. return false</pre>
          solution: |-
            func anyAbove(nums []int, threshold int) bool {
                for _, n := range nums {
                    if n > threshold {
                        return true
                    }
                }
                return false
            }
          difficulty: 2
        - id: v9
          title: Enumerate
          description: >-
            Write <code>func enumerate(items []string) []string</code> that returns a slice of strings in the
            format "0: item", "1: item", etc.
          functionSignature: func enumerate(items []string) []string
          testCases:
            - input: "[]string{\"a\", \"b\", \"c\"}"
              output: "[]string{\"0: a\", \"1: b\", \"2: c\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need both the index and the value from range. How do you format an integer and a string into a
                single string in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("%d: %s", i, item) to format each entry. Pre-allocate with make([]string,
                len(items)).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]string, len(items))
                2. for i, item := range items:
                   - result[i] = fmt.Sprintf("%d: %s", i, item)
                3. return result</pre>
          solution: |-
            func enumerate(items []string) []string {
                result := make([]string, len(items))
                for i, item := range items {
                    result[i] = fmt.Sprintf("%d: %s", i, item)
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Longest String
          description: >-
            Write <code>func longest(words []string) string</code> that returns the longest string in the slice.
            If there is a tie, return the first one found.
          functionSignature: func longest(words []string) string
          testCases:
            - input: "[]string{\"go\", \"python\", \"c\", \"rust\"}"
              output: "\"python\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is like finding the max, but instead of comparing numbers you compare string lengths. What do
                you track as you iterate?
            - title: "\U0001F4A1 Hint"
              content: >-
                Initialize best to words[0]. Range over the slice and update best whenever len(w) > len(best).
                Using > (not >=) ensures the first one wins on ties.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. best := words[0]
                2. for _, w := range words:
                   - if len(w) > len(best): best = w
                3. return best</pre>
          solution: |-
            func longest(words []string) string {
                best := words[0]
                for _, w := range words {
                    if len(w) > len(best) {
                        best = w
                    }
                }
                return best
            }
          difficulty: 3
        - id: v11
          title: Running Max
          description: >-
            Write <code>func runningMax(nums []int) []int</code> that returns a slice where each element is the
            maximum of all elements up to and including that index.
          functionSignature: func runningMax(nums []int) []int
          testCases:
            - input: "[]int{3, 1, 4, 1, 5}"
              output: "[]int{3, 3, 4, 4, 5}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                At each position, the running max is either the current element or the previous running max,
                whichever is larger. How do you track this as you iterate?
            - title: "\U0001F4A1 Hint"
              content: >-
                Keep a max variable initialized to nums[0]. As you range, update max if the current value is
                larger, then store max in the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, len(nums))
                2. max := nums[0]
                3. for i, n := range nums:
                   - if n > max: max = n
                   - result[i] = max
                4. return result</pre>
          solution: |-
            func runningMax(nums []int) []int {
                result := make([]int, len(nums))
                max := nums[0]
                for i, n := range nums {
                    if n > max {
                        max = n
                    }
                    result[i] = max
                }
                return result
            }
          difficulty: 3
        - id: v12
          title: Zip
          description: >-
            Write <code>func zip(a []int, b []int) [][2]int</code> that combines two slices into pairs. Use the
            shorter length if they differ.
          functionSignature: func zip(a []int, b []int) [][2]int
          testCases:
            - input: "[]int{1, 2, 3}, []int{4, 5, 6}"
              output: "[][2]int{{1, 4}, {2, 5}, {3, 6}}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to iterate two slices in parallel. Range only works on one collection at a time. What
                kind of loop lets you control the index explicitly?
            - title: "\U0001F4A1 Hint"
              content: >-
                Find the minimum of len(a) and len(b). Use a C-style for loop up to that length. At each index,
                create a [2]int pair from a[i] and b[i].
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. length := min(len(a), len(b))
                2. result := make([][2]int, length)
                3. for i := 0; i < length; i++:
                   - result[i] = [2]int{a[i], b[i]}
                4. return result</pre>
          solution: |-
            func zip(a []int, b []int) [][2]int {
                length := len(a)
                if len(b) < length {
                    length = len(b)
                }
                result := make([][2]int, length)
                for i := 0; i < length; i++ {
                    result[i] = [2]int{a[i], b[i]}
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Count Characters
          description: >-
            Write <code>func countChars(s string) map[rune]int</code> that counts the occurrences of each
            character in a string using range, which iterates over runes.
          functionSignature: func countChars(s string) map[rune]int
          testCases:
            - input: "\"hello\""
              output: "map[rune]int{'h': 1, 'e': 1, 'l': 2, 'o': 1}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you range over a string in Go, you get runes (Unicode code points), not bytes. How do you
                store counts for each unique character?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a map[rune]int with make(). Range over the string to get each rune, then increment the
                count for that rune in the map.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. counts := make(map[rune]int)
                2. for _, c := range s:
                   - counts[c]++
                3. return counts</pre>
          solution: |-
            func countChars(s string) map[rune]int {
                counts := make(map[rune]int)
                for _, c := range s {
                    counts[c]++
                }
                return counts
            }
          difficulty: 3
    - id: challenge_11
      block: 1
      difficulty: 2
      concept: "Map Basics"
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go Blog: Go maps in action"
          note: comprehensive map guide
        - url: https://go.dev/tour/moretypes/19
          title: "Go Tour: Maps"
          note: map basics
      patternPrimer:
        bruteForce: Use parallel slices for keys and values and search linearly.
        bestApproach: Use maps for O(1) key lookups; build maps from data with make() or literals.
        typical: Map operations (get/set/delete) are O(1) average case.
      variants:
        - id: v1
          title: Word Count
          description: >-
            Write <code>func wordCount(words []string) map[string]int</code> that counts occurrences of each word.
          functionSignature: func wordCount(words []string) map[string]int
          testCases:
            - input: "[]string{\"go\", \"is\", \"go\"}"
              output: "map[string]int{\"go\": 2, \"is\": 1}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to track how many times each word appears. What data structure gives you O(1) lookups by
                key?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a map[string]int with make(). Range over words and use counts[w]++ to increment each
                word's count. Missing keys default to 0.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. counts := make(map[string]int)
                2. for _, w := range words:
                   - counts[w]++
                3. return counts</pre>
          solution: |-
            func wordCount(words []string) map[string]int {
                counts := make(map[string]int)
                for _, w := range words {
                    counts[w]++
                }
                return counts
            }
          difficulty: 1
        - id: v2
          title: Create Phone Book
          description: >-
            Write <code>func phoneBook(names, numbers []string) map[string]string</code> that builds a map from
            two parallel slices of names and numbers.
          functionSignature: func phoneBook(names, numbers []string) map[string]string
          testCases:
            - input: "[]string{\"alice\", \"bob\"}, []string{\"111\", \"222\"}"
              output: "map[string]string{\"alice\": \"111\", \"bob\": \"222\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You have two slices of the same length where corresponding elements are related. How do you access
                matching elements from both?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for i := range names to iterate by index. Set m[names[i]] = numbers[i] to build the mapping.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. m := make(map[string]string)
                2. for i := range names:
                   - m[names[i]] = numbers[i]
                3. return m</pre>
          solution: |-
            func phoneBook(names, numbers []string) map[string]string {
                m := make(map[string]string)
                for i := range names {
                    m[names[i]] = numbers[i]
                }
                return m
            }
          difficulty: 1
        - id: v3
          title: Square Lookup
          description: >-
            Write <code>func squareLookup(n int) map[int]int</code> that creates a map from 1 to n where each
            key maps to its square.
          functionSignature: func squareLookup(n int) map[int]int
          testCases:
            - input: "3"
              output: "map[int]int{1: 1, 2: 4, 3: 9}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to generate key-value pairs where the key is a number and the value is derived from it.
                What loop generates numbers 1 through n?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use make(map[int]int) and a for loop from 1 to n. Set m[i] = i * i for each number.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. m := make(map[int]int)
                2. for i := 1; i <= n; i++:
                   - m[i] = i * i
                3. return m</pre>
          solution: |-
            func squareLookup(n int) map[int]int {
                m := make(map[int]int)
                for i := 1; i <= n; i++ {
                    m[i] = i * i
                }
                return m
            }
          difficulty: 1
        - id: v4
          title: Invert Map
          description: >-
            Write <code>func invertMap(m map[string]int) map[int]string</code> that swaps keys and values.
          functionSignature: func invertMap(m map[string]int) map[int]string
          testCases:
            - input: "map[string]int{\"a\": 1, \"b\": 2}"
              output: "map[int]string{1: \"a\", 2: \"b\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each key becomes a value and each value becomes a key. What happens if two keys have the same
                value?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a new map with the types swapped. Range over the original map and set result[v] = k for
                each key-value pair.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make(map[int]string)
                2. for k, v := range m:
                   - result[v] = k
                3. return result</pre>
          solution: |-
            func invertMap(m map[string]int) map[int]string {
                result := make(map[int]string)
                for k, v := range m {
                    result[v] = k
                }
                return result
            }
          difficulty: 1
        - id: v5
          title: Group by Length
          description: >-
            Write <code>func groupByLength(words []string) map[int][]string</code> that groups words by their
            string length.
          functionSignature: func groupByLength(words []string) map[int][]string
          testCases:
            - input: "[]string{\"go\", \"hi\", \"rust\", \"hey\"}"
              output: "map[int][]string{2: {\"go\", \"hi\"}, 4: {\"rust\"}, 3: {\"hey\"}}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The map values are slices. How do you add to a slice that might not exist in the map yet?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use append. In Go, appending to a nil slice works fine, so groups[len(w)] = append(groups[len(w)],
                w) handles both new and existing keys.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. groups := make(map[int][]string)
                2. for _, w := range words:
                   - groups[len(w)] = append(groups[len(w)], w)
                3. return groups</pre>
          solution: |-
            func groupByLength(words []string) map[int][]string {
                groups := make(map[int][]string)
                for _, w := range words {
                    groups[len(w)] = append(groups[len(w)], w)
                }
                return groups
            }
          difficulty: 2
        - id: v6
          title: Keys
          description: >-
            Write <code>func keys(m map[string]int) []string</code> that returns all keys of a map as a slice.
          functionSignature: func keys(m map[string]int) []string
          testCases:
            - input: "map[string]int{\"a\": 1, \"b\": 2}"
              output: "[]string{\"a\", \"b\"} (order may vary)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you range over a map, you get keys and values. How do you collect just the keys into a slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for k := range m to iterate only keys. Append each key to a result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. for k := range m:
                   - append k to result
                3. return result</pre>
          solution: |-
            func keys(m map[string]int) []string {
                result := []string{}
                for k := range m {
                    result = append(result, k)
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Values
          description: >-
            Write <code>func values(m map[string]int) []int</code> that returns all values of a map as a slice.
          functionSignature: func values(m map[string]int) []int
          testCases:
            - input: "map[string]int{\"a\": 1, \"b\": 2}"
              output: "[]int{1, 2} (order may vary)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Similar to extracting keys, but you want the values. How do you get just the value in a range
                loop?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for _, v := range m to iterate values. The underscore discards the key. Append each value to a
                result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. for _, v := range m:
                   - append v to result
                3. return result</pre>
          solution: |-
            func values(m map[string]int) []int {
                result := []int{}
                for _, v := range m {
                    result = append(result, v)
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Merge Maps
          description: >-
            Write <code>func mergeMaps(a, b map[string]int) map[string]int</code> that merges two maps into a
            new one. If both maps have the same key, the value from b wins.
          functionSignature: func mergeMaps(a, b map[string]int) map[string]int
          testCases:
            - input: "map[string]int{\"x\": 1}, map[string]int{\"x\": 2, \"y\": 3}"
              output: "map[string]int{\"x\": 2, \"y\": 3}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                If you copy a first and then b, any overlapping keys from b will overwrite those from a. Does
                order of copying matter?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a new map. Copy all entries from a, then copy all entries from b. Since b is copied second,
                its values win on conflicts.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make(map[string]int)
                2. for k, v := range a:
                   - result[k] = v
                3. for k, v := range b:
                   - result[k] = v
                4. return result</pre>
          solution: |-
            func mergeMaps(a, b map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range a {
                    result[k] = v
                }
                for k, v := range b {
                    result[k] = v
                }
                return result
            }
          difficulty: 2
        - id: v9
          title: Filter Map
          description: >-
            Write <code>func filterMap(m map[string]int, minValue int) map[string]int</code> that returns a new
            map containing only entries where the value is >= minValue.
          functionSignature: func filterMap(m map[string]int, minValue int) map[string]int
          testCases:
            - input: "map[string]int{\"a\": 1, \"b\": 5, \"c\": 3}, 3"
              output: "map[string]int{\"b\": 5, \"c\": 3}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You want to keep only some entries from the original map. How do you selectively copy entries?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a new map. Range over the original and only add entries where v >= minValue.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make(map[string]int)
                2. for k, v := range m:
                   - if v >= minValue: result[k] = v
                3. return result</pre>
          solution: |-
            func filterMap(m map[string]int, minValue int) map[string]int {
                result := make(map[string]int)
                for k, v := range m {
                    if v >= minValue {
                        result[k] = v
                    }
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Most Frequent
          description: >-
            Write <code>func mostFrequent(words []string) string</code> that returns the most frequently
            occurring word in the slice.
          functionSignature: func mostFrequent(words []string) string
          testCases:
            - input: "[]string{\"go\", \"rust\", \"go\", \"python\", \"go\"}"
              output: "\"go\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a two-step problem: first count, then find the max. What data structure helps you count
                occurrences?
            - title: "\U0001F4A1 Hint"
              content: >-
                Build a word count map first. Then iterate the map to find the key with the highest value, just
                like finding a max in a slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. counts := make(map[string]int)
                2. for _, w := range words:
                   - counts[w]++
                3. best := ""; bestCount := 0
                4. for k, v := range counts:
                   - if v > bestCount: best = k; bestCount = v
                5. return best</pre>
          solution: |-
            func mostFrequent(words []string) string {
                counts := make(map[string]int)
                for _, w := range words {
                    counts[w]++
                }
                best := ""
                bestCount := 0
                for k, v := range counts {
                    if v > bestCount {
                        best = k
                        bestCount = v
                    }
                }
                return best
            }
          difficulty: 3
        - id: v11
          title: Two Sum Map
          description: >-
            Write <code>func twoSumExists(nums []int, target int) bool</code> that uses a map to check if any
            two numbers in the slice sum to the target.
          functionSignature: func twoSumExists(nums []int, target int) bool
          testCases:
            - input: "[]int{2, 7, 11, 15}, 9"
              output: "true"
            - input: "[]int{2, 7, 11, 15}, 10"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each number, you need to know if its complement (target - number) has already appeared. What
                data structure gives you O(1) lookups?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a map[int]bool as a "seen" set. For each number, check if target - n is in the map. If yes,
                return true. Otherwise, add n to the map.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. seen := make(map[int]bool)
                2. for _, n := range nums:
                   - if seen[target - n]: return true
                   - seen[n] = true
                3. return false</pre>
          solution: |-
            func twoSumExists(nums []int, target int) bool {
                seen := make(map[int]bool)
                for _, n := range nums {
                    if seen[target-n] {
                        return true
                    }
                    seen[n] = true
                }
                return false
            }
          difficulty: 3
        - id: v12
          title: Histogram
          description: >-
            Write <code>func histogram(data []int) map[int]string</code> that creates a map where each key is a
            number from data and the value is a bar of "*" characters whose length equals the count of that number
            in data.
          functionSignature: func histogram(data []int) map[int]string
          testCases:
            - input: "[]int{1, 2, 2, 3, 3, 3}"
              output: "map[int]string{1: \"*\", 2: \"**\", 3: \"***\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a two-phase problem: first count occurrences, then convert counts to strings of repeated
                characters. How do you repeat a string in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                First build a count map. Then create a result map where each value is strings.Repeat("*", count).
                You will need to import "strings".
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. count := make(map[int]int)
                2. for _, n := range data:
                   - count[n]++
                3. result := make(map[int]string)
                4. for k, v := range count:
                   - result[k] = strings.Repeat("*", v)
                5. return result</pre>
          solution: |-
            func histogram(data []int) map[int]string {
                count := make(map[int]int)
                for _, n := range data {
                    count[n]++
                }
                result := make(map[int]string)
                for k, v := range count {
                    result[k] = strings.Repeat("*", v)
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Top Characters
          description: >-
            Write <code>func topChars(s string, n int) []string</code> that returns the n most frequent
            characters in s as strings, sorted by frequency in descending order.
          functionSignature: func topChars(s string, n int) []string
          testCases:
            - input: "\"aabbbcc\", 2"
              output: "[]string{\"b\", \"a\"} or []string{\"b\", \"c\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to count characters, sort them by frequency, and return the top n. How do you sort map
                entries in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                Count characters into a map. Extract unique characters into a slice. Sort the slice using
                sort.Slice with a custom comparator that compares counts. Return the first n entries as strings.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. counts := make(map[rune]int)
                2. for _, c := range s: counts[c]++
                3. chars := collect keys into []rune
                4. sort.Slice(chars, by descending count)
                5. result := first n chars as []string
                6. return result</pre>
          solution: |-
            func topChars(s string, n int) []string {
                counts := make(map[rune]int)
                for _, c := range s {
                    counts[c]++
                }
                chars := make([]rune, 0, len(counts))
                for c := range counts {
                    chars = append(chars, c)
                }
                sort.Slice(chars, func(i, j int) bool {
                    return counts[chars[i]] > counts[chars[j]]
                })
                result := make([]string, n)
                for i := 0; i < n; i++ {
                    result[i] = string(chars[i])
                }
                return result
            }
          difficulty: 3
    - id: challenge_12
      block: 1
      difficulty: 2
      concept: "Comma-Ok Pattern"
      docLinks:
        - url: https://go.dev/doc/effective_go#maps
          title: "Effective Go: Maps"
          note: comma-ok idiom
        - url: https://go.dev/ref/spec#Index_expressions
          title: "Go Spec: Index expressions"
          note: two-value form
      patternPrimer:
        bruteForce: Check if zero value means the key is missing (unreliable for int/string maps).
        bestApproach: "Always use value, ok := m[key] to distinguish missing keys from zero values."
        typical: "Comma-ok lookup is O(1) — same as regular map access, but safe."
      variants:
        - id: v1
          title: Safe Lookup
          description: >-
            Write <code>func safeLookup(m map[string]int, key string) (int, bool)</code> that returns the value for the
            given key and whether the key exists in the map.
          functionSignature: func safeLookup(m map[string]int, key string) (int, bool)
          testCases:
            - input: "map[string]int{\"a\": 1}, \"a\""
              output: "1, true"
            - input: "map[string]int{\"a\": 1}, \"z\""
              output: "0, false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you access a map key that doesn't exist, Go returns the zero value. How can you tell the difference
                between a missing key and a key whose value really is zero?
            - title: "\U0001F4A1 Hint"
              content: >-
                Go's comma-ok idiom lets you get two values from a map lookup: the value and a boolean indicating whether
                the key was found. Use <code>v, ok := m[key]</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use comma-ok: v, ok := m[key]
                2. Return both v and ok</pre>
          solution: |-
            func safeLookup(m map[string]int, key string) (int, bool) {
                v, ok := m[key]
                return v, ok
            }
          difficulty: 1
        - id: v2
          title: Get or Default
          description: >-
            Write <code>func getOrDefault(m map[string]int, key string, defaultVal int) int</code> that returns the value
            for the key if it exists, otherwise returns defaultVal.
          functionSignature: func getOrDefault(m map[string]int, key string, defaultVal int) int
          testCases:
            - input: "map[string]int{\"a\": 1}, \"a\", 99"
              output: "1"
            - input: "map[string]int{\"a\": 1}, \"z\", 99"
              output: "99"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check if the key exists before deciding what to return. What Go idiom lets you check
                existence and get the value at the same time?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the comma-ok pattern in an if statement: <code>if v, ok := m[key]; ok { return v }</code>. If the
                key is not found, fall through to return the default.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if v, ok := m[key]; ok → return v
                2. Otherwise → return defaultVal</pre>
          solution: |-
            func getOrDefault(m map[string]int, key string, defaultVal int) int {
                if v, ok := m[key]; ok {
                    return v
                }
                return defaultVal
            }
          difficulty: 1
        - id: v3
          title: Key Exists
          description: >-
            Write <code>func keyExists(m map[string]string, key string) bool</code> that returns true if the key is
            present in the map.
          functionSignature: func keyExists(m map[string]string, key string) bool
          testCases:
            - input: "map[string]string{\"go\": \"fun\"}, \"go\""
              output: "true"
            - input: "map[string]string{\"go\": \"fun\"}, \"rust\""
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You only care about whether the key is present, not its value. Is there a way to ignore the value and
                just get the boolean?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the blank identifier to discard the value: <code>_, ok := m[key]</code>. The ok boolean tells you
                if the key exists.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. _, ok := m[key]
                2. Return ok</pre>
          solution: |-
            func keyExists(m map[string]string, key string) bool {
                _, ok := m[key]
                return ok
            }
          difficulty: 1
        - id: v4
          title: Count Known Keys
          description: >-
            Write <code>func countKnown(m map[string]int, keys []string) int</code> that counts how many of the given
            keys exist in the map.
          functionSignature: func countKnown(m map[string]int, keys []string) int
          testCases:
            - input: "map[string]int{\"a\": 1, \"b\": 2}, []string{\"a\", \"c\", \"b\"}"
              output: "2"
            - input: "map[string]int{\"a\": 1}, []string{\"x\", \"y\"}"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to loop through the keys slice and check each one against the map. How do you count only the
                ones that are found?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a counter variable. For each key in the slice, use comma-ok to check if it exists in the map. If ok
                is true, increment the counter.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. count := 0
                2. For each key in keys:
                   - _, ok := m[key]
                   - If ok → count++
                3. Return count</pre>
          solution: |-
            func countKnown(m map[string]int, keys []string) int {
                count := 0
                for _, k := range keys {
                    if _, ok := m[k]; ok {
                        count++
                    }
                }
                return count
            }
          difficulty: 1
        - id: v5
          title: Get with Fallback
          description: >-
            Write <code>func getWithFallback(m map[string]string, key, fallback string) string</code> that returns
            m[key] if present, else fallback. Important: an empty string "" is a valid value, so you must use comma-ok
            to distinguish it from a missing key.
          functionSignature: func getWithFallback(m map[string]string, key, fallback string) string
          testCases:
            - input: "map[string]string{\"a\": \"\"}, \"a\", \"none\""
              output: "\"\""
              note: key "a" exists with value "", so return ""
            - input: "map[string]string{\"a\": \"\"}, \"z\", \"none\""
              output: "\"none\""
              note: key "z" does not exist, so return fallback
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Why can't you just check if m[key] == ""? Because "" might be a legitimate value stored in the map. You
                need a way to distinguish "key not found" from "key found with zero value."
            - title: "\U0001F4A1 Hint"
              content: >-
                The comma-ok pattern is essential here. <code>if v, ok := m[key]; ok</code> will correctly detect that
                the key exists even when its value is the zero value for the type.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if v, ok := m[key]; ok → return v
                2. Otherwise → return fallback</pre>
          solution: |-
            func getWithFallback(m map[string]string, key, fallback string) string {
                if v, ok := m[key]; ok {
                    return v
                }
                return fallback
            }
          difficulty: 2
        - id: v6
          title: First Found
          description: >-
            Write <code>func firstFound(m map[string]int, keys []string) (int, bool)</code> that tries each key in
            order and returns the value of the first key found in the map, along with true. If none are found, return
            0 and false.
          functionSignature: func firstFound(m map[string]int, keys []string) (int, bool)
          testCases:
            - input: "map[string]int{\"b\": 2}, []string{\"a\", \"b\", \"c\"}"
              output: "2, true"
            - input: "map[string]int{\"x\": 1}, []string{\"a\", \"b\", \"c\"}"
              output: "0, false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You want to try multiple keys in priority order. As soon as you find one that exists, you should stop
                looking and return it.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through the keys slice. For each key, use comma-ok to check the map. If ok is true, return the
                value immediately. If the loop finishes without finding anything, return 0 and false.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. For each key in keys:
                   - v, ok := m[key]
                   - If ok → return v, true
                2. Return 0, false</pre>
          solution: |-
            func firstFound(m map[string]int, keys []string) (int, bool) {
                for _, k := range keys {
                    if v, ok := m[k]; ok {
                        return v, true
                    }
                }
                return 0, false
            }
          difficulty: 2
        - id: v7
          title: Collect Found
          description: >-
            Write <code>func collectFound(m map[string]int, keys []string) []int</code> that returns the values for all
            keys that exist in the map, skipping any missing keys. The result preserves the order of the keys slice.
          functionSignature: func collectFound(m map[string]int, keys []string) []int
          testCases:
            - input: "map[string]int{\"a\": 1, \"c\": 3}, []string{\"a\", \"b\", \"c\"}"
              output: "[]int{1, 3}"
            - input: "map[string]int{\"x\": 10}, []string{\"a\", \"b\"}"
              output: "[]int{}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build a result slice containing only the values for keys that exist. How do you selectively
                add to a slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with an empty slice. For each key, use comma-ok to check the map. If the key exists, append its
                value to the result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. For each key in keys:
                   - v, ok := m[key]
                   - If ok → append v to result
                3. Return result</pre>
          solution: |-
            func collectFound(m map[string]int, keys []string) []int {
                result := []int{}
                for _, k := range keys {
                    if v, ok := m[k]; ok {
                        result = append(result, v)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Update If Exists
          description: >-
            Write <code>func updateIfExists(m map[string]int, key string, delta int) bool</code> that adds delta to
            the value of key if it exists in the map and returns true. If the key does not exist, return false without
            modifying the map.
          functionSignature: func updateIfExists(m map[string]int, key string, delta int) bool
          testCases:
            - input: "map[string]int{\"a\": 10}, \"a\", 5"
              output: "true"
              note: "map is now {\"a\": 15}"
            - input: "map[string]int{\"a\": 10}, \"z\", 5"
              output: "false"
              note: map is unchanged
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You only want to update the map if the key already exists. How can you conditionally modify a map entry?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use comma-ok to check if the key exists. If it does, update the value using <code>m[key] += delta</code>
                and return true. Otherwise return false.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. _, ok := m[key]
                2. If ok → m[key] += delta, return true
                3. Otherwise → return false</pre>
          solution: |-
            func updateIfExists(m map[string]int, key string, delta int) bool {
                if _, ok := m[key]; ok {
                    m[key] += delta
                    return true
                }
                return false
            }
          difficulty: 2
        - id: v9
          title: Difference
          description: >-
            Write <code>func difference(a, b map[string]int) map[string]int</code> that returns a new map containing
            all entries from a whose keys are NOT present in b.
          functionSignature: func difference(a, b map[string]int) map[string]int
          testCases:
            - input: "map[string]int{\"x\": 1, \"y\": 2}, map[string]int{\"y\": 3}"
              output: "map[string]int{\"x\": 1}"
            - input: "map[string]int{\"a\": 1}, map[string]int{\"a\": 2, \"b\": 3}"
              output: "map[string]int{}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You want entries from a that are absent in b. For each key in a, how do you check if b has that key?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through map a. For each key, use comma-ok on map b. If the key is NOT in b (ok is false), add it
                to your result map.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make(map[string]int)
                2. For each k, v in a:
                   - _, ok := b[k]
                   - If !ok → result[k] = v
                3. Return result</pre>
          solution: |-
            func difference(a, b map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range a {
                    if _, ok := b[k]; !ok {
                        result[k] = v
                    }
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Intersection
          description: >-
            Write <code>func intersection(a, b map[string]int) map[string]int</code> that returns a new map containing
            entries where the key exists in both maps. Use the values from map a.
          functionSignature: func intersection(a, b map[string]int) map[string]int
          testCases:
            - input: "map[string]int{\"x\": 1, \"y\": 2}, map[string]int{\"y\": 3, \"z\": 4}"
              output: "map[string]int{\"y\": 2}"
            - input: "map[string]int{\"a\": 1}, map[string]int{\"b\": 2}"
              output: "map[string]int{}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Intersection means keys that appear in both maps. For each key in a, how do you verify it also exists
                in b?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through map a. For each key, use comma-ok on map b. If the key IS in b (ok is true), add it to
                the result using a's value.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make(map[string]int)
                2. For each k, v in a:
                   - _, ok := b[k]
                   - If ok → result[k] = v
                3. Return result</pre>
          solution: |-
            func intersection(a, b map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range a {
                    if _, ok := b[k]; ok {
                        result[k] = v
                    }
                }
                return result
            }
          difficulty: 3
        - id: v11
          title: Get Nested
          description: >-
            Write <code>func getNestedValue(m map[string]map[string]int, outer, inner string) (int, bool)</code> that
            safely looks up a value in a nested map. Return the value and true if both the outer and inner keys exist,
            otherwise return 0 and false.
          functionSignature: func getNestedValue(m map[string]map[string]int, outer, inner string) (int, bool)
          testCases:
            - input: "map[string]map[string]int{\"a\": {\"x\": 1}}, \"a\", \"x\""
              output: "1, true"
            - input: "map[string]map[string]int{\"a\": {\"x\": 1}}, \"b\", \"x\""
              output: "0, false"
            - input: "map[string]map[string]int{\"a\": {\"x\": 1}}, \"a\", \"y\""
              output: "0, false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                With nested maps, you need two comma-ok checks: one for the outer key and one for the inner key. If
                either fails, the lookup fails.
            - title: "\U0001F4A1 Hint"
              content: >-
                First check if the outer key exists using comma-ok. If it does, check the inner key on the resulting
                inner map. Both must succeed for the lookup to return a valid value.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. innerMap, ok := m[outer]
                2. If !ok → return 0, false
                3. v, ok := innerMap[inner]
                4. Return v, ok</pre>
          solution: |-
            func getNestedValue(m map[string]map[string]int, outer, inner string) (int, bool) {
                innerMap, ok := m[outer]
                if !ok {
                    return 0, false
                }
                v, ok := innerMap[inner]
                return v, ok
            }
          difficulty: 3
        - id: v12
          title: Unique Values
          description: >-
            Write <code>func uniqueValues(m map[string]int) []int</code> that returns a slice of the unique values in
            the map (deduplicated). The order of the result does not matter.
          functionSignature: func uniqueValues(m map[string]int) []int
          testCases:
            - input: "map[string]int{\"a\": 1, \"b\": 2, \"c\": 1}"
              output: "[]int{1, 2}"
              note: order may vary
            - input: "map[string]int{\"x\": 5, \"y\": 5}"
              output: "[]int{5}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Multiple keys can have the same value. How do you collect values while making sure each unique value
                only appears once in the result?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a second map as a "seen" set for values. For each value in the original map, use comma-ok to check
                if you've already seen it. If not, add it to both the seen map and the result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. seen := make(map[int]bool)
                2. result := []int{}
                3. For each _, v in m:
                   - If !seen[v] → seen[v] = true, append v
                4. Return result</pre>
          solution: |-
            func uniqueValues(m map[string]int) []int {
                seen := make(map[int]bool)
                result := []int{}
                for _, v := range m {
                    if _, ok := seen[v]; !ok {
                        seen[v] = true
                        result = append(result, v)
                    }
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Translate
          description: >-
            Write <code>func translate(words []string, dictionary map[string]string) []string</code> that replaces each
            word with its translation from the dictionary if found, or keeps the original word if not found.
          functionSignature: func translate(words []string, dictionary map[string]string) []string
          testCases:
            - input: "[]string{\"hello\", \"world\"}, map[string]string{\"hello\": \"hola\"}"
              output: "[]string{\"hola\", \"world\"}"
            - input: "[]string{\"cat\", \"dog\"}, map[string]string{\"cat\": \"gato\", \"dog\": \"perro\"}"
              output: "[]string{\"gato\", \"perro\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each word, you need to check if a translation exists. If it does, use the translation; if not, keep
                the original. What pattern handles this check?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a result slice. For each word, use comma-ok on the dictionary. If ok, use the translated value.
                Otherwise, use the original word.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]string, len(words))
                2. For each i, word in words:
                   - t, ok := dictionary[word]
                   - If ok → result[i] = t
                   - Else → result[i] = word
                3. Return result</pre>
          solution: |-
            func translate(words []string, dictionary map[string]string) []string {
                result := make([]string, len(words))
                for i, w := range words {
                    if t, ok := dictionary[w]; ok {
                        result[i] = t
                    } else {
                        result[i] = w
                    }
                }
                return result
            }
          difficulty: 3
    - id: challenge_13
      block: 1
      difficulty: 2
      concept: "Strings & Runes"
      docLinks:
        - url: https://go.dev/blog/strings
          title: "Go Blog: Strings, bytes, runes and characters"
          note: string internals
        - url: https://go.dev/ref/spec#String_types
          title: "Go Spec: String types"
          note: string specification
      patternPrimer:
        bruteForce: Treat strings as byte arrays and hope for ASCII.
        bestApproach: "Use []rune(s) for Unicode-safe character operations; range over string iterates runes automatically."
        typical: "len(s) returns bytes; len([]rune(s)) returns character count. Know the difference."
      variants:
        - id: v1
          title: Rune Count
          description: >-
            Write <code>func runeCount(s string) int</code> that returns the number of runes (characters) in the
            string. Use <code>[]rune(s)</code> to convert and count correctly for Unicode strings.
          functionSignature: func runeCount(s string) int
          testCases:
            - input: "\"hello\""
              output: "5"
            - input: "\"caf\\u00e9\""
              output: "4"
              note: "cafe with accent: c-a-f-e is 4 runes"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The built-in len() function returns the number of bytes in a string, not the number of characters. For
                ASCII strings these are the same, but for Unicode they differ. How do you count actual characters?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert the string to a rune slice with <code>[]rune(s)</code>, then use len() on the rune slice. Each
                rune represents one Unicode character regardless of its byte size.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Convert string to []rune
                2. Return len of the rune slice</pre>
          solution: |-
            func runeCount(s string) int {
                return len([]rune(s))
            }
          difficulty: 1
        - id: v2
          title: Byte Count
          description: >-
            Write <code>func byteCount(s string) int</code> that returns the number of bytes in the string using
            the built-in <code>len()</code> function.
          functionSignature: func byteCount(s string) int
          testCases:
            - input: "\"hello\""
              output: "5"
            - input: "\"caf\\u00e9\""
              output: "5"
              note: "e-acute is 2 bytes in UTF-8, so cafe = 3 + 2 = 5 bytes"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go strings are sequences of bytes under the hood. The len() function on a string returns the byte count,
                not the character count. For multi-byte Unicode characters, these differ.
            - title: "\U0001F4A1 Hint"
              content: >-
                Simply use <code>len(s)</code> which returns the number of bytes. This is different from the rune count
                for strings containing multi-byte UTF-8 characters.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return len(s) — this counts bytes</pre>
          solution: |-
            func byteCount(s string) int {
                return len(s)
            }
          difficulty: 1
        - id: v3
          title: First Rune
          description: >-
            Write <code>func firstRune(s string) rune</code> that returns the first rune (character) of the string.
            You may assume the string is non-empty.
          functionSignature: func firstRune(s string) rune
          testCases:
            - input: "\"hello\""
              output: "'h'"
            - input: "\"caf\\u00e9\""
              output: "'c'"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Indexing a string with s[0] gives you a byte, not a rune. For ASCII strings this works, but for Unicode
                it may give you only part of a character. How do you safely get the first character?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to a rune slice first: <code>runes := []rune(s)</code>, then return <code>runes[0]</code>. This
                correctly handles multi-byte Unicode characters.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Convert s to []rune
                2. Return the first element runes[0]</pre>
          solution: |-
            func firstRune(s string) rune {
                runes := []rune(s)
                return runes[0]
            }
          difficulty: 1
        - id: v4
          title: Is ASCII
          description: >-
            Write <code>func isASCII(s string) bool</code> that returns true if all characters in the string are ASCII
            (rune value less than 128).
          functionSignature: func isASCII(s string) bool
          testCases:
            - input: "\"hello\""
              output: "true"
            - input: "\"caf\\u00e9\""
              output: "false"
              note: "e-acute has rune value > 127"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                ASCII characters have values 0-127. You need to check every character in the string. What Go construct
                iterates over runes in a string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>for _, r := range s</code> which iterates over runes. If any rune has a value greater than
                127, return false. If the loop finishes, all characters are ASCII.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. For each rune r in string:
                   - If r > 127 → return false
                2. Return true</pre>
          solution: |-
            func isASCII(s string) bool {
                for _, r := range s {
                    if r > 127 {
                        return false
                    }
                }
                return true
            }
          difficulty: 1
        - id: v5
          title: Reverse String
          description: >-
            Write <code>func reverseString(s string) string</code> that reverses a string correctly, handling Unicode
            characters safely by converting to a rune slice first.
          functionSignature: func reverseString(s string) string
          testCases:
            - input: "\"hello\""
              output: "\"olleh\""
            - input: "\"caf\\u00e9\""
              output: "\"\\u00e9fac\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Reversing a string byte-by-byte would break multi-byte Unicode characters. You need to reverse at the
                rune level. How do you swap elements from opposite ends of a slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to []rune, then use two pointers (i from start, j from end) to swap elements moving inward.
                Convert back to string when done.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. runes := []rune(s)
                2. Two pointers: i=0, j=len-1
                3. While i < j:
                   - Swap runes[i] and runes[j]
                   - i++, j--
                4. Return string(runes)</pre>
          solution: |-
            func reverseString(s string) string {
                runes := []rune(s)
                for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
                    runes[i], runes[j] = runes[j], runes[i]
                }
                return string(runes)
            }
          difficulty: 2
        - id: v6
          title: To Upper Manual
          description: >-
            Write <code>func toUpperManual(s string) string</code> that converts lowercase ASCII letters to uppercase
            by subtracting 32 from each rune value. Leave all other characters unchanged.
          functionSignature: func toUpperManual(s string) string
          testCases:
            - input: "\"hello\""
              output: "\"HELLO\""
            - input: "\"Go 123\""
              output: "\"GO 123\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                In ASCII, lowercase letters 'a' to 'z' are 32 positions higher than their uppercase counterparts 'A' to
                'Z'. How do you check if a rune is a lowercase letter?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to []rune. For each rune, check if it is between 'a' and 'z'. If so, subtract 32 to get the
                uppercase version. Leave other runes unchanged.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. runes := []rune(s)
                2. For each rune:
                   - If 'a' <= r <= 'z' → r -= 32
                3. Return string(runes)</pre>
          solution: |-
            func toUpperManual(s string) string {
                runes := []rune(s)
                for i, r := range runes {
                    if r >= 'a' && r <= 'z' {
                        runes[i] = r - 32
                    }
                }
                return string(runes)
            }
          difficulty: 2
        - id: v7
          title: Count Vowels
          description: >-
            Write <code>func countVowels(s string) int</code> that counts the number of vowels (a, e, i, o, u, both
            upper and lowercase) in the string.
          functionSignature: func countVowels(s string) int
          testCases:
            - input: "\"Hello World\""
              output: "3"
            - input: "\"AEIOU\""
              output: "5"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check each character against the set of vowels. How can you efficiently test if a character
                is one of several values?
            - title: "\U0001F4A1 Hint"
              content: >-
                Range over the string to get runes. For each rune, check if it is in the string "aeiouAEIOU" using
                <code>strings.ContainsRune</code> or a manual comparison loop.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. count := 0
                2. For each rune r in s:
                   - If r is a vowel → count++
                3. Return count</pre>
          solution: |-
            func countVowels(s string) int {
                count := 0
                vowels := "aeiouAEIOU"
                for _, r := range s {
                    for _, v := range vowels {
                        if r == v {
                            count++
                            break
                        }
                    }
                }
                return count
            }
          difficulty: 2
        - id: v8
          title: Capitalize First
          description: >-
            Write <code>func capitalizeFirst(s string) string</code> that capitalizes the first character of the string
            and leaves the rest unchanged. If the first character is not a lowercase letter, return the string as-is.
          functionSignature: func capitalizeFirst(s string) string
          testCases:
            - input: "\"hello\""
              output: "\"Hello\""
            - input: "\"Go\""
              output: "\"Go\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You only need to modify the first character. Convert to runes so you can safely access and modify the
                first character, then convert back.
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to []rune. Check if the first rune is between 'a' and 'z'. If so, subtract 32 to capitalize it.
                Convert back to string.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. runes := []rune(s)
                2. If len > 0 and runes[0] is lowercase:
                   - runes[0] -= 32
                3. Return string(runes)</pre>
          solution: |-
            func capitalizeFirst(s string) string {
                runes := []rune(s)
                if len(runes) > 0 && runes[0] >= 'a' && runes[0] <= 'z' {
                    runes[0] -= 32
                }
                return string(runes)
            }
          difficulty: 2
        - id: v9
          title: Is Palindrome
          description: >-
            Write <code>func isPalindrome(s string) bool</code> that checks if the string reads the same forwards and
            backwards. Handle Unicode correctly by converting to runes.
          functionSignature: func isPalindrome(s string) bool
          testCases:
            - input: "\"racecar\""
              output: "true"
            - input: "\"hello\""
              output: "false"
            - input: "\"a\""
              output: "true"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A palindrome reads the same from both ends. You can compare characters from the start and end moving
                inward. If any pair doesn't match, it's not a palindrome.
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to []rune for Unicode safety. Use two pointers starting at opposite ends. Compare runes[i] and
                runes[j] as you move inward. If all pairs match, it's a palindrome.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. runes := []rune(s)
                2. i := 0, j := len(runes) - 1
                3. While i < j:
                   - If runes[i] != runes[j] → return false
                   - i++, j--
                4. Return true</pre>
          solution: |-
            func isPalindrome(s string) bool {
                runes := []rune(s)
                for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
                    if runes[i] != runes[j] {
                        return false
                    }
                }
                return true
            }
          difficulty: 2
        - id: v10
          title: Bytes vs Runes
          description: >-
            Write <code>func bytesAndRunes(s string) (int, int)</code> that returns both the byte count and the rune
            count of the string as a pair.
          functionSignature: func bytesAndRunes(s string) (int, int)
          testCases:
            - input: "\"caf\\u00e9\""
              output: "5, 4"
              note: "5 bytes (e-acute is 2 bytes), 4 runes"
            - input: "\"hello\""
              output: "5, 5"
              note: all ASCII, so bytes == runes
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You already know how to count bytes and runes separately. This function combines both. What two built-in
                operations give you each count?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>len(s)</code> for byte count and <code>len([]rune(s))</code> for rune count. Return both
                values using Go's multiple return syntax.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. bytes := len(s)
                2. runes := len([]rune(s))
                3. Return bytes, runes</pre>
          solution: |-
            func bytesAndRunes(s string) (int, int) {
                return len(s), len([]rune(s))
            }
          difficulty: 3
        - id: v11
          title: Caesar Cipher
          description: >-
            Write <code>func caesarCipher(s string, shift int) string</code> that shifts each lowercase letter by
            shift positions in the alphabet, wrapping around from z to a. Leave non-lowercase characters unchanged.
          functionSignature: func caesarCipher(s string, shift int) string
          testCases:
            - input: "\"abc\", 1"
              output: "\"bcd\""
            - input: "\"xyz\", 3"
              output: "\"abc\""
            - input: "\"hello\", 0"
              output: "\"hello\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To wrap around the alphabet, you need modular arithmetic. If you shift 'z' by 1, it should become 'a'.
                How can you use the modulo operator to handle this wrapping?
            - title: "\U0001F4A1 Hint"
              content: >-
                For each lowercase rune, compute its position (r - 'a'), add the shift, take modulo 26 to wrap, then
                add 'a' back. Use <code>'a' + (r - 'a' + rune(shift)) % 26</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. runes := []rune(s)
                2. For each rune:
                   - If 'a' <= r <= 'z':
                     - runes[i] = 'a' + (r - 'a' + shift) % 26
                3. Return string(runes)</pre>
          solution: |-
            func caesarCipher(s string, shift int) string {
                runes := []rune(s)
                for i, r := range runes {
                    if r >= 'a' && r <= 'z' {
                        runes[i] = 'a' + (r-'a'+rune(shift))%26
                    }
                }
                return string(runes)
            }
          difficulty: 3
        - id: v12
          title: Run Length Encode
          description: >-
            Write <code>func runLengthEncode(s string) string</code> that encodes consecutive repeated characters as
            the count followed by the character. For example, "aaabbc" becomes "3a2b1c".
          functionSignature: func runLengthEncode(s string) string
          testCases:
            - input: "\"aaabbc\""
              output: "\"3a2b1c\""
            - input: "\"abc\""
              output: "\"1a1b1c\""
            - input: "\"\""
              output: "\"\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to track runs of consecutive identical characters. As you scan, keep a count of the current
                character. When the character changes, output the count and character, then reset.
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to runes. Track the current count starting at 1. Compare each rune to the previous one. When
                they differ, append the count and previous character to the result using
                <code>fmt.Sprintf("%d%c", ...)</code>, then reset the count.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If empty → return ""
                2. runes := []rune(s), count := 1
                3. For i from 1 to len(runes):
                   - If runes[i] == runes[i-1] → count++
                   - Else → append count + runes[i-1], reset count
                4. Append final count + last rune
                5. Return result</pre>
          solution: |-
            func runLengthEncode(s string) string {
                if s == "" {
                    return ""
                }
                runes := []rune(s)
                result := ""
                count := 1
                for i := 1; i < len(runes); i++ {
                    if runes[i] == runes[i-1] {
                        count++
                    } else {
                        result += fmt.Sprintf("%d%c", count, runes[i-1])
                        count = 1
                    }
                }
                result += fmt.Sprintf("%d%c", count, runes[len(runes)-1])
                return result
            }
          difficulty: 3
        - id: v13
          title: Truncate with Ellipsis
          description: >-
            Write <code>func truncate(s string, maxRunes int) string</code> that truncates the string if it has more
            than maxRunes characters. When truncating, the result (including the "..." suffix) must be at most maxRunes
            characters. If the string fits within maxRunes, return it unchanged.
          functionSignature: func truncate(s string, maxRunes int) string
          testCases:
            - input: "\"Hello World\", 8"
              output: "\"Hello...\""
              note: "5 chars + 3 dots = 8"
            - input: "\"Hi\", 8"
              output: "\"Hi\""
              note: fits within limit, no truncation
            - input: "\"abcdef\", 5"
              output: "\"ab...\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you truncate, the "..." takes up 3 characters of your budget. So you can only keep maxRunes - 3
                characters of the original string before adding the ellipsis.
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to runes for correct Unicode handling. If the rune count is within the limit, return as-is.
                Otherwise, take the first maxRunes-3 runes and append "...".
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. runes := []rune(s)
                2. If len(runes) <= maxRunes → return s
                3. Return string(runes[:maxRunes-3]) + "..."</pre>
          solution: |-
            func truncate(s string, maxRunes int) string {
                runes := []rune(s)
                if len(runes) <= maxRunes {
                    return s
                }
                return string(runes[:maxRunes-3]) + "..."
            }
          difficulty: 3
    - id: challenge_14
      block: 1
      difficulty: 3
      concept: "Go Fundamentals Combined"
      docLinks:
        - url: https://go.dev/doc/effective_go
          title: "Effective Go"
          note: comprehensive Go guide
        - url: https://go.dev/tour/welcome/1
          title: "A Tour of Go"
          note: complete Go tutorial
      patternPrimer:
        bruteForce: Solve each sub-problem independently without leveraging Go idioms.
        bestApproach: Combine slices, maps, loops, functions, and error handling into cohesive solutions using idiomatic Go.
        typical: Multi-step problems test your ability to choose the right tool from your Go toolkit.
      variants:
        - id: v1
          title: Word Frequency
          description: >-
            Write <code>func wordFrequency(words []string) map[string]int</code> that counts how many times each word
            appears in the slice and returns a map of word to count.
          functionSignature: func wordFrequency(words []string) map[string]int
          testCases:
            - input: "[]string{\"the\", \"cat\", \"the\", \"hat\"}"
              output: "map[string]int{\"the\": 2, \"cat\": 1, \"hat\": 1}"
            - input: "[]string{\"go\", \"go\", \"go\"}"
              output: "map[string]int{\"go\": 3}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to count occurrences. What data structure lets you associate each word with a count that you
                can easily increment?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a map with <code>make(map[string]int)</code>. Loop through the words and increment each word's
                count with <code>freq[w]++</code>. The zero value for int is 0, so missing keys start at 0.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. freq := make(map[string]int)
                2. For each word:
                   - freq[word]++
                3. Return freq</pre>
          solution: |-
            func wordFrequency(words []string) map[string]int {
                freq := make(map[string]int)
                for _, w := range words {
                    freq[w]++
                }
                return freq
            }
          difficulty: 1
        - id: v2
          title: Grade Calculator
          description: >-
            Write <code>func letterGrade(score int) string</code> that returns "A" for scores >= 90, "B" for >= 80,
            "C" for >= 70, "D" for >= 60, and "F" for anything below 60.
          functionSignature: func letterGrade(score int) string
          testCases:
            - input: "85"
              output: "\"B\""
            - input: "55"
              output: "\"F\""
            - input: "92"
              output: "\"A\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You have multiple thresholds to check. What Go construct lets you check conditions in order and take
                different actions?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use if/else if chains, checking from highest threshold to lowest. Once a condition matches, return the
                corresponding grade letter.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If score >= 90 → return "A"
                2. Else if score >= 80 → return "B"
                3. Else if score >= 70 → return "C"
                4. Else if score >= 60 → return "D"
                5. Else → return "F"</pre>
          solution: |-
            func letterGrade(score int) string {
                if score >= 90 {
                    return "A"
                } else if score >= 80 {
                    return "B"
                } else if score >= 70 {
                    return "C"
                } else if score >= 60 {
                    return "D"
                }
                return "F"
            }
          difficulty: 1
        - id: v3
          title: Sum Even Numbers
          description: >-
            Write <code>func sumEven(nums []int) int</code> that returns the sum of only the even numbers in the
            slice.
          functionSignature: func sumEven(nums []int) int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5, 6}"
              output: "12"
              note: 2 + 4 + 6 = 12
            - input: "[]int{1, 3, 5}"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to combine filtering (only even numbers) with accumulation (summing them). How do you check if
                a number is even?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the modulo operator: <code>n % 2 == 0</code> means even. Loop through and only add even numbers to
                your running sum.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. sum := 0
                2. For each num:
                   - If num % 2 == 0 → sum += num
                3. Return sum</pre>
          solution: |-
            func sumEven(nums []int) int {
                sum := 0
                for _, n := range nums {
                    if n%2 == 0 {
                        sum += n
                    }
                }
                return sum
            }
          difficulty: 1
        - id: v4
          title: Count Words in Sentence
          description: >-
            Write <code>func countWords(sentence string) int</code> that counts the number of words in a sentence.
            Use <code>strings.Fields()</code> which splits on any whitespace and handles multiple spaces correctly.
          functionSignature: func countWords(sentence string) int
          testCases:
            - input: "\"hello world\""
              output: "2"
            - input: "\"  go  is  fun  \""
              output: "3"
              note: strings.Fields handles extra whitespace
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Splitting by a single space won't handle multiple spaces or leading/trailing whitespace correctly. What
                standard library function handles this for you?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields(sentence)</code> which splits on any whitespace and ignores leading, trailing,
                and consecutive spaces. Then just return the length of the resulting slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. words := strings.Fields(sentence)
                2. Return len(words)</pre>
          solution: |-
            func countWords(sentence string) int {
                return len(strings.Fields(sentence))
            }
          difficulty: 1
        - id: v5
          title: Unique Words
          description: >-
            Write <code>func uniqueWords(words []string) []string</code> that returns the unique words from the slice,
            preserving the order of their first occurrence.
          functionSignature: func uniqueWords(words []string) []string
          testCases:
            - input: "[]string{\"go\", \"rust\", \"go\", \"python\"}"
              output: "[]string{\"go\", \"rust\", \"python\"}"
            - input: "[]string{\"a\", \"a\", \"a\"}"
              output: "[]string{\"a\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to track which words you've already seen while also preserving order. A map alone won't
                preserve order. What combination of data structures works here?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a map as a "seen" set and a slice for the result. For each word, check the map. If the word hasn't
                been seen, add it to both the map and the result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. seen := make(map[string]bool)
                2. result := []string{}
                3. For each word:
                   - If !seen[word]:
                     - seen[word] = true
                     - Append word to result
                4. Return result</pre>
          solution: |-
            func uniqueWords(words []string) []string {
                seen := make(map[string]bool)
                result := []string{}
                for _, w := range words {
                    if !seen[w] {
                        seen[w] = true
                        result = append(result, w)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v6
          title: Student Average
          description: >-
            Write <code>func studentAverage(scores map[string][]int) map[string]float64</code> that takes a map of
            student names to their score slices and returns a map of student names to their average score.
          functionSignature: func studentAverage(scores map[string][]int) map[string]float64
          testCases:
            - input: "map[string][]int{\"alice\": {80, 90}, \"bob\": {70, 80, 90}}"
              output: "map[string]float64{\"alice\": 85.0, \"bob\": 80.0}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each student, you need to sum their scores and divide by the count. This combines map iteration with
                slice accumulation. How do you convert int sums to float64 for division?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a result map. For each student, sum their scores using a loop, then divide by the number of
                scores. Use <code>float64(sum) / float64(len(scores))</code> for the average.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make(map[string]float64)
                2. For each name, scores in map:
                   - sum all scores
                   - result[name] = float64(sum) / float64(len(scores))
                3. Return result</pre>
          solution: |-
            func studentAverage(scores map[string][]int) map[string]float64 {
                result := make(map[string]float64)
                for name, sc := range scores {
                    sum := 0
                    for _, s := range sc {
                        sum += s
                    }
                    result[name] = float64(sum) / float64(len(sc))
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Inventory Check
          description: >-
            Write <code>func inStock(inventory map[string]int, items []string) []string</code> that returns the items
            from the list that are present in the inventory map with a count greater than 0.
          functionSignature: func inStock(inventory map[string]int, items []string) []string
          testCases:
            - input: "map[string]int{\"pen\": 5, \"paper\": 0, \"ink\": 3}, []string{\"pen\", \"paper\", \"stapler\"}"
              output: "[]string{\"pen\"}"
              note: "paper has count 0, stapler is missing"
            - input: "map[string]int{\"a\": 1, \"b\": 2}, []string{\"a\", \"b\"}"
              output: "[]string{\"a\", \"b\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need two checks for each item: does the key exist in the inventory map, and is the quantity greater
                than zero? How can you combine comma-ok with a value check?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through the items slice. For each item, use comma-ok to look it up in the inventory. If ok is true
                AND the quantity is greater than 0, add it to the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. For each item in items:
                   - qty, ok := inventory[item]
                   - If ok && qty > 0 → append item
                3. Return result</pre>
          solution: |-
            func inStock(inventory map[string]int, items []string) []string {
                result := []string{}
                for _, item := range items {
                    if qty, ok := inventory[item]; ok && qty > 0 {
                        result = append(result, item)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Remove Duplicates Sorted
          description: >-
            Write <code>func removeDupsSorted(nums []int) []int</code> that removes duplicates from a sorted slice,
            keeping only the first occurrence of each value.
          functionSignature: func removeDupsSorted(nums []int) []int
          testCases:
            - input: "[]int{1, 1, 2, 3, 3, 3, 4}"
              output: "[]int{1, 2, 3, 4}"
            - input: "[]int{5, 5, 5}"
              output: "[]int{5}"
            - input: "[]int{}"
              output: "[]int{}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Since the slice is sorted, all duplicates are adjacent. You only need to compare each element to the
                previous one. How do you build a new slice with only the unique elements?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with the first element in the result. For each subsequent element, compare it to the previous one.
                If it's different, append it to the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If empty → return empty
                2. result := []int{nums[0]}
                3. For i from 1 to len:
                   - If nums[i] != nums[i-1] → append
                4. Return result</pre>
          solution: |-
            func removeDupsSorted(nums []int) []int {
                if len(nums) == 0 {
                    return nums
                }
                result := []int{nums[0]}
                for i := 1; i < len(nums); i++ {
                    if nums[i] != nums[i-1] {
                        result = append(result, nums[i])
                    }
                }
                return result
            }
          difficulty: 2
        - id: v9
          title: Title Case
          description: >-
            Write <code>func titleCase(s string) string</code> that capitalizes the first letter of each word in the
            string. Use <code>strings.Fields</code> to split and <code>strings.Join</code> to reassemble.
          functionSignature: func titleCase(s string) string
          testCases:
            - input: "\"hello world\""
              output: "\"Hello World\""
            - input: "\"go is fun\""
              output: "\"Go Is Fun\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to split the string into words, capitalize the first character of each word, and join them back
                together. This combines string splitting, rune manipulation, and string building.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields(s)</code> to split into words. For each word, convert to runes, uppercase the
                first rune, convert back. Use <code>strings.Join</code> to combine with spaces.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. words := strings.Fields(s)
                2. For each word:
                   - Convert to []rune
                   - Uppercase first rune
                   - Convert back to string
                3. Return strings.Join(words, " ")</pre>
          solution: |-
            func titleCase(s string) string {
                words := strings.Fields(s)
                for i, w := range words {
                    runes := []rune(w)
                    if len(runes) > 0 && runes[0] >= 'a' && runes[0] <= 'z' {
                        runes[0] -= 32
                    }
                    words[i] = string(runes)
                }
                return strings.Join(words, " ")
            }
          difficulty: 2
        - id: v10
          title: Validate Password
          description: >-
            Write <code>func validatePassword(password string) (bool, []string)</code> that validates a password
            against these rules: length >= 8, contains at least one uppercase letter, one lowercase letter, and one
            digit. Return true with an empty slice if valid, or false with a slice of failure messages.
          functionSignature: func validatePassword(password string) (bool, []string)
          testCases:
            - input: "\"Abc12345\""
              output: "true, []string{}"
            - input: "\"abc\""
              output: "false, []string{\"too short\", \"no uppercase\", \"no digit\"}"
            - input: "\"ABCDEFGH\""
              output: "false, []string{\"no lowercase\", \"no digit\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check multiple independent conditions and collect all failure messages. How do you track
                which conditions have been met as you scan the string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use boolean flags for hasUpper, hasLower, hasDigit. Loop through the string's runes to set the flags.
                After the loop, check each condition and build a list of failure messages.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Check length, set flags to false
                2. For each rune in password:
                   - Set hasUpper/hasLower/hasDigit flags
                3. Collect failure messages
                4. Return len(failures) == 0, failures</pre>
          solution: |-
            func validatePassword(password string) (bool, []string) {
                failures := []string{}
                if len([]rune(password)) < 8 {
                    failures = append(failures, "too short")
                }
                hasUpper, hasLower, hasDigit := false, false, false
                for _, r := range password {
                    if r >= 'A' && r <= 'Z' {
                        hasUpper = true
                    }
                    if r >= 'a' && r <= 'z' {
                        hasLower = true
                    }
                    if r >= '0' && r <= '9' {
                        hasDigit = true
                    }
                }
                if !hasUpper {
                    failures = append(failures, "no uppercase")
                }
                if !hasLower {
                    failures = append(failures, "no lowercase")
                }
                if !hasDigit {
                    failures = append(failures, "no digit")
                }
                return len(failures) == 0, failures
            }
          difficulty: 3
        - id: v11
          title: Anagram Check
          description: >-
            Write <code>func areAnagrams(a, b string) bool</code> that checks if two strings are anagrams of each
            other (contain exactly the same characters in any order).
          functionSignature: func areAnagrams(a, b string) bool
          testCases:
            - input: "\"listen\", \"silent\""
              output: "true"
            - input: "\"hello\", \"world\""
              output: "false"
            - input: "\"aab\", \"aba\""
              output: "true"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Two strings are anagrams if they have exactly the same character frequencies. How can you count
                character frequencies and compare them?
            - title: "\U0001F4A1 Hint"
              content: >-
                Count the frequency of each rune in both strings using maps. Then compare the two maps: they must have
                the same keys with the same counts. Or, increment for one string and decrement for the other, checking
                all counts are zero.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Count rune frequencies of string a into a map
                2. For each rune in b, decrement the count
                3. Check all counts are zero
                (or build two maps and compare)</pre>
          solution: |-
            func areAnagrams(a, b string) bool {
                counts := make(map[rune]int)
                for _, r := range a {
                    counts[r]++
                }
                for _, r := range b {
                    counts[r]--
                }
                for _, c := range counts {
                    if c != 0 {
                        return false
                    }
                }
                return true
            }
          difficulty: 3
        - id: v12
          title: Matrix Sum
          description: >-
            Write <code>func matrixSum(matrix [][]int) int</code> that returns the sum of all elements in a 2D slice
            (matrix).
          functionSignature: func matrixSum(matrix [][]int) int
          testCases:
            - input: "[][]int{{1, 2}, {3, 4}, {5, 6}}"
              output: "21"
            - input: "[][]int{{10}, {20}, {30}}"
              output: "60"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A 2D slice is a slice of slices. You need to iterate through two levels: the outer slice (rows) and
                each inner slice (columns). How do you nest range loops?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use nested range loops. The outer loop iterates over rows, the inner loop iterates over elements in
                each row. Add each element to a running sum.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. sum := 0
                2. For each row in matrix:
                   - For each element in row:
                     - sum += element
                3. Return sum</pre>
          solution: |-
            func matrixSum(matrix [][]int) int {
                sum := 0
                for _, row := range matrix {
                    for _, n := range row {
                        sum += n
                    }
                }
                return sum
            }
          difficulty: 3
        - id: v13
          title: Group and Count
          description: >-
            Write <code>func groupAndCount(items []string) []string</code> that counts the frequency of each item and
            returns formatted strings "item: N" sorted by count descending, then alphabetically for ties.
          functionSignature: func groupAndCount(items []string) []string
          testCases:
            - input: "[]string{\"b\", \"a\", \"b\", \"a\", \"a\"}"
              output: "[]string{\"a: 3\", \"b: 2\"}"
            - input: "[]string{\"x\", \"y\", \"x\", \"y\"}"
              output: "[]string{\"x: 2\", \"y: 2\"}"
              note: same count, sorted alphabetically
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This problem has multiple steps: count frequencies, sort by count then alphabetically, and format the
                output. Break it into sub-problems.
            - title: "\U0001F4A1 Hint"
              content: >-
                First count frequencies with a map. Collect the unique keys into a slice. Sort the slice using
                <code>sort.Slice</code> with a custom less function that compares counts first, then names. Finally,
                format each entry with <code>fmt.Sprintf</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Count frequencies into a map
                2. Collect unique keys into a slice
                3. Sort: by count descending, then alphabetically
                4. Format each as "item: N"
                5. Return formatted slice</pre>
          solution: |-
            func groupAndCount(items []string) []string {
                freq := make(map[string]int)
                for _, item := range items {
                    freq[item]++
                }
                keys := []string{}
                for k := range freq {
                    keys = append(keys, k)
                }
                sort.Slice(keys, func(i, j int) bool {
                    if freq[keys[i]] != freq[keys[j]] {
                        return freq[keys[i]] > freq[keys[j]]
                    }
                    return keys[i] < keys[j]
                })
                result := []string{}
                for _, k := range keys {
                    result = append(result, fmt.Sprintf("%s: %d", k, freq[k]))
                }
                return result
            }
          difficulty: 3
